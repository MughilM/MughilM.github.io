


{
  "pages": [
    {
      
      
      
      "content": "\n",
      "url": "/404.html"
    },{
      
      "title": "Config",
      "description": "This chapter covers the many configuration options of Hydejack, allowing you to tailor it to your needs.\n",
      "content": "Once Jekyll is running, you can start with basic configuration by adding various entries to _config.yml. \nBesides the documentation here, you can also read the annotated config file.\n\nWhen making changes to _config.yml, it is necessary to restart the Jekyll process for changes to take effect.\n\n\n  Setting url and baseurl    \n      GitHub Pages\n    \n  \n  Changing accent colors and sidebar images    \n      Theme color\n    \n  \n  Changing fonts    \n      Removing Google Fonts\n    \n  \n  Choosing a blog layout    \n      Using the blog layout in a subdirectory\n    \n  \n  Adding an author    \n      Adding an author’s picture\n      Adding social media icons\n      Adding an email, RSS icon or download icon\n    \n  \n  Enabling comments\n  Enabling Google Analytics    \n      Using a custom analytics provider\n    \n  \n  Changing built-in strings\n  Adding legal documents\n  Enabling math blocks\n  Adding custom Favicons and App Icons    \n      Changing the Favicon\n      Changing the App Icons\n    \n  \n  Adding a cookies banner*\n  Enabling newsletter boxes*\n  Enabling Dark Mode*\n\n\nSetting url and baseurl\nThe first order of business should be to set the correct url and baseurl values in _config.yml.\n\nThe url is the domain of your site, including the protocol (http or https). For this site, it is\n\n# file: `_config.yml`\nurl: https://qwtel.com\n\n\nYou don’t need to provide this property when hosting on GitHub Pages or Netlify.\n\nIf your entire Jekyll blog is hosted in a subdirectory of your page, provide the path in baseurl with a leading /, but no trailing /,\ne.g.\n\n# file: `_config.yml`\nbaseurl: /hydejack\n\n\nOtherwise, provide the empty string ''\n\nYou don’t need to provide this property when hosting on GitHub Pages or Netlify.\n\nGitHub Pages\nWhen hosting on GitHub Pages the url is https://&lt;username&gt;.github.io\n(unless you are using a custom domain).\n\nThe baseurl depends on the kind of page you are hosting.\n\n\n  When hosting a user or organization page, use the empty string ''.\n  When hosting project page, use /&lt;reponame&gt;.\n\n\nFor for information on the types of pages you can host on GitHub, see the\nGitHub Help article.\n\nChanging accent colors and sidebar images\nHydejack allows you to choose the background image of the sidebar, as well as the accent color\n(color of the links, selection and focus outline, etc…).\n\n# file: `_config.yml`\naccent_image: /assets/img/sidebar-bg.jpg\naccent_color: rgb(79,177,186)\n\n\nI recommend using a blurred image in order for the text to remain readable.\nIf you save a blurred image as JPG, it will also drastically reduce its file size.\n\nThe accent_image property also accepts the special value none which will remove the default image.\n\nIf your sidebar image contains bright colors, the white text can be difficult to read. In this case, consider setting\ninvert_sidebar: true in the front matter to invert the text colors in the sidebar. \nUse front matter defaults to enable this on all pages (see below).\n\nNote that these values can be overwritten on a per-page basis, i.e. you can create a unique look for each page.\nYou can also apply a certain look to all posts in a category via front matter defaults, e.g.:\n\n# file: `_config.yml`\ndefaults:\n  - scope:\n      path:         hydejack/\n    values:\n      accent_image: /assets/img/hydejack-bg.jpg\n      accent_color: rgb(38,139,210)\n\n\nTheme color\nHydejack also supports the theme_color property. When set, it will change the background color of the sidebar, as well as set the theme_color property in the Web App Manifest. In some browsers, such as Chrome on Android, this will change the color of the browser’s UI components.\n\n# file: `_config.yml`\ntheme_color:  rgb(25,55,71)\n\n\nJust like accent_* properties, the theme color can be overridden on a per-page basis by setting it in the front matter.\n\nChanging fonts\nHydejack lets you configure the font of regular text and headlines, and it has built-in support for Google Fonts.\nThere are three keys in _config.yml associated with this: font, font_heading and google_fonts.\nThe defaults are:\n\n# file: `_config.yml`\nfont:         Noto Sans, Helvetica, Arial, sans-serif\nfont_heading: Roboto Slab, Helvetica, Arial, sans-serif\ngoogle_fonts: Roboto+Slab:700|Noto+Sans:400,400i,700,700i\n\n\nfont and font_heading must be valid CSS font-family values. When using Google Fonts make sure to provide at least one fallback.\n\nThe google_fonts key is the string necessary to fetch the fonts from Google.\nYou can get it from the download page at Google Fonts after you’ve selected one or more fonts:\n\n\n\nRemoving Google Fonts\nIf you prefer not to use Google Fonts and remove all associated code from the site,\nset the google_fonts key to false.\n\nThe no_google_fonts parameter has been removed in v9 and no longer has any effect.\n\nChoosing a blog layout\nHydejack features three layouts for showing your blog posts.\n\n\n  The list layout only shows the title and groups the posts by year of publication.\n  The grid layout* is exclusive to the PRO Version and will show a content card (with image) for each post.\n  The blog layout is a traditional paginated layout and shows the title and an excerpt of each post.\n\n\nIn order to use the list or grid layout add the following front-matter to a new markdown file:\n\n---\nlayout: list # or `grid`\ntitle:  Home\n---\n\n\nIf you want to use the blog layout, you need to add jekyll-paginate to your Gemfile and to the plugins list in your config file:\n\n# file: `Gemfile`\ngem \"jekyll-paginate\"\n\n\n# file: `_config.yml`\nplugins:\n  - jekyll-paginate\n\n\nYou also need to add the paginate and paginate_path keys to your config file, e.g.\n\n# file: `_config.yml`\npaginate:      10\npaginate_path: '/:num/'\n\n\nThe blog layout needs to be applied to a file with the .html file extension\nand the paginate_path needs to match the path to the index.html file.\nTo match the paginate_path above, put a index.html with the following front matter in the root directory:\n\n# file: `index.html`\n---\nlayout: blog\ntitle: Blog\n---\n\n\nFor more information see Pagination.\n\nUsing the blog layout in a subdirectory\nIf you want to use the blog layout at a URL like /my-blog/, create the following folder structure:\n\n├── my-blog\n│   └── index.html\n└── _config.yml\n\n\nYou can use the same index.html as before and place it in the subdirectory.\n\n# file: `my-blog/index.html`\n---\nlayout: blog\ntitle: Blog\n---\n\n\nIn your config file, make sure the paginate_path matches the name of the subdirectory:\n\n# file: `_config.yml`\npaginate:      10\npaginate_path: /my-blog/:num/ #!!\n\n\nTo add an entry in the sidebar to your blog directory, see Adding an entry to the sidebar.\n\nAdding an author\nAt a bare minimum, you should add an author key with a name and email sub-key\n(used by the feed plugin) to to your config file:\n\n# file: `_config.yml`\nauthor:\n  name:  Florian Klampfer\n  email: mail@qwtel.com\n\n\nIf you would like the author to be displayed in the about section below a post or project*, add an about key and provide markdown content. I recommend using the YAML pipe | syntax, so you can include multiple paragraphs:\n\n# file: `_config.yml`\nauthor:\n  name:  Florian Klampfer\n  email: mail@qwtel.com\n  about: |\n    Hi, I'm Florian or @qwtel...\n\n    This is another paragraph.\n\n\nAdding an author’s picture\nIf you’d like for the author’s picture to appear in addition the about text (see above), you can either use the jekyll-avatar plugin or provide URLs to images manually.\n\nTo use the plugin, add it to your Gemfile and the list of plugins in your config file:\n\n# file: `Gemfile`\ngem \"jekyll-avatar\"\n\n\n# file: `_config.yml`\nplugins:\n  - jekyll-avatar\n\n\nRun bundle install for the changes to take effect.\n\nMake sure you have provided a GitHub username in your config file (github_username),\nor to the author key (author.social.github, author.github.username, or author.github).\nSee Adding social media icons for more.\n\nTo set an image manually, you have to provide an URL to the author’s picture key:\n\n# file: `_config.yml`\nauthor:\n  picture:  /assets/img/me.jpg\n\n\nIf you’d like to provide multiple versions for screens with different pixel densities,\nyou can provide path and srcset keys instead:\n\n# file: `_config.yml`\nauthor:\n  picture:\n    path:   /assets/img/me.jpg\n    srcset:\n      1x:   /assets/img/me.jpg\n      2x:   /assets/img/me@2x.jpg\n\n\nThe keys of the srcset hash will be used as image descriptors. For more information on srcset, see the documentation at MDN, or this article from CSS-Tricks.\n\nAdding social media icons\nHydejack supports a variety of social media icons out of the box. These are defined on a per-author basis, so make sure you’ve followed the steps in Adding an author.\n\nIf you are using the gem-based version of Hydejack, download social.yml and put it into _data in the root directory. This is necessary because gem-based themes do not support including _data.\n\nYou can add a link to a social network by adding an entry to the social key in to an author.\nIt consists of the name of the social network as key and your username within that network as value, e.g.\n\n# file: `_config.yml`\nauthor:\n  social:\n    twitter: qwtel\n    github:  qwtel\n\n\nCheck out authors.yml to see which networks are available.\nYou can also follow the steps here to add your own social media icons.\n\nYou can change the order in which the icons appear by moving lines up or down, e.g.\n\n# file: `_config.yml`\nauthor:\n  social:\n    github:  qwtel # now github appears first\n    twitter: qwtel\n\n\nTo get an overview of which networks are available and how a typical username in that network looks like,\nsee the included authors.yml.\n\nShould providing a username not produce a correct link for some reason, you can provide a complete URL instead, e.g.\n\n# file: `_config.yml`\nauthor:\n  social:\n    youtube: https://www.youtube.com/channel/UCu0PYX_kVANdmgIZ4bw6_kA\n\n\nYou can add any platform, even if it’s not defined in social.yml, by providing a complete URL. However, a fallback icon  will be used when no icon is available. Supplying your own icons is an advanced topic.\n\nAdding an email, RSS icon or download icon\nIf you’d like to add an email , RSS , or download  icon to the list, add the email, rss, or download key, e.g.:\n\n# file: `_config.yml`\nauthor:\n  social:\n    email:    mail@qwtel.com\n    rss:      /feed.xml # make sure you provide an absolute URL\n    download: https://github.com/hydecorp/hydejack/archive/v9.1.6.zip\n\n\nEnabling comments\nHydejack supports comments via Disqus. Before you can add comments to a page you need to register and add your site to Disqus’ admin console. Once you have obtained your “Disqus shortname”, you include it in your config file:\n\n# file: `_config.yml`\ndisqus: &lt;disqus shortname&gt;\n\n\nNow comments can be enabled by adding comments: true to the front matter.\n\n---\nlayout:   post\ntitle:    Hello World\ncomments: true\n---\n\n\nYou can enable comments for entire classes of pages by using front matter defaults.\nE.g. to enable comments on all posts, add to your config file:\n\n# file: `_config.yml`\ndefaults:\n  - scope:\n      type: posts\n    values:\n      comments: true\n\n\nEnabling Google Analytics\nEnabling Google Analytics is as simple as setting the google_analytics key.\n\n# file: `_config.yml`\ngoogle_analytics: UA-XXXXXXXX-X\n\n\nTo remove Google Analytics and all associated code from the site, set the google_analytics key to false.\n\nUsing a custom analytics provider\nIf you want to use a different analytics provider such as Matomo, you can add its code snippet to _includes/my-body.html (create if it doesn’t exist).\nThe default file contains an example.\n\nChanging built-in strings\nYou can change the wording of built-in strings like “Related Posts” or “Read more” in _data/strings.yml.\n\nIf you are using the gem-based version the file doesn’t exist, but you can get the default file here.\n\nYou will frequently find markers like &lt;!--post_title--&gt;.\nYou can place them freely within your string and they will be replaced with the content they refer to.\n\nYou may also use this feature to translate the theme into different languages.\nIn this case you should also set the lang key to your config file, e.g.\n\n# file: `_config.yml`\nlang: cc-ll\n\n\nwhere cc is the 2-letter country code and ll specifies a 2-letter location code, e.g.: de-at.\n\nYou may also change the strings used for formatting dates and times (look out for the date_formats key), but be aware that the values you provide need to be valid Ruby format directives.\n\nAdding legal documents\nIf you have pages for contact data, privacy policy, cookie policy, etc. you can add links to them in the footer by listing them under the legal key in your config file as follows:\n\n# file: `_config.yml`\nlegal:\n  - title: Impress\n    url:  /impress/\n  - title: Cookies Policy\n    url:  /cookies-policy/\n\n\nWhen using Hydejack’s offline feature, the pages listed here will be downloaded and cached when loading the page for the first time.\n\nEnabling math blocks\n\nHydejack supports math blocks with either KaTeX or MathJax.\n\nThe MathJax implementation comes with a client-side runtime and works on GitHub Pages. \nIt is the more heavy-weight of the two and doesn’t work without JavaScript enabled. \nDue to the size of the complete MathJax package, it only works partially with offline support enabled.\n\nThe KaTeX implementation pre-renders the KaTeX output during site building.\nIt’s more lightweight because it does not ship a client-side runtime and therefore works without JavaScript.\nIn my opinion, it is the more elegant solution, but it requires a JavaScript runtime on the machine that builds the site,\ni.e. it does not work on GitHub Pages.\n\nYou can switch between the two implementations by changing the kramdown.math_engine key to either katex or mathjax in your config file.\n\n# file: `_config.yml`\nkramdown:\n  math_engine:         katex\n  math_engine_opts:    {}\n\n\nThe KaTeX implementation also requires the kramdown-math-katex gem in your Gemfile. \nIf you intend to use MathJax instead, this step is not required.\n\n# file: `Gemfile`\ngem \"kramdown-math-katex\"\n\n\nThere are a couple of things to know about this gem:\n\n  It is not supported on GitHub Pages. \nYou have to build the site on your machine before uploading to GitHub,\nor use a more permissive cloud building tool such as Netlify.\n  You need some kind of JavaScript runtime on your machine.\nUsually installing NodeJS will suffice. \nAlternatively, adding gem \"duktape\" will also do.\nFor more, see https://github.com/kramdown/math-katex#documentation\n\n\nBefore you add math content, remember to run bundle install and restart Jekyll.\n\nAdding custom Favicons and App Icons\nChanging the Favicon\nBy default, Hydejack will use the Favicon from /assets/icons/favicon.ico and Apple Touch Icon from /assets/icons/icon-192x192.png.\nYou can either override these files, or override the path in the config file via favicon and app_touch_icon keys:\n\n# file: \"_config.yml\"\nfavicon: /favicon.ico\napple_touch_icon: /assets/img/logo.png\n\n\nChanging the App Icons\nBy default, Hydejack includes its own favicon, as well as app icons in 8 different resolutions.\n\n\n  \n    \n      Name\n      Resolution\n    \n  \n  \n    \n      icon-512x512.png\n      512x512\n    \n    \n      icon-384x384.png\n      384x384\n    \n    \n      icon-192x192.png\n      192x192\n    \n    \n      icon-152x152.png\n      152x152\n    \n    \n      icon-144x144.png\n      144x144\n    \n    \n      icon-128x128.png\n      128x128\n    \n    \n      icon-96x96.png\n      96x96\n    \n    \n      icon-72x72.png\n      72x72\n    \n  \n\n\nTo change the default icons you have to replce all of them. To make this manageable, I recommend using the following tools:\n\nFirst, use the Maskable.app Editor to confine your logo/picture to the “minimum safe area”. More on maskable app icons, see this article on web.dev. \nMake sure the base image is at least 512x512 pixels in size.\n\nThen use the Web App Manifest Generator to automatically resize the icons. \nUpload the icon downloaded from Maskable.app and then click “Generate .zip”. \nIn the zip, ignore the manifest.json and look for the icons folder. Copy it into the assets folder of your site.\n\nTo change the favicon, place your own favicon.ico (32x32, PNG) into assets/icons.\n\nAdding a cookies banner*\n\n# file: `_config.yml`\nhydejack:\n  cookies_banner: true\n\n\nEnabling this setting will show a notice at the top of the page to new visitors.\nYou can change the wording of the notice in _data/strings.yml\nwith the cookies_banner.text and cookies_banner.okay keys:\n\n# file: `_data/strings.yml`\ncookies_banner:\n  text: This site uses cookies. [Markdown allowed](/cookies-policy/)!\n  okay: Okay\n\n\nEnabling newsletter boxes*\nTo enable showing newsletter subscription boxes below each post and project,\nprovide your Tinyletter username to the tinyletter key in the config file.\n\n# file: `_config.yml`\ntinyletter:  &lt;tinyletter username&gt;\n\n\nTo edit the content of the newsletter box, open _data/strings.yml, and change the entries under the tinyletter key.\n\nIf want to use a different mailing provider you can build your own form, and insert it into _includes/my-newsletter.html. The file includes an example form for MailChimp, where you need to fill in site.mailchimp.action and site.mailchimp.hidden_input (you can get these from MailChimp).\n\nTo build a completely new from, you can use the same CSS classes as Bootstrap. Note that only form, grid and utility classes are available. Check out Forms by Example for more examples.\n\nEnabling Dark Mode*\nBuyers of the PRO version have access to a dark-themed version of Hydejack.\n\nDark mode can be enabled in config.yml under the hydejack key and has three settings and two adjustments:\n\n# file: `_config.yml`\nhydejack:\n  dark_mode:\n    dynamic: true\n    sunrise: 6\n    sunset:  18\n    icon:    true\n    always:  false\n\n\nSetting dynamic, will enable dark mode based on the client’s local time (unlike location-based sunset calculations, this approach does not require a permission form the user). You can adjust sunrise and sunset to change when to show the light/dark theme.\n\nSetting icon will show a switch to alternate between the light and dark mode at the top of the page.\n\nFinally, setting always will cause dark mode to become the default theme at all times (combine with dynamic: false).\n\nContinue with Basics\n\n",
      "url": "/docs/config/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/"
    },{
      
      "title": "Install",
      "description": "How you install Hydejack depends on whether you start a new site, or change the theme of an existing site.\n",
      "content": "How you install Hydejack depends on whether you start a new site, \nor change the theme of an existing site.\n\n\n  New sites\n  Existing sites    \n      Troubleshooting\n    \n  \n  GitHub Pages\n  Running locally\n\n\nNew sites\nFor new sites, the best way to get started with Hydejack is via the Starter Kit. \nIt comes with a documented config file and example content that gets you started quickly.\n\nIf you have a GitHub account, fork the Hydejack Starter Kit repository. \nOtherwise download the Starter Kit and unzip them somewhere on your machine.\n\nIf you bought the PRO Version of Hydejack, use the contents of the starter-kit folder instead.\n\nIn addition to the docs here, you can follow the quick start guide in the Starter Kit.\n\nYou can now jump to running locally.\n\nYou can now also  directly.\n\nExisting sites\nIf you have an existing site that you’d like to upgrade to Hydejack you can install the theme via bundler.\nAdd the following to your Gemfile:\n\n# file: `Gemfile`\ngem \"jekyll-theme-hydejack\"\n\n\nIf you bought the PRO Version of Hydejack, copy the #jekyll-theme-hydejack folder into the root folder of your site,\nand add the following to your Gemfile instead:\n\n# file: `Gemfile`\ngem \"jekyll-theme-hydejack\", path: \"./#jekyll-theme-hydejack\"\n\n\nThe folder is prefixed with a # to indicate that this folder is different from regular Jekyll content. \nThe # char was choosen specifically because it is on of the four characters ignored by Jekyll by default (., _ , #, ~).\n\nIn your config file, change the theme to Hydejack:\n\n# file: `_config.yml`\ntheme: jekyll-theme-hydejack\n\n\nHydejack comes with a default configuration file that takes care most of the configuration,\nbut it pays off to check out the example config file in the Starter Kit to see what’s available.\n\nYou can now jump to running locally.\n\nTroubleshooting\nIf your existing site combines theme files with your content (as did previous verisons of Hydejack/PRO),\nmake sure to delete the following folders:\n\n\n  _layouts\n  _includes\n  _sass\n  assets\n\n\nThe assets folder most likely includes theme files as well as your personal/content files. \nMake sure to only delete files that belong to the old theme!\n\nGitHub Pages\nIf you want to build your site on GitHub Pages, check out the gh-pages branch in the Hydejack Starter Kit repo.\n\nFor existing sites, you can instead set the remote_theme key as follows:\n\n# file: `_config.yml`\nremote_theme: hydecorp/hydejack@v9.1.6\n\n\nMake sure the plugins list contains jekyll-include-cache (create if it doesn’t exist):\n\n# file: `_config.yml`\nplugins:\n  - jekyll-include-cache\n\n\nTo run this configuration locally, make sure the following is part of your Gemfile:\n\n# file: `Gemfile`\ngem \"github-pages\", group: :jekyll_plugins\ngem \"jekyll-include-cache\", group: :jekyll_plugins\n\n\nNote that Hydejack has a reduced feature set when built on GitHub Pages. \nSpecifically, using KaTeX math formulas doesn’t work when built in this way.\n\nRunning locally\nMake sure you’ve cded into the directory where _config.yml is located.\nBefore running for the first time, dependencies need to be fetched from RubyGems:\n\n$ bundle install\n\n\nIf you are missing the bundle command, you can install Bundler by running gem install bundler.\n\nNow you can run Jekyll on your local machine:\n\n$ bundle exec jekyll serve\n\n\nand point your browser to http://localhost:4000 to see Hydejack in action.\n\nContinue with Config\n\n",
      "url": "/docs/install/"
    },{
      
      "title": "Posts",
      "description": "This is the list layout for showing blog posts, which shows just the title and groups them by year of publication. Check out the blog layout for comparison.\n",
      "content": "\n",
      "url": "/posts/"
    },{
      
      "title": "Projects",
      "description": "How people are using Hydejack in the real world.  This page is built using the projects layout* that you can use yourself to build a portfolio.\n",
      "content": "\n",
      "url": "/projects/"
    },{
      
      "title": "Résumé*",
      "description": "This is the description of your resume page, as it will be seen by search engines. You’ll probably want to modify it in resume.md, and maybe set hide_description to true in the front matter.\n",
      "content": "\n",
      "url": "/resume/"
    },{
      
      "title": "Upgrade",
      "description": "This chapter shows how to upgrade Hydejack to a newer version. The method depends on how you’ve installed Hydejack.\n",
      "content": "This chapter shows how to upgrade Hydejack to a newer version. The method depends on how you’ve installed Hydejack.\n\n\n  Free version\n  PRO Version\n  GitHub Pages\n\n\nBefore upgrading to v7+, make sure you’ve read the CHANGELOG,\nespecially the part about the license change!\n\nFree version\nUpgrading the free version of the theme is as easy as running\n\nbundle update jekyll-theme-hydejack\n\n\nPRO Version\n\nIn v9, the structure of Hydejack PRO sites has changed. If you’re looking to upgrade from v8 or earlier, \ncheck out Installation for existing sites instead.\n\nBuyers of the PRO version will find the files necessary for an upgrade in the #jekyll-theme-hydejack folder of the downloaded zip archive.\nTo upgrade, simply overwrite the existing theme folder in the root directory of your site with the new one, then run\n\nbundle update jekyll-theme-hydejack\n\n\nIf you’ve modified any of Hydejack’s files in #jekyll-theme-hydejack, your changes will most likely be overwritten\nand you have to apply them again. Make sure you’ve made a backup before overwriting any files.\n\nGitHub Pages\nWhen building on GitHub Pages, upgrading Hydejack is as simple as setting the remote_theme key in _config.yml to the desired version.\n\nremote_theme: hydecorp/hydejack@v9.1.6\n\n\nTo use the latest version on the v9 branch on each build, you can use  hydecorp/hydejack@v9.\n\nContinue with Config\n",
      "url": "/docs/upgrade/"
    },{
      
      "title": "Writing",
      "description": "Hydejack offers a few additional features to markup your content. Don’t worry, these are merely CSS classes added with kramdown’s {:...} syntax, so that your content remains compatible with other Jekyll themes.\n",
      "content": "Hydejack offers a few additional features to markup your content.\nDon’t worry, these are merely CSS classes added with kramdown’s {:...} syntax,\nso that your content remains compatible with other Jekyll themes.\n\n\n  A word on building speeds\n  Adding a table of contents\n  Adding notes\n  Adding large text\n  Adding large images\n  Adding image captions\n  Adding large quotes\n  Adding faded text\n  Adding tables    \n      Scroll table\n      Small tables\n    \n  \n  Adding code blocks\n  Adding math    \n      Inline\n      Block\n    \n  \n\n\nFor an introduction to markdown in general, see Mastering Markdown and kramdown Syntax.\n\nA word on building speeds\nIf building speeds are a problem, try using the --incremental flag, e.g.\n\nbundle exec jekyll serve --incremental\n\n\nFrom the Jekyll docs (emphasis mine):\n\n\n  Enable the experimental incremental build feature. Incremental build only re-builds posts and pages that have changed, resulting in significant performance improvements for large sites, but may also break site generation in certain cases.\n\n\nThe breakage occurs when you create new files or change filenames.\nAlso, changing the title, category, tags, etc. of a page or post will not be reflected in pages\nother then the page or post itself.\nThis makes it ideal for writing new posts and previewing changes, but not setting up new content.\n\nAdding a table of contents\nYou can add a generated table of contents to any page by adding {:toc} below a list.\n\nMarkdown:\n* this unordered seed list will be replaced by the toc\n{:toc}\n\n\nYou can also create your table of contents as an ordered list (note the 1. instead of *):\n\n1. this ordered seed list will be replaced by the toc\n{:toc}\n\n\nThe width of the display has to be larger than 1665px for the ToC to become sticky.\nOtherwise, the ToC will appear where the seed list is placed in the document.\nTo show the table of contents only on large displays (&gt; 1665px) use the following:\n\n* this unordered seed list will be replaced by the toc \n{:toc .large-only}\n\n\nA sticky table of contents will reduce the amount of space freed up by the no_break_layout: false setting.\nThis is necessary to ensure large code blocks or tables don’t overlap with the ToC.\n\nAdding notes\nYou can add a note by adding the note class to a paragraph.\n\nExample:\n\nYou can add a note.\n\nMarkdown:\nYou can add a note.\n{:.note}\n\n\nEdit the note key in _data/strings.yml to change the wording of the default label.\nTo add a note with a specific label, add a title attribute:\n\nA custom label.\n{:.note title=\"Attention\"}\n\n\nA custom label.\n\nAdding large text\nYou can add large text by adding the lead class to the paragraph.\n\nExample:\n\nYou can add large text.\n\nMarkdown:\nYou can add large text.\n{:.lead}\n\n\nAdding large images\nYou can make an image span the full width by adding the lead class.\n\nExample:\n\n\n\nMarkdown:\n![Full-width image](https://via.placeholder.com/800x100){:.lead width=\"800\" height=\"100\" loading=\"lazy\"}\n\n\nIt is recommended to provide the dimension of the image via the width and height attributes, \nso that browsers can calculate the layout before the images are loaded. Combining this with the loading=\"lazy\" attribute\nallows modern browsers to load the images just-in-time as the users scrolls.\n\nPrevious versions of Hydejack shipped with a custom JavaScript-based lazy loading solution,\nbut it has been removed in v9 in favor of this more standards-based approach.\n\nAdding image captions\nYou can add captions to large images by adding the figcaption class to the paragraph after the image:\n\n\n\nAn optional caption for an image.\n\nMarkdown:\n![Full-width image](https://via.placeholder.com/800x100){:.lead width=\"800\" height=\"100\" loading=\"lazy\"}\n\nA caption for an image.\n{:.figcaption}\n\n\nAdding large quotes\nYou can make a quote “pop out” by adding the lead class.\n\nExample:\n\n\n  You can make a quote “pop out”.\n\n\nMarkdown:\n&gt; You can make a quote \"pop out\".\n{:.lead}\n\n\nAdding faded text\nYou can gray out text by adding the faded class. Use this sparingly and for information that is not essential, as it is more difficult to read.\n\nExample:\n\nI’m faded, faded, faded.\n\nMarkdown:\nI'm faded, faded, faded.\n{:.faded}\n\n\nAdding tables\nAdding tables is straightforward and works just as described in the kramdown docs, e.g.\n\n\n  \n    \n      Default aligned\n      Left aligned\n      Center aligned\n      Right aligned\n    \n  \n  \n    \n      First body part\n      Second cell\n      Third cell\n      fourth cell\n    \n  \n\n\nMarkdown:\n| Default aligned |Left aligned| Center aligned  | Right aligned  |\n|-----------------|:-----------|:---------------:|---------------:|\n| First body part |Second cell | Third cell      | fourth cell    |\n\n\nHowever, it gets tricker when adding large tables.\nIn this case, Hydejack will break the layout and grant the table the entire available screen width to the right:\n\n\n  \n    \n      Default aligned\n      Left aligned\n      Center aligned\n      Right aligned\n      Default aligned\n      Left aligned\n      Center aligned\n      Right aligned\n      Default aligned\n      Left aligned\n      Center aligned\n      Right aligned\n      Default aligned\n      Left aligned\n      Center aligned\n      Right aligned\n    \n  \n  \n    \n      First body part\n      Second cell\n      Third cell\n      fourth cell\n      First body part\n      Second cell\n      Third cell\n      fourth cell\n      First body part\n      Second cell\n      Third cell\n      fourth cell\n      First body part\n      Second cell\n      Third cell\n      fourth cell\n    \n    \n      Second line\n      foo\n      strong\n      baz\n      Second line\n      foo\n      strong\n      baz\n      Second line\n      foo\n      strong\n      baz\n      Second line\n      foo\n      strong\n      baz\n    \n    \n      Third line\n      quux\n      baz\n      bar\n      Third line\n      quux\n      baz\n      bar\n      Third line\n      quux\n      baz\n      bar\n      Third line\n      quux\n      baz\n      bar\n    \n    \n      Second body\n       \n       \n       \n      Second body\n       \n       \n       \n      Second body\n       \n       \n       \n      Second body\n       \n       \n       \n    \n    \n      2 line\n       \n       \n       \n      2 line\n       \n       \n       \n      2 line\n       \n       \n       \n      2 line\n       \n       \n       \n    \n  \n  \n    \n      Footer row\n       \n       \n       \n      Footer row\n       \n       \n       \n      Footer row\n       \n       \n       \n      Footer row\n       \n       \n       \n    \n  \n\n\nTables adopts to the font size! You can decrease the size of the table by adding the smaller CSS class. Put {:.smaller} below the Markdown table, or add class=\"smaller\" to a HTML table.\n\nScroll table\nIf the extra space still isn’t enough, the table will receive a scrollbar.\nIt is browser default behavior to break the lines inside table cells to fit the content on the screen.\nBy adding the scroll-table class on a table, the behavior is changed to never break lines inside cells, e.g:\n\n\n  \n    \n      Default aligned\n      Left aligned\n      Center aligned\n      Right aligned\n      Default aligned\n      Left aligned\n      Center aligned\n      Right aligned\n      Default aligned\n      Left aligned\n      Center aligned\n      Right aligned\n      Default aligned\n      Left aligned\n      Center aligned\n      Right aligned\n    \n  \n  \n    \n      First body part\n      Second cell\n      Third cell\n      fourth cell\n      First body part\n      Second cell\n      Third cell\n      fourth cell\n      First body part\n      Second cell\n      Third cell\n      fourth cell\n      First body part\n      Second cell\n      Third cell\n      fourth cell\n    \n    \n      Second line\n      foo\n      strong\n      baz\n      Second line\n      foo\n      strong\n      baz\n      Second line\n      foo\n      strong\n      baz\n      Second line\n      foo\n      strong\n      baz\n    \n    \n      Third line\n      quux\n      baz\n      bar\n      Third line\n      quux\n      baz\n      bar\n      Third line\n      quux\n      baz\n      bar\n      Third line\n      quux\n      baz\n      bar\n    \n    \n      Second body\n       \n       \n       \n      Second body\n       \n       \n       \n      Second body\n       \n       \n       \n      Second body\n       \n       \n       \n    \n    \n      2 line\n       \n       \n       \n      2 line\n       \n       \n       \n      2 line\n       \n       \n       \n      2 line\n       \n       \n       \n    \n  \n  \n    \n      Footer row\n       \n       \n       \n      Footer row\n       \n       \n       \n      Footer row\n       \n       \n       \n      Footer row\n       \n       \n       \n    \n  \n\n\nYou can add the scroll-table class to a markdown table by putting {:.scroll-table} in line directly below the table.\nTo add the class to a HTML table, add the it to the class attribute of the table tag, e.g. &lt;table class=\"scroll-table\"&gt;.\n\nSmall tables\nIf a table is small enough to fit the screen even on small screens, you can add the stretch-table class\nto force a table to use the entire available content width. Note that stretched tables can no longer be scrolled.\n\n\n  \n    \n      Default aligned\n      Left aligned\n      Center aligned\n      Right aligned\n    \n  \n  \n    \n      First body part\n      Second cell\n      Third cell\n      fourth cell\n    \n  \n\n\nAn optional caption for a table\n\nYou can add the stretch-table class to a markdown table by putting {:.stretch-table} in line directly below the table.\nTo add the class to a HTML table, add the it to the class attribute of the table tag, e.g. &lt;table class=\"stretch-table\"&gt;.\n\nJust like images, you can add captions to tables by adding the figcaption class to the paragraph after the table.\n\nAn optional caption for a table\n{:.figcaption}\n\n\nAdding code blocks\nTo add a code block without syntax highlighting, simply indent 4 spaces (regular markdown).\nFor code blocks with code highlighting, use ~~~&lt;language&gt;. This syntax is also supported by GitHub.\nFor more information and a list of supported languages, see Rouge.\n\nYou can give each code block a filename, by making the first line in the block a comment of the form File: \"dir/filename.ext\". Use either single quotes ', double quotes \", or backticks ` to surround the filename.\n\nExample:\n\n// file: \"code-block.js\"\n// Example can be run directly in your JavaScript console\n\n// Create a function that takes two arguments and returns the sum of those\n// arguments\nvar adder = new Function(\"a\", \"b\", \"return a + b\");\n\n// Call the function\nadder(2, 6);\n// &gt; 8\n\n\nAn optional caption for a code block\n\nMarkdown:\n\n~~~js\n// file: \"code-block.js\"\n// Example can be run directly in your JavaScript console\n\n// Create a function that takes two arguments and returns the sum of those\n// arguments\nvar adder = new Function(\"a\", \"b\", \"return a + b\");\n\n// Call the function\nadder(2, 6);\n// &gt; 8\n~~~\n\nAn optional caption for a code block\n{:.figcaption}\n\n\nDO NOT use Jekyll’s { % highlight % } ... { % endhighlight % } syntax, especially together with the linenos option.\nThe generated table to render the line numbers does not have a CSS class or any other way of differentiating it from regular tables,\nso that the styles above apply, resulting in a broken page.\nWhat’s more, the output from highlight tags isn’t even valid HTML, nesting pre tags inside pre tags,\nwhich will in break the site during minification.\nYou can read more about it here and\nhere.\n\nAdding math\nBefore adding math blocks, make sure you’ve set up math support.\n\nInline\nExample:\n\nLorem ipsum \\(f(x) = x^2\\).\n\nMarkdown:\nLorem ipsum $$ f(x) = x^2 $$.\n\n\nBlock\nExample:\n\n[\\begin{aligned}\n  \\phi(x,y) &amp;= \\phi \\left(\\sum_{i=1}^n x_ie_i, \\sum_{j=1}^n y_je_j \\right) \\[2em]\n            &amp;= \\sum_{i=1}^n \\sum_{j=1}^n x_i y_j \\phi(e_i, e_j)            \\[2em]\n            &amp;= (x_1, \\ldots, x_n)\n               \\left(\\begin{array}{ccc}\n                 \\phi(e_1, e_1)  &amp; \\cdots &amp; \\phi(e_1, e_n) \n                 \\vdots          &amp; \\ddots &amp; \\vdots         \n                 \\phi(e_n, e_1)  &amp; \\cdots &amp; \\phi(e_n, e_n)\n               \\end{array}\\right)\n               \\left(\\begin{array}{c}\n                 y_1    \n                 \\vdots \n                 y_n\n               \\end{array}\\right)\n\\end{aligned}]\n\nAn optional caption for a math block\n\nMarkdown:\n\n$$\n\\begin{aligned} %!!15\n  \\phi(x,y) &amp;= \\phi \\left(\\sum_{i=1}^n x_ie_i, \\sum_{j=1}^n y_je_j \\right) \\\\[2em]\n            &amp;= \\sum_{i=1}^n \\sum_{j=1}^n x_i y_j \\phi(e_i, e_j)            \\\\[2em]\n            &amp;= (x_1, \\ldots, x_n)\n               \\left(\\begin{array}{ccc}\n                 \\phi(e_1, e_1)  &amp; \\cdots &amp; \\phi(e_1, e_n) \\\\\n                 \\vdots          &amp; \\ddots &amp; \\vdots         \\\\\n                 \\phi(e_n, e_1)  &amp; \\cdots &amp; \\phi(e_n, e_n)\n               \\end{array}\\right)\n               \\left(\\begin{array}{c}\n                 y_1    \\\\\n                 \\vdots \\\\\n                 y_n\n               \\end{array}\\right)\n\\end{aligned}\n$$\n\nAn optional caption for a math block\n{:.figcaption}\n\n\nKaTeX does not support the align and align* environments.\nInstead, aligned should be used, e.g. \\begin{aligned} ... \\end{aligned}.\n\nContinue with Scripts\n\n",
      "url": "/docs/writing/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/2/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/3/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/4/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/5/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/6/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/7/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/8/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/9/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/10/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/11/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/12/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/blog/13/"
    }
  ], 
  "documents": [
    {
      
      "title": "#1 - Multiples of 3 and 5",
      "date": "2015-07-15 17:41:00 +0000",
      
      "content": "\n  If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\n\n  Find the sum of all the multiples of 3 or 5 below 1000.\n\n\n\nNothing fancy to do here. We can simply look through each natural number and add it to a rolling sum if it’s a multiple of 3 or 5:\n\n# file: \"problem001.py\"\ns = 0\nfor n in range(1, 1000):\n    if n % 3 == 0 or n % 5 == 0:\n        s += n\nprint(n)\n\nRunning the code results in\n233168\n0.00019780000000002573 seconds.\n\nTherefore, 233168 is the answer to the first problem.\nBonus\nWe can solve this problem completely analytically. For example, $\\sum_{i=1}^{333}3i$ will get us all multiples of 3. We can do the same summation for 5. However, we have to be a bit careful. Adding these two summations will lead us to double count all numbers that are both multiples of 3 and 5 i.e. 15. Thus, we need to subtract these multiples. The full sum is therefore:\n\n[\\begin{aligned}\nS &amp;= \\sum_{i=1}^{333}3i + \\sum_{i=1}^{199}5i - \\sum_{i=1}^{66}15i\n\n&amp;= 3\\left(\\frac{333(334)}{2}\\right) + 5\\left(\\frac{199(200)}{2}\\right)-15\\left(\\frac{66(67)}{2}\\right)\n\\ &amp;=\n3(55611) + 5(19900) - 15(2211)\n\\ &amp;=\n\\boxed{233168}\n\\end{aligned}]\n",
      "categories": ["project_euler"],
      "tags": ["05_diff","analytical solution","brute force"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-15-001-Multiples-of-3-and-5/"
    },{
      
      "title": "#2 - Even Fibonaci numbers",
      "date": "2015-07-22 18:22:00 +0000",
      
      "content": "\n  Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 20 terms will be:\n\n  1, 2, 3, 5, 8, 13, 21, 34, 55, 89\n\n  By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terrms.\n\n\n\nWe can go through the Fibonacci numbers, generating and checking them as we go.\n# file: \"problem002.py\"\na = 1\nb = 1\ns = 0\nwhile b &lt;= 4000000:\n    if b % 2 == 0:\n        s += b\n    temp = a + b\n    a = b\n    b = temp\nprint(s)\n\nRunning results in the following output:\n4613732\n0.00011090000000002487 seconds.\n\nBonus\nHowever, we can also solve this analytically. If we assume $F_1=F_2=1$, then it turns out every 3rd Fibonacci number is even. This is due to:\n\n  The sequence starts with 2 odd numbers\n  An odd plus an odd gives an even\n  An even plus odd gives an odd.\nThus, we need to add every 3rd Fibonacci number. Recall that there is also a closed-form formula utilizing the golden ratio:\n\n\n[F_n=\\frac{\\Phi^n-(1-\\Phi)^n}{\\sqrt{5}}]\n\nWe need to find the index of the largest Fibonacci number less than 4 million. From the Wikipedia article, the formula to find the closest index (rounded down) of a Fibonacci number $F$ is\n\n[n(F)=\\lfloor \\log_\\Phi\\left(F\\sqrt{5}+\\frac{1}{2}\\right)\\rfloor\n\nn(4000000)=33]\n\nNext, recall that the sum of a finite geometric series is\n\n[a_1\\frac{1-r^n}{1-r}]\n\nwhere,\n\n  $a_1$ is the first term\n  $r$ is the common ratio\n  $n$ is the number of terms in the sequence.\n\n\nNow we can write and solve our summation like so:\n\n[\\begin{aligned}\n\tS &amp;= \\sum_{k=1}^{11}F_{3k}\n\t\\ &amp;=\n\t\\sum_{k=1}^{11}\\frac{\\Phi^{3k} - (1-\\Phi)^{3k}}{\\sqrt{5}}\n\t\\ &amp;=\n\t\\frac{1}{\\sqrt{5}}\\left(\\sum_{k=1}^{11}\\Phi^{3k} - \\sum_{k=1}^{11}(1-\\Phi)^{3k}\\right)\n\t\\ &amp;=\n\t\\frac{1}{\\sqrt{5}}\\left(\\Phi^3\\frac{1-(\\Phi^3)^{11}}{1-\\Phi^3} - \n\t\t(1-\\Phi)^3\\frac{1-((1-\\Phi)^3)^{11}}{1-(1-\\Phi)^3}\\right)\n\t\\ &amp;=\n\t\\boxed{4613732}\n\\end{aligned}]\n",
      "categories": ["project_euler"],
      "tags": ["05_diff","fibonacci","analytical solution","brute force"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-22-002-Even-Fibonacci-numbers/"
    },{
      
      "title": "#3 - Largest prime factor",
      "date": "2015-07-23 11:50:00 +0000",
      
      "content": "\n  The prime factors of 13195 are 5, 7, 13, and 29.\n\n  What is the largest prime factor of the number 600851475143?\n\n\n\nThere are a lot of complicated algorithms out there that can quickly prime factorize composite numbers. However, for the purposes of this problem, the number is not extremely large. Therefore, we can take a simple approach. There is a Python package known as primesieve that can handle finding prime numbers themselves. Documentation is listed here.\n\nThe upper bound for the largest prime factor of a number $n$ is $\\sqrt{n}$. Using primesieve we can quickly generate prime factors and check the largest one on down:\n\n# file: \"problem003.py\"\nimport primesieve\n\nn = 600851475143\nprimesToCheck = primesieve.primes(n ** 0.5)\n\nfor prime in primesToCheck[::-1]:\n    if n % prime == 0:\n        print(prime)\n        break\n\nRunning this code gives us\n6857\n0.01296553086419753 seconds.\n\nThus, 6857 is our answer.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff","primes","brute force"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-23-003-Largest-prime-factor/"
    },{
      
      "title": "#4 - Largest palindrome product",
      "date": "2015-07-23 12:06:00 +0000",
      
      "content": "\n  A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99.\n\n  Find the largest palindrome made from the product of two 3-digit numbers.\n\n\n\nFirst, we need a function to determine if a number is a palindrome. Using Python, we can convert the number to a string, reverse it, and check if they are equal.\n# file: \"problem004.py\"\ndef isPalindrome(n):  \n   num = str(n)  \n   return num == num[::-1]\n\nNext, the built-in method itertools.combinations allows to quickly iterate through all products of two 3-digit numbers. Because we want the largest, we will reverse the list of products after removing duplicates, and select the first palindrome we find.\n# file: \"problem004.py\"\nnumbers = sorted(set([a * b for a, b in combinations(range(100, 1000), r=2)]))  \n  \ni = -1  \nwhile not isPalindrome(numbers[i]):  \n   i -= 1  \n  \nprint(numbers[i])\n\nRunning this short code gives us\n906609\n0.07893140008673072 seconds.\n\nTherefore, 906609 is our answer.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff","Brute force"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-23-004-Largest-palindrome-product/"
    },{
      
      "title": "#5 - Smallest multiple",
      "date": "2015-07-23 12:36:00 +0000",
      
      "content": "\n  2520 is the smallest number that can be divided by each of the numbers by 1 to 10 without any remainder.\n\n  What is the smallest positive number that is evenly divisible by all the numbers from 1 to 20?\n\n\n\nWe need to find the Least Common Multiple (LCM) of all the numbers from 1 to 20. If we have the prime factorization of each number, then finding the LCM is simple.\n\nTo find the LCM of a list of numbers, we would union the prime factorizations of all the numbers together. This way, lower numbers get absorbed into higher factorizations. We then multiply all the unioned factorizations together. Here is an example with 1-10:\n\n\n  $\\mathbf{2} = 2$\n  $\\mathbf{3} = 3$\n  $\\mathbf{4} = 2^2$\n  $\\mathbf{5} = 5$\n  $\\mathbf{6} = 2\\times3$\n  $\\mathbf{7} = 7$\n  $\\mathbf{8} = 2^3$\n  $\\mathbf{9} = 3^2$\n  $\\mathbf{10} = 2\\times5$\n\n\nWe have four unique factors: 2, 3, 5, 7. The union of each factor is $2^3, 3^2, 5$, and $7$ respectively. Multiplying these together gets us the LCM:\n\n[LCM(1, 2, 3, \\dots, 10) = 2^3\\times 3^2\\times 5\\times 7 = \\mathbf{2520}]\n\nHowever, there is one optimization we can do. Becuase we are doing consecutive numbers, all we need to find is the highest power of each prime less than the limit. There will be eventually be a prime where every power prime greater than that will just be the prime itself. For 1-10, that prime was 3. For 1-20, that prime will also be 5, since $5^2=25&gt;20$. Therefore, we can calculate this product directly:\n\n\\(LCM(1,2,3,\\dots,20) = 2^4\\times 3^2\\times 5\\times 7\\times 11\\times 13\\times 17\\times 19 = \\mathbf{232792560}\\)\nTherefore, 232792560 is our answer. If we wanted to actually code this, all we need is the primesieve package to get a list of primes less than the limit. We test $\\log_p L$ for each prime $p$. As soon as this is less than 2, we can stop our loop and just multiply the rest of the prime numbers.\n\n# file; \"problem005.py\"\nlimit = 20  \nprime_list = primes(limit)  \n  \n# Keep looping until log_p is less than 2  \nprod = 1  \ni = 0  \nwhile np.emath.logn(prime_list[i], limit) &gt; 2:  \n   prod *= prime_list[i] ** int(np.emath.logn(prime_list[i], limit))  \n   i += 1  \n# Multiply the rest starting at i  \nprod *= np.prod(prime_list[i:])  \n  \nprint(prod)\n\nRunning the code gives,\n\n232792560\n0.00041200011037290096 seconds.\n\nwhich is the same answer as the analytical method.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff","Analytical solution"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-23-005-Smallest-multiple/"
    },{
      
      "title": "#6 - Sum square difference",
      "date": "2015-07-23 19:23:00 +0000",
      
      "content": "\n  The sum of the squares of the first ten natural numbers is,\n\n\\[1^2 + 2^2 + \\cdots + 10^2 = 385\\]\n\n  The square of the sum of the first ten natural numbers is,\n\n\\[(1 + 2 + \\cdots + 10)^2 = 55^2 = 3025\\]\n\n  Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.\n\n  Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.\n\n\n\nJust directly loop until 100. No special packages are necassary, and we can use list comprehension to make the code extra short.\n\n# file: \"problem006.py\"\nn = 100  \nsum_square = sum(x ** 2 for x in range(n + 1))  \nsquare_sum = sum(range(n + 1)) ** 2  \n  \nprint(square_sum - sum_square)\n\nRunning gives,\n25164150\n5.570007488131523e-05 seconds.\n\nBonus\nWe can also do this analytically. The expression we are asked to solve is\n\n[S = \\left( \\sum_{i=1}^{100} i \\right)^2 - \\sum_{i=1}^{100} i^2]\n\nRecall that $\\sum_{i=1}^n i = \\frac{n(n+1)}{2}$ and $\\sum{i=1}^n i^2 = \\frac{n(n+1)(2n+1)}{6}$. Substituting and solving, we get\n\n[\\begin{aligned}\n    S &amp;= \\left( \\frac{100(100+1)}{2} \\right)^2 - \\frac{100(100 + 1)(2(100) + 1)}{6}\n    \\ &amp;=\n    5050^2 - 338350\n    \\ &amp;=\n    \\boxed{25164150}\n\\end{aligned}]\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-23-006-Sum-square-difference/"
    },{
      
      "title": "#7 - 10001st prime",
      "date": "2015-07-26 09:11:00 +0000",
      
      "content": "\n  By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.\n\n  What is the 10,001st prime number?\n\n\n\nBecause the crux of the problem is to find a specific prime, I will not be using the primesieve package, as it trivially gives us the answer. Instead, for this problem, we can create a sieve, where we mark off composite numbers in a list. The sieve requires an upper bound, which is not immediately clear based on the number. According to the Prime number theorem, an upper bound for the $n$th prime number $p_n$ is\n\n[p_n &lt; n(\\ln n + \\ln \\ln n)]\n\nSubstituting $n = 10001$, we get that $p_{10001} &lt; 114319.2$. This is how far the sieve has to go.\n\nThe sieve itself is straightforward to generate. Originally, we assume every number starting with 2 is prime. If we encounter a number that is marked as prime, then we mark all multiples of that number as composite. Then, we move to the next number that is marked as prime. At the end of the process, we have a full list of which numbers are prime. To speed things up a little bit, we start counting from the end.\n# file: \"problem007.py\"\nimport math\n\nn = 10001\nlimit = int(n * (math.log(n) + math.log(math.log(n))))\n\nsieve = [True] * (limit + 1)\n# By definition, 0 and 1 are not primes.\nsieve[0] = False\nsieve[1] = False\n# Start at index 2, so the index = prime number\np = 2\nwhile p &lt; limit + 1:\n    # If it's composite, then go to the next one\n    if not sieve[p]:\n        p += 1\n        continue\n    # Mark all multiples\n    for i in range(2 * p, limit + 1, p):\n        sieve[i] = False\n    p += 1\n# Since this is an upper bound, count the number of prime numbers,\n# and count backwards from the end...\nnum_primes = sum(sieve)\nencountered = 0\ni = limit\nwhile encountered &lt; num_primes - n + 1:\n    if sieve[i]:\n        encountered += 1\n    i -= 1\n# i got subtracted by 1, so add one back to get the actual location\nprint(i + 1)\n\nRunning this loop, we get\n104743\n0.06304600000112259 seconds.\n\nThus, 104743 is the 10,001st prime.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-26-007-10001st-prime/"
    },{
      
      "title": "#8 - Largest product in a series",
      "date": "2015-07-26 19:15:00 +0000",
      
      "content": "\n  The four adjacent digits in the 1000-digit number that have the graetest product are\n\n\\[9\\times 9\\times 8\\times 9 = 5832\\]\n\n  73167176531330624919225119674426574742355349194934\n96983520312774506326239578318016984801869478851843\n85861560789112949495459501737958331952853208805511\n12540698747158523863050715693290963295227443043557\n66896648950445244523161731856403098711121722383113\n62229893423380308135336276614282806444486645238749\n30358907296290491560440772390713810515859307960866\n70172427121883998797908792274921901699720888093776\n65727333001053367881220235421809751254540594752243\n52584907711670556013604839586446706324415722155397\n53697817977846174064955149290862569321978468622482\n83972241375657056057490261407972968652414535100474\n82166370484403199890008895243450658541227588666881\n16427171479924442928230863465674813919123162824586\n17866458359124566529476545682848912883142607690042\n24219022671055626321111109370544217506941658960408\n07198403850962455444362981230987879927244284909188\n84580156166097919133875499200524063689912560717606\n05886116467109405077541002256983155200055935729725\n71636269561882670428252483600823257530420752963450\n  \n  Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?\n\n\n\nIn Python, we can convert the number into a string, iterate through 13 digits at a time, multiply, and compare to a running max.\n# file: \"problem008.py\"\nnum = \"\"\"\n73167176531330624919225119674426574742355349194934\n96983520312774506326239578318016984801869478851843\n85861560789112949495459501737958331952853208805511\n12540698747158523863050715693290963295227443043557\n66896648950445244523161731856403098711121722383113\n62229893423380308135336276614282806444486645238749\n30358907296290491560440772390713810515859307960866\n70172427121883998797908792274921901699720888093776\n65727333001053367881220235421809751254540594752243\n52584907711670556013604839586446706324415722155397\n53697817977846174064955149290862569321978468622482\n83972241375657056057490261407972968652414535100474\n82166370484403199890008895243450658541227588666881\n16427171479924442928230863465674813919123162824586\n17866458359124566529476545682848912883142607690042\n24219022671055626321111109370544217506941658960408\n07198403850962455444362981230987879927244284909188\n84580156166097919133875499200524063689912560717606\n05886116467109405077541002256983155200055935729725\n71636269561882670428252483600823257530420752963450\n\"\"\"\nnum = num.replace('\\n', '')\n\nmaxproduct = 0\nproduct = 1\nfor i in range(len(num) - 13):\n    product = 1\n    for j in range(i, i + 13):\n        product = product * int(num[j])\n    if (product &gt; maxproduct):\n        maxproduct = product\n\nprint(maxproduct)\n\nThe output is\n23514624000\n0.00531595061728395 seconds.\n\nThus, the largest product is 23514624000.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-26-008-Largest-product-in-series/"
    },{
      
      "title": "#9 - Special Pythagorean triplet",
      "date": "2015-07-26 19:24:00 +0000",
      
      "content": "\n  A Pythagorean triplet is a set of three natural numbers, $a &lt; b &lt; c$, for which,\n\n\\[a^2 + b^2 = c^2\\]\n\n  For example, $3^2 + 4^2 = 9 + 16 = 25 = 5^2$.\n\n  There exists only one Pythagorean triplet for which $a + b + c = 1000$.\nFind the product $abc$.\n\n\n\nThe brute force method would simply loop through all $a,b,c$ values from 1 to 999. However, we can use our given relationships to reduce the search space to just two variables. Note that\n\n[(a + b + c)^2 = a^2 + 2ab + b^2 + 2ac + 2bc + c^2]\n\nFrom $a + b + c = 1000$, we have $c = 1000 - a - b$. Using these facts and the Pythagorean theorem, we can simplify the above expression:\n\n[\\begin{aligned}\n\t1000^2 &amp;= 2ab + 2ac + 2bc + 2c^2\n\t\n\t\\frac{1000^2}{2} &amp;= ab + a(1000 - a - b) + b(1000 - a - b) + (1000 - a - b)^2\n\t\n\t\\frac{1000^2}{2} &amp;= ab + 1000a - a^2 - ab + 1000b - ab - b^2 - 1000^2 - 2(1000)(a+b) + (a+b)^2\n\t\n\t\\frac{1000^2}{2} &amp;= 1000a-a^2+1000b-ab-b^2-1000^2-2000a-2000b+a^2+2ab+b^2\n\t\n\t\\frac{1000^2}{2} &amp;= 1000^2-1000a-1000b+ab\n\t\n\t500 &amp;= 1000-a-b+\\frac{ab}{1000}\n\t\n\ta+b-500 &amp;= \\frac{ab}{1000}\n\\end{aligned}]\n\nThe last statement provides our condition to check for all pairs $a, b$. So we have reduced to a double for loop.\n# file: \"problem009.py\"\nfor b in range(1, 999):\n    for a in range(1, b):\n        if a + b - 500 == a * b / 1000:\n            c = int((a ** 2 + b ** 2) ** 0.5)\n            print('(a, b, c)', '=', a, b, c)\n            print('abc', '=', a * b * c)\n            end = time.perf_counter()\n            print(end - start, 'seconds.')\n            sys.exit(0)\n\nRunning the above code gives us,\n(a, b, c) = 200 375 425\nabc = 31875000\n0.033183526281024125 seconds.\n\nTherefore, our product is 31875000.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-26-009-Special-Pythagorean-triplet/"
    },{
      
      "title": "#10 - Summation of primes",
      "date": "2015-07-26 19:29:00 +0000",
      
      "content": "\n  The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.\n\n  Find the sum of all primes below two million.\n\n\n\nSince finding primes is the main crux of the problem, I will refran from using the primesieve package. In this case, I will use the same sieve we generated from #7 - 10001st prime. This time we need to go until two million. To get the actual values, we will just use enumerate, which pairs the index with the actual value.\n# file: \"problem010.py\"\nlimit = 2000000\nsieve = [True] * (limit + 1)\nsieve[0] = False\nsieve[1] = False\n# Start at index 2, so the index = prime number\np = 2\nwhile p &lt; limit + 1:\n    # If it's composite, then go to the next one\n    if not sieve[p]:\n        p += 1\n        continue\n    # Mark all multiples\n    for i in range(2 * p, limit + 1, p):\n        sieve[i] = False\n    p += 1\n\ns = 0\nfor i, mark in enumerate(sieve):\n    if mark:\n        s += i\nprint(s)\n\nRunning the loop,\n142913828922\n1.7028809000039473 seconds.\n\nTherefore, the sum of all primes under two million is 142913828922.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-26-010-Summation-of-primes/"
    },{
      
      "title": "#11 - Largest product in a grid",
      "date": "2015-07-27 10:07:00 +0000",
      
      "content": "\n  In the 20 x 20 grid below, four numbers along a diagonal line have been marked in red:\n\n  \n08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08\n49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00\n81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65\n52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91\n22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80\n24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50\n32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70\n67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21\n24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72\n21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95\n78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92\n16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57\n86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58\n19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40\n04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66\n88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69\n04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36\n20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16\n20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54\n01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48\n\n\n  The product of these numbers is 26 x 63 x 78 x 14 = 1788696\n\n  What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20 x 20 grid?\n\n\n\nWe will write a few for loops to go in the different directions. I have copied the above grid directly into a file problem011.txt that I read.\n# file: \"problem011.py\"\n# open file containing 20 x 20 grid and read into list\nwith open(\"problem011.txt\") as f:\n    grid = f.read().splitlines()\n    grid = [list(map(int, grid[i].split(' '))) for i in range(len(grid))]\n\nmaxproduct = 0\n# Check horizontal products\nfor i in range(len(grid)):\n    for j in range(len(grid[i]) - 3):\n        product = 1\n        for k in range(4):\n            product = product * grid[i][j + k]\n        if (product &gt; maxproduct):\n            maxproduct = product\n# Check vertical products\nfor i in range(len(grid) - 3):\n    for j in range(len(grid[i])):\n        product = 1\n        for k in range(4):\n            product = product * grid[i + k][j]\n        if (product &gt; maxproduct):\n            maxproduct = product\n# Check increasing diagonals\nfor i in range(len(grid) - 3):\n    for j in range(3, len(grid[i])):\n        product = 1\n        for k in range(4):\n            product = product * grid[i + k][j - k]\n        if (product &gt; maxproduct):\n            maxproduct = product\n# Check decreasing diagonals\nfor i in range(len(grid) - 3):\n    for j in range(len(grid[i]) - 3):\n        product = 1\n        for k in range(4):\n            product = product * grid[i + k][j + k]\n        if (product &gt; maxproduct):\n            maxproduct = product\n# Finish\nprint(maxproduct)\n\nRunning these loops gives us,\n70600674\n0.002657975308641975 seconds.\n\nThus, 70600674 is our answer.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-27-011-Largest-product-in-grid/"
    },{
      
      "title": "#12 - Highly divisible triangular number",
      "date": "2015-07-27 10:30:00 +0000",
      
      "content": "\n  The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:\n\n\\[1, 3, 6, 10, 15, 21, 28, 36, 45, 55, \\dots\\]\n\n  Let us list the factors of the first seven triangular numbers:\n  \n    1: 1\n    3: 1, 3\n    6: 1, 2, 3, 6\n    10: 1, 2, 5, 10\n    15: 1, 3, 5, 15\n    21: 1, 3, 7, 21\n    28: 1, 2, 4, 7, 14, 28\n  \n\n  We can see that 28 is the first triangular number to have over five divisors.\n\n  What is the value of the first triangle number to have over five hundred divisors?\n\n\n\nWe will take an optimized brute force approach. The formula for the $n^{\\text{th}}$ triangular number $T_n$ is\n\n[T_n = \\sum_{i=1}^n i = \\frac{n(n+1)}{2}]\n\nIt is possible for us to look for the factors in a brute force manner, by looping until $\\sqrt{T_n}$. However, note that the problem doesn’t require us to find the factors themselves, only the number of divisors. If we have the prime factorization of a number, it is trivial to find the number of divisors. If the prime factorization of $n$ is\n\n[n = p_1^{e_1}p_2^{e_2}\\cdots p_k^{e_k}]\n\nThen the number of divisors $D$ is\n\n[D = \\prod_{i=1}^k (e_i+1)]\n\nAdd one to each exponent, and multiply them all together. This is the method we will use.\n# file: \"problem012.py\"\ndef numOfFactors(n):\n    # Get prime numbers less\n    # than square root of n\n    primes = primesieve.primes(n ** 0.5)\n    # Filter...\n    primes = [p for p in primes if n % p == 0]\n    # Now we need to find powers...\n    prod = 1\n    for p in primes:\n        count = 0\n        while n % p == 0:\n            count += 1\n            n //= p\n        # Multiply by one more\n        # than the number of powers\n        prod *= (count + 1)\n    return prod\n    \nn = 8\nwhile True:\n    num = n * (n + 1) // 2\n    f = numOfFactors(num)\n    if f &gt; 500:\n        print(num)\n        break\n    n += 1\n\nRunning gives\n76576500\n0.7927415999874938 seconds.\n\nThus, 76576500 is our answer.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-27-012-Highly-divisible-triangular-number/"
    },{
      
      "title": "#13 - Large sum",
      "date": "2015-07-27 10:41:00 +0000",
      
      "content": "\n  Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.\n  37107287533902102798797998220837590246510135740250\n46376937677490009712648124896970078050417018260538\n74324986199524741059474233309513058123726617309629\n91942213363574161572522430563301811072406154908250\n23067588207539346171171980310421047513778063246676\n89261670696623633820136378418383684178734361726757\n28112879812849979408065481931592621691275889832738\n44274228917432520321923589422876796487670272189318\n47451445736001306439091167216856844588711603153276\n70386486105843025439939619828917593665686757934951\n62176457141856560629502157223196586755079324193331\n64906352462741904929101432445813822663347944758178\n92575867718337217661963751590579239728245598838407\n58203565325359399008402633568948830189458628227828\n80181199384826282014278194139940567587151170094390\n35398664372827112653829987240784473053190104293586\n86515506006295864861532075273371959191420517255829\n71693888707715466499115593487603532921714970056938\n54370070576826684624621495650076471787294438377604\n53282654108756828443191190634694037855217779295145\n36123272525000296071075082563815656710885258350721\n45876576172410976447339110607218265236877223636045\n17423706905851860660448207621209813287860733969412\n81142660418086830619328460811191061556940512689692\n51934325451728388641918047049293215058642563049483\n62467221648435076201727918039944693004732956340691\n15732444386908125794514089057706229429197107928209\n55037687525678773091862540744969844508330393682126\n18336384825330154686196124348767681297534375946515\n80386287592878490201521685554828717201219257766954\n78182833757993103614740356856449095527097864797581\n16726320100436897842553539920931837441497806860984\n48403098129077791799088218795327364475675590848030\n87086987551392711854517078544161852424320693150332\n59959406895756536782107074926966537676326235447210\n69793950679652694742597709739166693763042633987085\n41052684708299085211399427365734116182760315001271\n65378607361501080857009149939512557028198746004375\n35829035317434717326932123578154982629742552737307\n94953759765105305946966067683156574377167401875275\n88902802571733229619176668713819931811048770190271\n25267680276078003013678680992525463401061632866526\n36270218540497705585629946580636237993140746255962\n24074486908231174977792365466257246923322810917141\n91430288197103288597806669760892938638285025333403\n34413065578016127815921815005561868836468420090470\n23053081172816430487623791969842487255036638784583\n11487696932154902810424020138335124462181441773470\n63783299490636259666498587618221225225512486764533\n67720186971698544312419572409913959008952310058822\n95548255300263520781532296796249481641953868218774\n76085327132285723110424803456124867697064507995236\n37774242535411291684276865538926205024910326572967\n23701913275725675285653248258265463092207058596522\n29798860272258331913126375147341994889534765745501\n18495701454879288984856827726077713721403798879715\n38298203783031473527721580348144513491373226651381\n34829543829199918180278916522431027392251122869539\n40957953066405232632538044100059654939159879593635\n29746152185502371307642255121183693803580388584903\n41698116222072977186158236678424689157993532961922\n62467957194401269043877107275048102390895523597457\n23189706772547915061505504953922979530901129967519\n86188088225875314529584099251203829009407770775672\n11306739708304724483816533873502340845647058077308\n82959174767140363198008187129011875491310547126581\n97623331044818386269515456334926366572897563400500\n42846280183517070527831839425882145521227251250327\n55121603546981200581762165212827652751691296897789\n32238195734329339946437501907836945765883352399886\n75506164965184775180738168837861091527357929701337\n62177842752192623401942399639168044983993173312731\n32924185707147349566916674687634660915035914677504\n99518671430235219628894890102423325116913619626622\n73267460800591547471830798392868535206946944540724\n76841822524674417161514036427982273348055556214818\n97142617910342598647204516893989422179826088076852\n87783646182799346313767754307809363333018982642090\n10848802521674670883215120185883543223812876952786\n71329612474782464538636993009049310363619763878039\n62184073572399794223406235393808339651327408011116\n66627891981488087797941876876144230030984490851411\n60661826293682836764744779239180335110989069790714\n85786944089552990653640447425576083659976645795096\n66024396409905389607120198219976047599490197230297\n64913982680032973156037120041377903785566085089252\n16730939319872750275468906903707539413042652315011\n94809377245048795150954100921645863754710598436791\n78639167021187492431995700641917969777599028300699\n15368713711936614952811305876380278410754449733078\n40789923115535562561142322423255033685442488917353\n44889911501440648020369068063960672322193204149535\n41503128880339536053299340368006977710650566631954\n81234880673210146739058568557934581403627822703280\n82616570773948327592232845941706525094512325230608\n22918802058777319719839450180888072429661980811197\n77158542502016545090413245809786882778948721859617\n72107838435069186155435662884062257473692284509516\n20849603980134001723930671666823555245252804609722\n53503534226472524250874054075591789781264330331690\n  \n\n\n\nPython is really good at fast calculations with very large numbers. Therefore, to solve this problem, all we have to do is copy these numbers to a file, loop through them and add. I save these numbers to a file called problem013.txt.\n# file: \"problem013.py\"\n# Read file\nwith open(\"problem013.txt\") as f:\n    # Convert each line into an integer\n    numbers = [int(num) for num in f.read().splitlines()]\n# Add them up\ns = 0\nfor i in range(len(numbers)):\n    s += numbers[i]\n# Convet to string so we get the first ten 10 digits\nprint(str(s)[:10])\n\nOur output is,\n5537376230\n0.00021430000197142363 seconds.\n\nOur answer is 5537376230.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-27-013-Large-sum/"
    },{
      
      "title": "#14 - Longest Collatz sequence",
      "date": "2015-07-27 11:07:00 +0000",
      
      "content": "\n  The following iterative sequence is defined for the set of positive integers:\n\n\\[n = \\begin{cases} \\frac{n}{2},\\quad &amp;n\\text{ is even} \\\\ 3n + 1, \\quad &amp;n\\text{ is odd} \\end{cases}\\]\n\n  Using the rule above and starting with 13, we generate the following sequence\n\n\\[13 \\rightarrow 40 \\rightarrow 20 \\rightarrow 10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1\\]\n\n  It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.\n\n  Which starting number, under one million, produces the longest chain?\n\n  Once the chain starts, the terms are allowed to go over one million.\n\n\n\nIt is unfeasible to brute force every starting number, especially since we don’t know how long the longest chain is. Instead, we can use dynamic programming. For example, when starting with 26, the next number is 13. However, we know that the sequence starting with 13 has 10 terms, so that means the sequence with 26 must have 11 terms. We can avoid a lot of repeated calculations using this method.\n\nIn code, we utilize a dictionary to save the sequence lengths of numbers we have already found. We can use defaultdict from the collections package to automatically initilazie all elements not explicitly set to 0.\n# file: \"problem014.py\"\nlimit = 1000000\nseq_lengths = defaultdict(int)\nseq_lengths[1] = 1\n\nfor n in range(2, limit + 1):\n    sequence = [n]\n    while seq_lengths[sequence[-1]] == 0:\n        if sequence[-1] % 2 == 0:\n            sequence.append(sequence[-1] // 2)\n        else:\n            sequence.append(3 * sequence[-1] + 1)\n    # Set all numbers in the sequence to the right number.\n    # We start at the first number that we have already,\n    # and add the index in reverse.\n    start_length = seq_lengths[sequence[-1]]\n    for i, num in enumerate(sequence[::-1][1:], 1):\n        seq_lengths[num] = start_length + i\n# Return the max, filtering out starting numbers greater than the limit\nmax_n, max_len = max(((k, v) for k, v in seq_lengths.items() if k &lt;= limit), key=lambda x: x[1])\nprint(f'{max_n} has the longest sequence starting under one million with {max_len} terms.')\n\nRunning our loop, our answer is thus,\n837799 has the longest sequence starting under one million with 525 terms.\n2.28711679999833 seconds.\n\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-07-27-014-Longest-Collatz-sequence/"
    },{
      
      "title": "#15 - Lattice paths",
      "date": "2015-08-07 20:44:00 +0000",
      
      "content": "\n  Starting in the top left corner of a 2 x 2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.\n\n  \n\n  Lattice paths\n\n  How many such routes are there through a 20 x 20 grid?\n\n\n\nWe can use dynamic programming here, since we have optimal substructure. The rule of the number of paths ending at a single cell does not change depending on where you are at. Meaning, if we had the number of paths for the cell immediately to the left, and above, all we have to do is add them.. In this way, we have turned this into a very fast solution, at the expense of storing the entire grid.\n# file: \"problem015.py\"\nsize = 20\n# It's (size + 1) because a size x size grid\n# has (size + 1) intersections across the top and\n# down.\ngrid = np.zeros((size + 1, size + 1), dtype=object)\n# The top row and left column only\n# have 1 way to get there.\ngrid[0] = 1\ngrid[:, 0] = 1\n# For each inner grid point, add\n# the number to its left and up\nfor i in range(1, size + 1):\n    for j in range(1, size + 1):\n        grid[i, j] = grid[i - 1, j] + grid[i, j - 1]\n# The number in the bottom right corner is what\n# we want.\nprint(grid[-1, -1])\n\nRunning our quick loop,\n137846528820\n0.0002860246913580247 seconds.\n\nTherefore, our answer is 137846528820.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff","Dynamic programming"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-08-07-015-Lattice-paths/"
    },{
      
      "title": "#16 - Power digit sum",
      "date": "2015-08-07 20:45:00 +0000",
      
      "content": "\n  $2^{15} = 32768$ and the sum of its digits is $3 + 2 + 7 + 6 + 8 = 26$.\n\n  What is the sum of the digits of the number $2^{1000}$?\n\n\n\nAs said in #13 - Large sum, Python is really good at handling large numbers. All we have to do here is compute teh large power, convert it to string, and add all the digits.\n# file: \"problem016.py\"\n# Create array of digits in 2 ^ 1000\nnum = [int(i) for i in str(2 ** 1000)]\n# Add them up\nprint(sum(num))\n\nRunning this short code,\n1366\n0.00012523456790123458 seconds.\n\nTherefore, the sum of the digits is 1366.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-08-07-016-Power-digit-sum/"
    },{
      
      "title": "#17 - Number letter counts",
      "date": "2015-08-07 20:46:00 +0000",
      
      "content": "\n  If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.\n\n  If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?\n\n  Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of “and” when writing out numbers is in compliance with British usage.\n\n\n\nWe need to break up this problem into cases, as numbers from 1 to 19 do not follow any problem. The tens also follow their own pattern. However, if the number is big enough, we can extract the hundreds place digit and recurse downwards. We can integer divide and do modular arithmetic to extract the digit and whatever is left over, respectively. The following recursive function would return the number of letters for the numbers we care about (&lt; 1000).\n# file: \"problem017.py\"\ndef letter_count(n):\n    ones = ['one', 'two', 'three', 'four', 'five',\n              'six', 'seven', 'eight', 'nine']\n    teens = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen',\n             'sixteen', 'seventeen', 'eighteen', 'nineteen']\n    tens = [None, 'twenty', 'thirty', 'forty', 'fifty',\n            'sixty', 'seventy', 'eighty', 'ninety']\n    # Ultimate base case is if our number is 0. \n    # This means we've exhausted the digits.\n    if n == 0:\n        return 0\n    # Base case is if our number is less than 20. \n    # There is a separate word for each number from 1-19.\n    if n &lt; 20:\n        if n &lt; 10:\n            return len(ones[n - 1])\n        else:\n            return len(teens[n - 10])\n    # If we're between 20 and 100,\n    # then we need to extract the tens and the ones\n    elif 20 &lt;= n &lt; 100:\n        return len(tens[n // 10 - 1]) + letter_count(n % 10)\n    # If we're at least one hundred, then extract\n    # the hundred's place and call the count again.\n    else:\n        total = len(ones[n // 100 - 1]) + len('hundred')\n        # If we're a multiple of hundred, then we don't need the \"and\".\n        # Otherwise, add 3 to the length for \"and\" and recurse.\n        if n % 100 != 0:\n            return total + 3 + letter_count(n % 100)\n    return total\n\nNow all we need to do is loop through and call the function,\n# file: problem017.py\ntotal = 0\nfor n in range(1, 1000):\n    total += letter_count(n)\ntotal += len('one') + len('thousand')\nprint(total)\n\nRunning our loop,\n21124\n0.002460049382716049 seconds.\n\nThus, 21124 is our answer.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-08-07-017-Number-letter-counts/"
    },{
      
      "title": "#18 - Maximum path sum I",
      "date": "2015-08-07 20:47:00 +0000",
      
      "content": "\n  By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.\n\n  \n3\n7 4\n2 4 6\n8 5 9 3\n\n\n  That is, 3 + 7 + 4 + 9 = 23.\n\n  Find the maximum total from top to bottom of the triangle below:\n\n  \n75\n95 64\n17 47 82\n18 35 87 10\n20 04 82 47 65\n19 01 23 75 03 34\n88 02 77 73 07 63 67\n99 65 04 28 06 16 70 92\n41 41 26 56 83 40 80 70 33\n41 48 72 33 47 32 37 16 94 29\n53 71 44 65 25 43 91 52 97 51 14\n70 11 33 28 77 73 17 78 39 68 17 57\n91 71 52 38 17 14 91 43 58 50 27 29 48\n63 66 04 68 89 53 67 30 73 16 69 87 40 31\n04 62 98 27 23 09 70 98 73 93 38 53 60 04 23\n\n\n  As there are only 16384 routes, it is possible to solve this problem by trying every route. However, Problem 67, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)\n\n\n\nLet’s code the “clever method” from the start, so that Problem 67 will be easy. Notice that we don’t need the path itself, just the sum. Just like with the #15 - Lattice paths, we can compute the largest sum in each row as we go. At a given row, we compare the max sum to the left, and to the right above, and sum whichever sum would be greater to the current row. Here’s how we do it with the given example in the 2nd and 3rd iteration.\n\n\n10 7\n2 4 200\n8 5 9 3\n\n\n\n12 14 207\n8 5 9 3\n\n\nThe final row is,\n\n20 19 216 210\n\n\nWe see the greatest number in the last row is 216. We can actually go in the other direction, comparing sums from below. In this manner, we end with one number at the top, so I’ll be using this method.\n\n\n3\n7 4\n10 13 209\n\n\n\n3\n20 213\n\n\n\n216\n\n\nI have saved the triangle in problem018.txt. Te make reading the file easier, I have placed numbers which are below and to the left in the triangle directly below it in the text file, like so:\n\n75\n95 64\n17 47 82\n18 35 87 10\n...\n\n\n# file: \"problem018.py\"\n# open file and convert to integers and make 2d array.\nwith open(\"problem018.txt\") as f:\n    triangle = [list(map(int, line.split(' '))) for line in f.read().splitlines()]\n# Work bottom to top, starting from the second to last\n# row so we can numbers below.\nfor i in range(len(triangle) - 2, -1, -1):\n    for j in range(len(triangle[i])):\n        # The number to the \"bottom left\" is really just below,\n        # in terms of indices, and \"bottom right\" is diagonally right.\n        triangle[i][j] = triangle[i][j] + max(triangle[i + 1][j], triangle[i + 1][j + 1])\n# Grab the top number.\nprint(triangle[0][0])\n\nRunning our loop gives,\n1074\n0.0003338271604938272 seconds.\n\nTherefore, our needed sum is 1074.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff","Dynamic programming"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-08-07-018-Maximum-path-sum-I/"
    },{
      
      "title": "#19 - Counting Sundays",
      "date": "2015-08-07 20:49:00 +0000",
      
      "content": "\n  You are given the following information, but you may prefer to do some research for yourself.\n\n  \n    1 Jan 1990 was a Monday.\n    Thirty days has September.\nApril, June and November.\nAll the rest have thirty-one,\nSaving February alone,\nWhich has twenty-eight, rain or shine.\nAnd on leap years, twenty-nine.\n    A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.\n  \n\n  How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?\n\n\n\nThis problem is slightly made easier by the fact that we only have to keep track of the firsts of the months. There are 7 days per week, which rotate on a cycle. We can use modular arithmetic to handle continuous rotations. The numbers 0-6 will be used to denote Sunday through Saturday. As stated in the problem, January 1st 1990 was a Monday. January has 31 days as well, so\n\n\\(31 \\equiv 3\\mod 7\\)\nmeans that January has 4 full weeks, plus 3 extra days. Therefore, add 3 days to Monday, and we can conclude that February 1st 1990 was a Thursday. We do this each month starting from January 1st 1901 until we hit the end of the century. The year 1900 was not a leap year, so it had 365 days. Thus, January 1st 1901 was a Tuesday (since $365\\equiv 1\\mod 7$). Any time the number is 0, that represents a Sunday and we have to count it. We hardcode the number of days per month, and we also need to keep track of leap years, which is straightforward.\n# file: \"problem019.py\"\n# Days will be numbered 0, 1, 2, ... -&gt; Sunday, Monday, Tuesday, ...\n# Months will be numbered 0-11.\n# Given that 1 Jan 1990 is Monday\nfirstDay = 1\n# We need to start counting from Jan 1 1901 though.\n# 1900 was NOT a leap year, so there were 365 days...\nfirstDay += 365 % 7\n# Array to hold number of dayskfor each month from Jan to Dec\nmonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\nnumOfSundays = 0\nfor year in range(1901, 2001):\n    for month in range(12):\n        # Check if it's a sunday...\n        if firstDay == 0:\n            numOfSundays += 1\n        # First check if it's a leap year.\n        # We need to mod afterwards as well\n        # Because there is a chance the addition will take it over 7...\n        # Remember 0-indexing, so month == 1 means it's the second month.\n        if (month == 1) and ((year % 100 != 0 and year % 4 == 0) or (year % 400 == 0)):\n            firstDay = (firstDay + 29 % 7) % 7\n        else:\n            firstDay = (firstDay + monthDays[month] % 7) % 7\n\nprint(numOfSundays)\n\nRunning the code gives an output of,\n171\n0.0008150123456790123 seconds.\n\nTherefore, there are 171 Sundays that fall on the first of the month from January 1st 1901 to December 31st 2000.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-08-07-019-Counting-Sundays/"
    },{
      
      "title": "#20 - Factorial digit sum",
      "date": "2015-08-07 20:51:00 +0000",
      
      "content": "\n  $n!$ means $n\\times (n-1)\\times\\cdots\\times 3\\times 2\\times 1$.\n\n  For example, $10! = 10\\times 9\\times\\cdots\\times 3\\times 2\\times 1 = 3628800$, and the sum of the digits in the number $10!$ is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.\n\n  Find the sum of the digits in the number $100!$.\n\n\n\nAs said before, Python can very easily handle large numbers. We write a simple loop to calculate $n!$ (though there is one built into the math package). To extract the digits, we convert the number into a string, and map the int function in each element.\n# file: \"problem020.py\"\ndef factorial(n):\n    product = 1\n    for i in range(2, n + 1):\n        product *= i\n    return product\nn = 100\nfact = factorial(n)\ns = sum([int(chara) for chara in str(fact)])\nprint(s)\n\nAt the end, the output is\n648\n9.362962962962964e-05 seconds.\n\nThus, the sum is 648.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-08-07-020-Factorial-digit-sum/"
    },{
      
      "title": "#21 - Amicable numbers",
      "date": "2015-08-13 10:21:00 +0000",
      
      "content": "\n  Let $d(n)$ be defined as the sum of proper divisors of $n$ (numbers less than $n$ which divide evenly into $n$).\nIf $d(a) = b$ and $d(b) = a$, where $a\\neq b$, then $a$ and $b$ are an amicable pair and each of $a$ and $b$ are called amicable numbers.\n\n  For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore $d(220) = 284$. The proper divisors of 284 are 1, 2, 4, 71, and 142; so $d(284) = 220$.\n\n  Evaluate the sum of all the amicable numbers under 10000.\n\n\n\nWe will need an efficient method to finding the sum of the proper divisors of $n$ outside of a brute force approach. Using the prime factorization of $n$, it is possible to directly derive the sum of the proper divisors, without explicitly finding the divisors themselves. Let’s use the number in the example:\n\n\\(220 = 2^2\\times 5\\times 11\\)\nThe divisors of $n$ will be a subproduct of the prime factorization of $n$. For example, 10 is a divisor, and $10=2\\times 5$. Below is the full list:\n\n[1 \\ 2 \\ 2^2 \\ 5 \\ 2\\times 5 \\ 11 \\ 2^2\\times 5 \\ 2\\times 11 \\ 2^2\\times 11 \\ 5\\times 11 \\ 2\\times 5\\times 11 \\ 2^2\\times 5\\times 11]\n\nWriting this another way, we can see a pattern,\n\n[2^0 5^0 11^0 \n2^1 5^0 11^0 \n2^2 5^0 11^0 \n2^0 5^1 11^0 \n2^1 5^1 11^0 \n2^0 5^0 11^1 \n2^2 5^1 11^0 \n2^1 5^0 11^1 \n2^2 5^0 11^1 \n2^0 5^1 11^1 \n2^1 5^1 11^1 \n2^2 5^1 11^1]\n\nIf we simplify the sum, we can easily factor as follows:\n\n[\\begin{aligned}\n2^0 5^0 11^0 + 2^1 5^0 11^0 + \\cdots + 2^2 5^1 11^1 &amp;=\n\t(2^0 + 2^1 + 2^1)(5^0 11^0 + 5^1 11^0 + 5^0 11^1 + 5^1 11^1)\n\\ &amp;=\n(2^0 + 2^1 + 2^2)(5^0 + 5^1)(11^0 + 11^1)\n\\end{aligned}]\n\nThis sum includes $n$ itself, so we need to subtract it off. Additionally, notice that each individual sum in the product is a sum of a geometric series. Recall that if $a$ is the first term and $r$ is the common ratio, then\n\n[\\sum_{i=0}^n ar^i = a\\left( \\frac{r^{n+1} - 1}{r - 1} \\right)]\n\nIn our case, $a = 1$. Therefore, if we have $m$ prime factors $p_1, p_2, \\cdots, p_m$ with exponents $k_1, k_2, \\cdots, k_m$ respectively, then\n\n[d(n) = \\prod_{i=1}^m \\frac{p_i^{k_i+1}}{p_i-1} - n]\n\nIn our example, since $220 = 2^2\\times 5\\times 11$, this means\n\n[d(220) = \\left( \\frac{2^3 - 1}{2 - 1} \\right)\\left( \\frac{5^2 - 1}{5 - 1} \\right)\\left( \\frac{11^2 - 1}{11 - 1} \\right) - 220 = 7(6)(12) - 220 = \\boxed{284}]\n\nBelow is the Python function d(n, primes) which does the same calculation.\n# file: \"problem021.py\"\ndef d(n, primes):\n    # 0 and 1 have no proper divisors, so return 0.\n    if n &lt;= 1:\n        return 0\n    # If n is a prime, then by definition d(n) = 1\n    if n in primes:\n        return 1\n    # underPrimes = primes[primes &lt;= n ** 0.5]\n    primeFacts = []\n    powers = []\n    ### PRIME FACTORIZATION\n    # Test each prime to see if it divides\n    num = n\n    for p in primes:\n        # Keep dividing until it can't.\n        # Keep a counter for the number of times.\n        power = 0\n        while num % p == 0:\n            num //= p\n            power += 1\n        # If we've divided, then this is a factor.\n        if power &gt; 0:\n            primeFacts.append(p)\n            powers.append(power)\n        # If num became 1, then we've exhausted all\n        # factors, no need to check.\n        if num == 1:\n            break\n    ### CALCULATING SUM OF PROPER DIVISORS\n    # Take each prime and respective power,\n    # and do (p^(k+1) - 1)/(p-1)\n    s = 1\n    for prime, power in zip(primeFacts, powers):\n        s *= (prime ** (power + 1) - 1) // (prime - 1)\n    # The product includes n, which isn't a\n    # PROPER divisor, so subtract.\n    s -= n\n    return s\n\nOnce we have this, we just loop through all numbers up to 10000, and see if we find amicable pairs.\n# file: \"problem021.py\"\nlimit = 10000\nprimes = primesieve.primes(limit)\n# For each number from 0 to 9999, find\n# d(n).\nDs = [d(i, primes) for i in range(limit)]\n# Now go through the list and search\n# for amicable numbers.\ns = 0\nfor n, propSum in enumerate(Ds):\n    # The first check is necessary because\n    # we don't want perfect numbers.\n    if n != propSum and propSum &lt; limit and Ds[propSum] == n:\n        s += n\n        print(n, end=' ')\nprint()\nprint(s)\n\nRunning our code results in an output of,\n220 284 1184 1210 2620 2924 5020 5564 6232 6368 \n31626\n0.13923039997462183 seconds.\n\nThus, 31626 is the sum we are looking for. You can also see the other pairs we have found.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-08-13-021-Amicable-numbers/"
    },{
      
      "title": "#22 - Names scores",
      "date": "2015-08-14 04:04:00 +0000",
      
      "content": "\n  Using names.txt (right click and ‘Save Link/Target As…’), a 46k text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.\n\n  For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 x 53 = 49714.\n\n  What is the total of all the name scores in the file?\n\n\n\nThe problem itself tells us how to solve it. There is no need for anything complicated. In Python, there is the ord() function, which returns the ASCII integer code for the given character. Additionally, since “A” has a value of 65, we need to subtract 64 from the value of ord() so that “A” properly maps to 1.\n# file: \"problem022.py\"\n# Each name is in double quotes, separated\n# by commas. So remove the quotes and split on the comma.\nwith open(\"problem022.txt\") as f:\n    names = f.readline().replace('\"', '').split(',')\nnames.sort()  # sort alphabetically\n\ntotal = 0\n\nfor i, name in enumerate(names, 1):\n    score = 0\n    # For each letter, grab the ASCII code integer,\n    # and subtract 64, because 'A' is 64.\n    for chara in name:\n        score += ord(chara) - 64\n    score *= i + 1\n    total += score\nprint(total)\n\nRunning this simple loop, we get\n871522818\n0.007237999991048127 seconds.\n\nThus, 871522818 is our answer.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-08-14-022-Names-scores/"
    },{
      
      "title": "#23 - Non-abundant sums",
      "date": "2015-08-14 09:10:00 +0000",
      
      "content": "\n  A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.\n\n  A number $n$ is called deficient if the sum of its proper divisors is less than $n$ and it is called abundant if this sum exceeds $n$.\n\n  As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.\n\n  Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.\n\n\n\nThe $d(n)$ function we developed in #21 - Amicable numbers. To recap, given the prime factorization\n\n[n = p_1^{k_1}p_2^{k_2}\\cdots p_m^{k_m}]\n\nthe sum of proper divisors is given by\n\n[d(n) = \\prod_{i=1}^m \\frac{p_i^{k_i+1}}{p_i-1} - n]\n\nIn this problem, we have to go until 28123 and grab all numbers which are abundant. Additionally, it is easier to find the inverse of the statement: Find which numbers can be written as the sum of two abundant numbers.\n\nSince the list is sorted, we can run a double for loop that goes through each pair of numbers. We can break out of the inner loop once we reach a sum bigger than 28123 to save some time. Once we have the numbers, we can sum these up, and subtract it from the sum of all numbers from 1 to 28123, which recall has a closed-from formula of $\\frac{n(n+1)}{2}$.\n# file: \"problem023.py\"\nlimit = 28123\nprimes = primesieve.primes(limit)\nDs = [d(i, primes) for i in range(limit + 1) if d]\n\n# Go through and remove all numbers which aren't\n# abundant.\nabundantNums = [i for i, num in enumerate(Ds) if num &gt; i]\n\n# Find all numbers which can be written\nsums = set()\nfor i in range(len(abundantNums) - 1):\n    for j in range(i, len(abundantNums)):\n        s = abundantNums[i] + abundantNums[j]\n        # Break out if s &gt; 28123\n        if s &gt; limit:\n            break\n        # Add the sum to the list\n        sums.add(s)\n# We can subtract the sum of all\n# numbers from 1 to 28123 from the sum\n# of this set...\nprint(limit * (limit + 1) // 2 - sum(sums))\n\nWe use set() because we might encounter numbers which have two separate sums. Running the code above results in an output of\n4179871\n3.11050750000868 seconds.\n\nThus, 4179871 is the sum of all positive integers which can’t be written as the sum of two abundant numbers.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2015-08-14-023-Non-abundant-sums/"
    },{
      
      "title": "#24 - Lexicographic permutations",
      "date": "2016-05-05 11:41:00 +0000",
      
      "content": "\n  A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3, and 4. If all the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:\n\n  \n    012\t021\t102\t120\t201\t210\n\n\n  What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?\n\n\n\nThere are $10! = 3\\,628\\,800$ permutations, which makes it infeasible to comb through them all. We need a way to find the next permutation that comes lexicographically after the current one. Fortunately, this is a common problem, and many have written about it. I will be using the algorithm used here, which also provides an example.\n\nThe algorithm is as follows:\n\n  Find the first element $x$ from the right that does not follow non-increasing order.\n  Swap $x$ with the smallest element greater than $x$ in the non-increasing part of the string.\n  Reverse the non-increasing part of the string.\n\n\nUsing Python’s generators, we can generate the permutations on the fly and not waste any space. I also use a small helper function for step 1 in the process.\n# file: \"problem024.py\"\n# Returns index of first element\n# from RIGHT which isn't in\n# non-increasing order.\ndef indexOfNonIncreasing(list_):\n    j = len(list_) - 1\n    while j &gt; 0 and list_[j] &lt;= list_[j-1]:\n        j -= 1\n    # If i is 0, then the whole list is\n    # in non-increasing order.\n    return j - 1\n\ndef genPermutations(charaSet):\n    # While we haven't gotten to the\n    # last permutation\n    index = indexOfNonIncreasing(charaSet)\n    while index != -1:\n        # Find the least element greater\n        # than what's at index...\n        leastEle = index + 1\n        while leastEle &lt; len(charaSet) and charaSet[leastEle] &gt; charaSet[index]:\n            leastEle += 1\n        # At this point we'll be one over, so subtract one.\n        leastEle -= 1\n        # Swap the numbers at the two locations\n        temp = charaSet[index]\n        charaSet[index] = charaSet[leastEle]\n        charaSet[leastEle] = temp\n        # Reverse the portion of non-increasingness\n        charaSet[index + 1:] = charaSet[index + 1:][::-1]\n        # Yield it.\n        yield charaSet\n        # Find the next index\n        index = indexOfNonIncreasing(charaSet)\n\nNow we run a loop until we hit the millionth one. One quirk with generators is that it runs once before it technically enters the for loop, so our iterator variable will actually be at 999999.\n# file: \"problem024.py\"\ndigits = list(range(10))\nfor i, perm in enumerate(genPermutations(digits), 1):\n    # The generator runs once before it enters the loop,\n    # so we need the permutation at 999999\n    if i == 999999:\n        print(''.join(map(str, perm)))\n        break\n\nAfter running, the output is\n2783915460\n0.9399120999732986 seconds.\n\nThus, 2783915460 is the millionth permutation.\nBonus\nIt’s actually possible to solve this problem using a basic calculator to find each digit from left to right.\n\nNotice that with the 10 digits we have on hand, there are exactly $9! = 362\\,880$ permutations that start with each digit. Additionally, since we know that the permutations need to be in lexicographic order, the first $362\\,880$ permutations will start with $0$, while the next $362\\,880$ will start with $1$, and so on. Because $3\\times362\\,880&gt;1\\,000\\,000$, the one millionth iteration starts with $2$. Additionally, the first permutation that starts with $2$ is $2013456789$, the $725\\,761^{\\text{th}}$ one.\n\nWe can do the same analysis for the second digit. There are $1\\,000\\,000-725\\,760 = 274\\,240$ more permutations left. This time, there are $8! = 40\\,320$ permutations that start with each of the digits, except for $2$, since we already used that. $\\lceil274\\,240 / 40\\,320\\rceil = 7$, so the seventh digit in our list, or $7$ will be the second digit in the one millionth digit.\n\nSo, in each step, we divide the remaining permutations to go by the number of ways to arrange the remaining digits, and take the ceiling to find which digit to use. In code, we do integer division i.e. the floor function, because we are dealing with 0-indexing. In the same manner, we decrement the number of permutations left by 1 before we divide. See below:\n\n# file: \"problem024.py\"\ndigits = list('0123456789')\npermNum = 1000000\nperm = ''\nfor i in range(1, 11):\n    ways = math.factorial(10 - i)\n    # It's permNum - 1 because integer\n    # division is 0-index like.\n    # If ways is 2, then the 4th permutation should\n    # still be the 2nd digit, not the 3rd digit.\n    loc = (permNum - 1) // ways\n    digit = digits[loc]\n    # Remove the element at loc.\n    del digits[loc]\n    perm += digit\n    # Subtract\n    permNum -= loc * ways\n\nprint(perm)\n\n\nRunning the above results in an output of,\n\n2783915460\n7.94073132950361e-05 seconds.\n\n\nNotice the time is much faster, almost instantaneously.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-05-024-Lexicographic-permutations/"
    },{
      
      "title": "#25 - 1000-digit Fibonacci number",
      "date": "2016-05-06 00:00:00 +0000",
      
      "content": "\n  The Fibonnaci sequence is defined by the recurrence relation:\n\n\\[F_n = F_{n-1} + F_{n-2}\\]\n\n  where $F_1=1$ and $F_2=1$.\n\n  Hence the first 12 terms will be:\n\n\\[\\begin{aligned}\n\tF_1 &amp;= 1 \\\\\n\tF_2 &amp;= 1 \\\\\n\tF_3 &amp;= 2 \\\\\n\tF_4 &amp;= 3 \\\\\n\tF_5 &amp;= 5 \\\\\n\tF_6 &amp;= 8 \\\\\n\tF_7 &amp;= 13 \\\\\n\tF_8 &amp;= 21 \\\\\n\tF_9 &amp;= 34 \\\\\n\tF_{10} &amp;= 55 \\\\\n\tF_{11} &amp;= 89 \\\\\n\tF_{12} &amp;= 144\n\\end{aligned}\\]\n\n  The 12th term, $F_{12}$, is the first term to contain three digits.\n\n  What is the index of the first term in the Fibonacci sequence to contain 1000 digits?\n\n\n\nTo quickly figure out the number of digits of a number $n$, we do $\\lfloor \\log_{10} n \\rfloor + 1$. This prevents us from converting to a string every time, which is a relatively expensive operation. Therefore, we can continually generate numbers until we find the number we want.\n# file: \"problem025.py\"\ndigitNum = 1000\na = 1\nb = 1\nn = 2\nwhile math.log10(b) + 1 &lt; digitNum:\n    temp = a + b\n    a = b\n    b = temp\n    n += 1\n\nprint(n)\n\nRunning this quick loop,\n4782\n0.0020837000338360667 seconds.\n\nThus, the 4782nd Fibonacci number has at least 1000 digits.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-06-025-1000-digit-Fibonacci-number/"
    },{
      
      "title": "#26 - Reciprocal cycles",
      "date": "2016-05-06 13:09:00 +0000",
      
      "content": "\n  A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:\n\n\\[\\begin{aligned}\n\\frac{1}{2} &amp;= 0.5 \\\\\n\\frac{1}{3} &amp;= 0.\\overline{3} \\\\\n\\frac{1}{4} &amp;= 0.25 \\\\\n\\frac{1}{5} &amp;= 0.2 \\\\\n\\frac{1}{6} &amp;= 0.1\\overline{6} \\\\\n\\frac{1}{7} &amp;= 0.\\overline{142857} \\\\\n\\frac{1}{8} &amp;= 0.125 \\\\\n\\frac{1}{9} &amp;= 0.\\overline{1} \\\\\n\\frac{1}{10} &amp;= 0.1\n\\end{aligned}\\]\n\n  where $0.1\\overline{6}$ means 0.166666…, and has a 1-digit recurring cycle. It can be seen that $\\frac{1}{7}$ has a 6-digit recurring cycle.\n\n  Find the value of $d&lt;1000$ for which $\\frac{1}{d}$ contains the longest recurring cycle in its decimal fraction part.\n\n\n\nThere are 2 things to unpack. First, we need to detect if we have a cycle. Second, and relatedly, we need to determine the length of that cycle. With the compounding inaccuracies of floating-point divisions, we need a way to find a way to determine the cycle length from $d$ itself.\n\nThis answer on Quora and the Wikipedia article give us insight in determining the cycle length. Given our fraction $\\frac{1}{d}$, we repeatedly multiply by 10 until $gcd(10,d) = 1$. Every time we multiply, we must reduce the fraction to its lowest terms. Multiplying by 10 has the same effect as moving the decimal point to the right. Therefore, after $k$ steps, the original fraction and the multipled fraction will have the same decimal repeating cycle. To find $k$, we find the smallest $k$ that satisfies $10^k\\equiv 1\\mod d$. Let’s do an example with $\\frac{1}{55}$.\n\nObserve that $gcd(10,55)=5\\neq 1$. Thus, multiply the fraction to get $\\frac{10}{55} = \\frac{2}{11}$. Now $gcd(10,11) = 1$, our condition is satisfied and we can move to the next step. We are looking for the smallest $k$ that satisfies $10^k\\equiv 1\\mod 11$.\n\n[\\begin{aligned}\n10^1 &amp;\\equiv 10\\mod 11 = 10 \n10^2 &amp;\\equiv 100\\mod 11 = 1\n\\end{aligned}]\n\nTherefore, $k=2$ and we conclude that $\\frac{1}{55}$ has a 2-digit recurring cycle, and indeed it does, as the decimal expansion is $0.0\\overline{18}$.\n\nWhat if during the first step we encounter a value of 1 for $d$?. This means that the decimal will not repeat, as the denominator only consisted of factors of 2 and 5. All fractions whose denominators with only these two prime factors will eventually terminate. Some intuition is that $\\frac{1}{2}$ and $\\frac{1}{5}$ are the only fractions with prime denominators that don’t repeat.\n\nLet’s revisit the Wikipedia article. The article states a prime denominator $p$ will have a recurring cycle length of $p-1$ unless the number 10 is a so-called multiplicative root of $p$, in which case the length will be shorter. For the purposes of this problem, this fact is out-of-scope, and this check is not necessary, as we are looking for the longest cycle. However, now we only need to check the prime numbers under 1000! To efficiently find the greatest common divisor, we can use the Euclidean algorithm.\n# file: \"problem026.py\"\ndef euclidGCD(a, b):\n    if a == 0:\n        return b\n    if a &lt; b:\n        return euclidGCD(b, a)\n    return euclidGCD(a - b * (a//b), b)\n\nmaxK = 1\nmaxN = 11\nfor n in primesieve.primes(1000):\n    numerator = 1\n    denominator = n\n    # While the gcd of the denominator\n    # and 10 isn't 1...keep multiplying\n    # by 10.\n    while euclidGCD(denominator, 10) != 1:\n        # Multiply numerator by 10,\n        # and reduce.\n        numerator *= 10\n        gcd = euclidGCD(numerator, denominator)\n        numerator //= gcd\n        denominator //= gcd\n    # If we ever encounter a denominator\n    # of 1, that means the decimal doesn't\n    # repeat, and we can skip this. Fun Fact,\n    # this happens with numbers with only\n    # 2 and 5 as their prime factors.\n    if denominator == 1:\n        continue\n    # Once 10 is co-prime, find when\n    # 10^k mod denominator is 1.\n    # This k is the length of the recurrence.\n    k = 1\n    while (10 ** k) % denominator != 1:\n        k += 1\n    # Update if it's the biggest we found.\n    if maxK &lt; k:\n        maxK = k\n        maxN = n\n\nprint('d =', maxN, 'with', maxK, 'recurring digits.')\n\nRunning our code results in\nd = 983 with 982 recurring digits.\n0.0507964999997057 seconds.\n\nTherefore, $\\frac{1}{983}$ has the longest recurring decimal cycle at 982 digits.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-06-026-Reciprocal-cycles/"
    },{
      
      "title": "#27 - Quadratic primes",
      "date": "2016-05-06 20:01:00 +0000",
      
      "content": "\n  Euler discovered the remarkable quadratic formula:\n\n\\[n^2+n+41\\]\n\n  It turns out that the formula will produce 40 primes for the consecutive integer values $0\\leq n\\leq 39$. However, when $n = 40, 40^2+40+41=40(40+1)+41$ is divisible by 41, and certainly when $n=41,41^2+41+41$ is clearly divisible by 41.\n\n  The incredible formula $n^2-79n+1601$ was discovered, which produces 80 primes for the consecutive values $0\\leq n\\leq 79$. The product of the coefficients, -79 and 1601, is -126479.\n\n  Considering quadratics of the form:\n\n\\[n^2+an+b,\\text{ where } |a|&lt;1000\\text{ and } |b|\\leq 1000\\]\n\n  where the bars indicate absolute value.\n\n  Find the product of the coefficients, $a$ and $b$, for the quadratic expression that produces the maximum number of primes for consecutive values of $n$, starting $n=0$.\n\n\n\nInitially, it feels we need to loop through all values of $a$ and $b$. However, there are a couple of observations.\n\nLet $f(n) = n^2+an+b$. The problem states $f(0)$ must be prime. However, $f(0) = b$, which means $\\mathbf{b}$ must be prime. There are about 150 primes below 1000, so that immediately reduces our search space. Additionally, $b\\neq 2$, because if $n$ is even, then $n^2+an + 2$ will be even, and thus won’t be prime.\n\nIn addition to saying $b$ is prime (and $b\\neq 2$), we can also say that $a$ is odd. Observe what happens when $a$ is even and $n$ is odd:\n\n[\\begin{aligned}\nf(Odd) &amp;= Odd^2 + Even\\times Odd+Odd \n&amp;= Odd + Even + Odd\n\\ &amp;=\nOdd + Odd \n&amp;= Even\n\\end{aligned}]\n\nEvery other $n$, $f(n)$ will be even, and hence be composite.\n\nFinally, $a &gt; -b$, because otherwise, that allows $f(n)$ to be negative. In the end, we need a double for loop that checks our constrained search space. For testing if $f(n)$ is prime, we can do the generic loop until $\\sqrt{n}$.\n# file: \"problem027.py\"\ndef isPrime(p):\n    if p &lt;= 1:\n        return False\n    if p == 2:\n        return True\n    if p % 2 == 0:\n        return False\n    for i in range(3, int(p ** 0.5) + 1):\n        if p % i == 0:\n            return False\n    return True\n\nlimit = 1000\nBs = primesieve.primes(limit)[1:]\nmaxChain = 40\nmaxA = 1\nmaxB = 41\nfor b in Bs:\n    for a in range(-b + 2, limit):\n        # Make the function\n        f = lambda x: x ** 2 + a * x + b\n        # We know f(0) = b is prime, so start from n = 1.\n        n = 1\n        while isPrime(f(n)):\n            n += 1\n        # Check to see if chain length is bigger...\n        if n &gt; maxChain:\n            maxChain = n\n            maxA = a\n            maxB = b\n\nprint(maxA, maxB, maxChain, maxA * maxB)\n\nThe result is,\n-61 971 71 -59231\n0.337677999981679 seconds.\n\nThus, $f(n) = n^2 - 61n + 971$ produces a chain of 71 consecutive primes from $0\\leq n\\leq 70$. The product we want is -59231.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-06-027-Quadratic-primes/"
    },{
      
      "title": "#28 - Number spiral diagonals",
      "date": "2016-05-06 22:38:00 +0000",
      
      "content": "\n  Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:\n\n  \n21 22 23 24 25\n20  7  8  9 10\n19  6  1  2 11\n18  5  4  3 12\n17 16 15 14 13\n\n\n  It can be verified that the sum of the numbers on the diagonals is 101.\n\n  What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?\n\n\n\nLet’s add another step and make it a 7 by 7 spiral:\n\n\n43 44 45 46 47 48 49\n42 21 22 23 24 25 26\n41 20  7  8  9 10 27\n40 19  6  1  2 11 28\n39 18  5  4  3 12 29\n38 17 16 15 14 13 30\n37 36 35 34 33 32 31\n\n\nNote that the diagonal heading northeast has $1,9,25,49,\\dots$. These are the squares of the odd numbers i.e. $1^2,3^2,5^2,7^2,\\dots$. We can get the other 3 numbers at the other corners by subtracting the side length minus one once, twice, and three times. For example, $25$ is at the corner of the 5 by 5 circle. If we subtract $5-1=4$ from $25$, we get $21$, the number on the northwest diagonal. Subtracting two times and three times gets us $17$ and $13$ respectively.\n\nSo our method is loop through each odd number until 1001, and add that number squared, as well as the other 3 numbers described in the preceding paragraph. We will start from 3, as to not triple count the 1 in the center.\n# file: \"problem028.py\"\nspiralLim = 1001\ns = 0\nfor n in range(3, spiralLim + 1, 2):\n    s += n ** 2\n    # Add the other three numbers:\n    s += n ** 2 - (n - 1)\n    s += n ** 2 - 2 * (n - 1)\n    s += n ** 2 - 3 * (n - 1)\n   \n# Add 1 from center\ns += 1\n\nprint(s)\n\nRunning the above code results in,\n669171001\n0.00024259998463094234 seconds.\n\nTherefore, 669171001 is our final sum.\nBonus\nThis is one of the few problems that can be done by hand, although it’s a little messy. Let the spiral loop we are on by denoted $n$. Recall that for each loop in the spiral, we add $n^2$, and the three numbers that have been subtracted by $n-1$ once, twice, and three times. Therefore, in each loop, the sum is\n\n[\\begin{align}\nS_n &amp;= n^2+n^2-(n-1)+n^2-2(n-1)+n^2-3(n-1)\n\\ &amp;=\n4n^2-6(n-1)\n\\ &amp;=\n4n^2-6n+6\n\\end{align}]\n\nSo, in actuality, instead of the 4 lines we had in the for loop, we could have had one line where add s by this sum. However, there are more steps we could do.\n\nAn odd number $n$ can be written in the form $2k+1$. In our problem, $1\\leq k\\leq 500$. Thus, we can write a summation and evaluate it as follows:\n\n[\\begin{aligned}\nS &amp;= \\sum_{k=1}^{500}S_{2k+1} +1\n\\ &amp;=\n\\sum_{k=1}^{500}\\left( 4(2k+1)^2 - 6(2k+1) + 6 \\right) +1\n\\ &amp;=\n\\sum_{k=1}^{500}\\left( 4\\left( 4k^2+4k+1 \\right) - 12k - 6 + 6 \\right) +1\n\\ &amp;=\n\\sum_{k=1}^{500}\\left( 16k^2+16k+4-12k \\right) +1\n\\ &amp;=\n\\sum_{k=1}^{500}\\left( 16k^2+4k+4 \\right) +1\n\\ &amp;=\n16\\sum_{k=1}^{500}k^2+4\\sum_{k=1}^{500}k+\\sum_{k=1}^{500}4 +1\n\\ &amp;=\n16\\left( \\frac{500(500+1)(2(500)+1)}{6} \\right)+4\\left( \\frac{500(500+1)}{2} \\right)\n\t+ 4(500) +1\n\\ &amp;=\n16(41\\,791\\,750)+4(125\\,250) + 2000 +1\n\\ &amp;=\n\\boxed{669\\,171\\,001}\n\\end{aligned}]\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-06-028-Number-spiral-diagonals/"
    },{
      
      "title": "#29 - Distinct powers",
      "date": "2016-05-06 22:44:00 +0000",
      
      "content": "\n  Consider all integer combinations of $a^b$ for $2\\leq a\\leq 5$ and $2\\leq b\\leq 5$:\n\n\n\n  \n    \n      \n        $a^b$\n        2\n        3\n        4\n        5\n      \n    \n    \n      \n        2\n        4\n        8\n        16\n        32\n      \n      \n        3\n        9\n        27\n        81\n        243\n      \n      \n        4\n        16\n        64\n        256\n        1024\n      \n      \n        5\n        25\n        125\n        625\n        3125\n      \n    \n  \n\n\n\n  If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:\n\n  \n    4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125\n\n\n  How many distinct terms are in the sequence generated by $a^b$ for $2\\leq a\\leq 100$ and $2\\leq b\\leq 100$?\n\n\n\nWe can solve this through brute force directly. The set() structure automatically removes duplicates for us. A simple for loop suffices:\n# file: \"problem029.py\"\ns = set()\n\nfor a in range(2, 101):\n    for b in range(2, 101):\n        s.add(a ** b)\n\nprint(len(s))\n\nRunning the short loop produces an output of,\n9183\n0.02056965463349574 seconds.\n\nTherefore, there are 9183 distinct terms in the sequence.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-06-029-Distinct-powers/"
    },{
      
      "title": "#30 - Digit fifth powers",
      "date": "2016-05-07 09:15:00 +0000",
      
      "content": "\n  Surprisingly there are only three numbers that can be written as the sum of the fourth powers of their digits:\n\n\\[\\begin{aligned}\n1634 &amp;= 1^4 + 6^4 + 3^4 + 4^4\n\\\\\n8208 &amp;= 8^4 + 2^4 + 0^4 + 8^4\n\\\\\n9474 &amp;= 9^4 + 4^4 + 7^4 + 4^4\n\\end{aligned}\\]\n\n  As $1=1^4$ is not a sum it is not included.\n\n  The sum of these numbers is 1634 + 8208 + 9474 = 19316.\n\n  Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.\n\n\n\nWe can do this with a simple for loop. However, we do not yet know the upper bound. Given $k$ digits, the largest number we can have is $k$ 9’s. The sum of fifth powers of this number is therefore $k\\times 9^5$. Notice that if $k=7$, the sum is $7\\times 9^5 = 413\\,343$, a six-digit number. Therefore, it is impossible to have a number that is 7 or more digits long be a sum of fifth powers of its digits. Additionally, if $k=6$, then the sum is $6\\times 9^5 = 354\\,294$. In that case, we don’t need to check numbers bigger than this.\n\nFor calculating the sum of fifth powers, we can convert the number to a string and loop through as seen below.\n# file: \"problem030.py\"\nlimit = 6 * 9 ** 5 + 1\ns = 0\nfor i in range(10, limit):\n    if sum([int(digit) ** 5 for digit in str(i)]) == i:\n        s = s + i\nprint(s)\n\nThe output after running is,\n443839\n1.061222499993164 seconds.\n\nTherefore, 443839 is the sum of all numbers that can be written as the sum of the fifth powers of their digits.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-07-030-Digit-fifth-powers/"
    },{
      
      "title": "#31 - Coin sums",
      "date": "2016-05-07 09:36:00 +0000",
      
      "content": "\n  In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:\n\n  \n1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), £2 (200p) \n\n\n  It is possible to make £2 in the following way:\n\n  \n1x£1 + 1x50p + 2x20p + 1x5p + 1x2p + 3x1p \n\n\n  How many different ways can £2 be made using any number of coins?\n\n\n\nTo solve this, we note that in a certain set of coin values, we can either use a certain coin or not use it.\n\nFor example, with £2 given above, we can use £2 coin or not.\n\n  If we use it, then there is only one way to make the value.\n  If we don’t use it, our next option is to use the £1 coin. At this point, the problem turns into “How many ways can we create £2 - £1 = £1 using the coins?”\n\n\nIn this way, we can recurse down. The base case will be when we have exactly £0 left. A few special cases include when we have a negative amount, or when we have no more coins left to choose.\n# file: \"problem031.py\"\ndef makeChange(value, coins):\n    # Coins will be in decreasing order i.e. largest is first\n    # Can't make change\n    if value &lt; 0:\n        return 0\n    # I can make no change by choosing nothing\n    elif value == 0:\n        return 1\n    # I can't make something out of nothing\n    elif value &gt; 0 and len(coins) == 0:\n        return 0\n    # Recursive call: Have a case where I choose the largest\n    # coin while decrementing value and a case where I skip it\n    # and don't decrement value\n    else:\n        return makeChange(value - coins[0], coins) + makeChange(value, coins[1:len(coins)])\n\nAfter this, we simply make the array of coin values, and call our function.\n# file: \"problem031.py\"\ncoins = [200, 100, 50, 20, 10, 5, 2, 1]\nprint(makeChange(200, coins))\n\nThe result of running is\n73682\n1.9159925933914943 seconds.\n\nThus, there are 73682 ways to make £2 from the coins given.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-07-031-Coin-sums/"
    },{
      
      "title": "#32 - Pandigital products",
      "date": "2016-05-09 16:53:00 +0000",
      
      "content": "\n  We shall say that an $n$-digit number is pandigital if it makes use of all the digits 1 to $n$ exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.\n\n  The product 7254 is unusual, as the identity, $39\\times 186=7254$, containing multiplicand, multiplier, and product is 1 through 9 pandigital.\n\n  Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.\n\n  Some products can be obtained in more than one way so be sure to only include it once in your sum.\n\n\n\nWe can use the itertools.permutations function to loop through all 9-digit arrangements of 1-9. Next, we can place the multiplication and equals signs at valid positions. The former can be placed anywhere between the 1st and 8th digit (to accomodate the equals sign afterwards). We would test all arrangements to see if a valid equation is made.\n\nFor example, in the problem above, we would start from $3\\times 9=1867254$ and end with $3918672\\times 5=4$. However, as we loop through on places to put the equals sign, the product decreases as we move left to right. Eventually it will be less than the “correct” product (what the equation should equal). Then we can stop and move the multiplication sign over one. In the same example, the last product we check is $3\\times 918=67254$, because the next product $3\\times 9186&gt;7254$. In this manner, we skip a good number of possibilities.\n# file: \"problem032.py\"\nproducts = set()\nfor perm in permutations('123456789'):\n    # We place a multiplication and equals\n    # sign at all possible places here.\n    # Once the product goes above the RHS,\n    # we can stop and test putting the\n    # multiplication sign in the next spot.\n    # The multiplication symbol can be placed\n    # after the 1st digit, or before the\n    # second to last digit (because we need equals)\n    for i in range(1, len(perm) - 2):\n        # Now we place an equals sign anywhere\n        # from at least one digit after\n        # the multiplicand to one before the result.\n        # Once the product becomes larger than RHS,\n        # we stop, because the RHS will only get smaller.\n        for j in range(i + 1, len(perm) - 1):\n            mCand = int(''.join(perm[:i]))\n            mPlier = int(''.join(perm[i:j]))\n            product = mCand * mPlier\n            rhs = int(''.join(perm[j:]))\n            if product &gt; rhs:\n                break\n            elif product == rhs:\n                products.add(product)\n\nprint(sum(products))\n\nWe add the products to a set() to avoid duplicates. Running the double for loop gets an output of\n45228\n9.040594220951176 seconds.\n\nTherefore, the sum of all products is 45228. It might be possible to cut the time in half, as multiplication is commutative.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-09-032-Pandigital-products/"
    },{
      
      "title": "#33 - Digit cancelling fractions",
      "date": "2016-05-09 17:17:00 +0000",
      
      "content": "\n  The fraction $\\frac{49}{98}$ is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that $\\frac{49}{98} = \\frac{4}{8}$, which is correct, is obtained by cancelling the 9s.\n\n  We shall consider fractions like, $\\frac{30}{50} = \\frac{3}{5}$, to be trivial examples.\n\n  There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.\n\n  If the product of these four fractions is given in its lowest common terms, find the value of the denominator.\n\n\n\nInstead of a brute force double for loop, we can optimize which fraction pairs we look at. There is no reason to look at a fraction where the numerator and denominator do not share any digits (14/56 for example).\n\nIf $d$ is the digit we want to cancel, then to generate all 2-digit numbers with $d$ in them, we can take all the numbers between $10d+1$ and $10d+9$ (when $d$ is in the tens place), and the numbers $d, 10+d,20+d,\\dots,90+d$ (when $d$ is in the ones place). Afterwards, we remove any numbers that are bigger than the denominator, since that will result in a fraction greater than 1. Below is the function I have defined.\n# file: \"problem033.py\"\ndef getSameDigitNums(initNum, digit):\n    # Get all tens digit numbers,\n    # excluding multiple of 10\n    nums = list(range(digit * 10 + 1, (digit + 1) * 10))\n    # Now append all numbers with ones digit.\n    nums.extend(list(range(digit, 100 + digit, 10)))\n    # Filter out numbers that are less than or equal\n    # to digit and remove the double instance of digit * 11\n    nums = [n for n in nums if n &gt; initNum]\n    if digit * 11 in nums:\n        nums.remove(digit * 11)\n    return nums\n\nNow we just have to loop through all the numerators. Since we want the result in lowest terms, we also need a GCD function.\n# file: \"problem033.py\"\ndef gcd(a, b):\n    #the euclid algorithm\n    while a:\n        a, b = b % a, a\n    return b\n\nnumProd = 1\ndenomProd = 1\n\nfor a in range(11, 100):\n    # Skip if a is a multiple of 10.\n    if a % 10 != 0:\n        for keep, delete in [(0, 1), (1, 0)]:\n            aNew = str(a)[keep]\n            deletedDigit = str(a)[delete]\n            denominators = getSameDigitNums(a, int(deletedDigit))\n            # Now go through each number, remove the digit and see\n            # what happens\n            for b in denominators:\n                b = str(b)\n                # See which digit was cancelled.\n                if b[0] == deletedDigit:\n                    bNew = int(b[1])\n                else:\n                    bNew = int(b[0])\n                # Now see if the old fraction\n                # is the same as the new fraction\n                if a / int(b) == int(aNew) / bNew:\n                    print(a, '/', b)\n                    numProd *= a\n                    denomProd *= int(b)\n# Reduce the multiplied frcation\nGCD = gcd(numProd, denomProd)\nprint('---------')\nprint(numProd // GCD, '/', denomProd // GCD)\n\nRunning the above gets,\n16 / 64\n19 / 95\n26 / 65\n49 / 98\n---------\n1 / 100\n0.0025031140777648326 seconds.\n\nTherefore, the four fractions that follow this property are $\\frac{16}{64},\\frac{19}{95},\\frac{26}{65}$, and $\\frac{49}{98}$. Multiplying these together results in $\\frac{1}{100}$ and so the denominator is 100.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-09-033-Digit-cancelling-fractions/"
    },{
      
      "title": "#34 - Digit factorials",
      "date": "2016-05-09 17:27:00 +0000",
      
      "content": "\n  145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.\n\n  Find the sum of all numbers which are equal to the sum of the factorial of their digits.\n\n  As 1! = 1 and 2! = 2 are not sums they are not included.\n\n\n\nWe need an upper bound for this problem. Suppose our test number $n$ has $k$ digits. The largest $n$ can be is a set of $k$ 9’s, in which the sum of the digits will be $k\\times 9!$. If $k=8$, then the sum is $8\\times 9! = 2\\,903\\,040$, which is only 7 digits. Therefore, $n$ can’t be more than 7 digits. Additionally, since $7\\times 9! = 2\\,540\\,160$, we check until this number.\n# file: \"problem034.py\"\ndef factSum(n):\n    s = 0\n    for d in str(n):\n        s += math.factorial(int(d))\n    return s\n\ns = 0\n\nfor i in range(10, 2540161):\n    if factSum(i) == i:\n        s = s + i\nprint(s)\n\nThe output is,\n40730\n8.536330512194187 seconds.\n\nTherefore, our sum is 40730. We also see that we could have safely ignored all 6 and 7 digit numbers as well.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-09-034-Digit-factorials/"
    },{
      
      "title": "#35 - Circular primes",
      "date": "2016-05-10 11:34:00 +0000",
      
      "content": "\n  The number, 197, is called a circular prime because all rotations of the digits: 197, 971, 719, are themselves prime.\n\n  There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.\n\n  How many circular primes are there below one million?\n\n\n\nWe can convert the integer to a list of digits, and shift the rest of the digits to the left. In Python, this process is extremely simple. Below is the function:\n# file: \"problem035.py\"\ndef circulate(x):\n    x = list(str(x))\n    numOfCircles = len(x) - 1\n    pList = []\n    for _ in range(numOfCircles):\n        # Copy the first digit.\n        firstDigit = x[0]\n        # Set all digits except\n        # the last to the remaining\n        x[:-1] = x[1:]\n        # Set the last digit to the first\n        # digit saved earlier\n        x[-1] = firstDigit\n        # Add to list\n        pList.append(int(''.join(x)))\n    return pList\n\nThis function is all good, but we still need a way to reduce the number of primes we need to check. There are two things we can observe:\n\n  If we find a set of circular primes, each prime’s final digit is each digit of the original prime. Therefore, a candidate circular prime should not contain any even digits. The only even circular prime is 2, we’ll only be checking from 100 onwards.\n  We can also remove the entire set of primes and not doubly check them later.\n\n\n# file: \"problem035.py\"\ndef containsAllOdd(x):\n    return all([int(d) % 2 for d in str(x)])\n\nlimit = 1000000\n# Generate primes between 100 and 1000000\nprimes = primesieve.primes(100, limit)\n# Filter out all primes that have even digits.\nprimes = [p for p in primes if containsAllOdd(p)]\ncount = 13  # 13 primes that follow the property below 100.\nfor prime in primes:\n    # Circulate, and see if each one\n    # is in the list. If they are, then\n    # save all of them and then\n    # delete them, as we don't need to check them again.\n    circlePrimes = circulate(prime)\n    if all([p in primes for p in circlePrimes]):\n        count += len(circlePrimes) + 1 # Plus 1 for current.\n        # Delete.\n        primes.remove(prime)\n        for p in circlePrimes:\n            primes.remove(p)\n\nThe output after running is,\n55\n0.8581394861900083 seconds.\n\nThus, there are 55 circular primes below one million. See below.\n\n\n  2\n  3\n  5\n  7\n  11\n  13, 31\n  17, 71\n  37, 73\n  79, 97\n  113, 131, 311\n  197, 971, 719\n  337, 373, 733\n  919, 199, 991\n  1193, 1931, 9311, 3119\n  3779, 7793, 7937, 9377\n  11939, 19391, 93911, 39119, 91193\n  19937, 99371, 93719, 37199, 71993\n  193939, 939391, 393919, 939193, 391939, 919393\n  199933, 999331, 993319, 933199, 331999, 319993\n\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-10-035-Circular-primes/"
    },{
      
      "title": "#36 - Double-base palindromes",
      "date": "2016-05-10 11:56:00 +0000",
      
      "content": "\n  The decimal number, $585=1001001001_2$ (binary), is palindromic in both bases.\n\n  Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.\n\n  (Please note that the palindromic number, in either base, may not include leading zeros.)\n\n\n\nPython has a convenient built-in function bin() that converts the number to binary. To check if a number is a palindrome, we will reverse and check for equality.\n# file: \"problem036.py\"\ns = 0\nisPalindrome = lambda x: x == x[::-1]\nfor i in range(1, 1000000):\n    if isPalindrome(str(i)) and isPalindrome(bin(i)[2:]):\n        s += i\nprint(s)\n\nThe output of the code is,\n872187\n0.49978133307417255 seconds.\n\nThus, our needed sum is 872187.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-10-036-Double-base-palindromes/"
    },{
      
      "title": "#37 - Truncatable primes",
      "date": "2016-05-10 16:39:00 +0000",
      
      "content": "\n  The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, 3.\n\n  Find the sum of the only eleven primes that are both truncatable from left to right and right to left.\n\n  2, 3, 5, and 7 are not considered to be truncatable primes.\n\n\n\nFor terminology, I’ll call a prime where you can chop off digits from left to right a left truncatable prime. Similarly, being able to chop off digits right to left will be called a right truncatable prime.\n\nOne way to do this is to generate primes which satisfy one of the two properties, and then check to see whether it satisfies the other property. Left truncatable primes are easier to generate, while right truncatable primes are simpler to check for validity.\n\nWhen chopping off digits left to right, the resulting single digit must be prime. The single digit primes are 2, 3, 5, 7, but our prime can’t end in 2, since that makes it even. Therefore, the prime must end in 3, 5, or 7\n\nWe can do a similar analysis for right-truncatable primes. Similar to left-truncatable, the left-most digit needs to be 2, 3, 5 or 7. Additionally, none of the inner digits can be even, since that would make a right-trunctabale prime composite at some point.\n\nTo summarize our candidate prime generation:\n\n  Start with 3, 5, and 7.\n  Each time, add all odd numbers to the left of each number to make a new list.\n  Remove any numbers which aren’t prime from the list. The new list only has numbers which are left truncatable.\n  Test each prime to see if it’s right-truncatable\n  Repeat steps 2 through 4, each time adding digits to the left until all 11 primes are found.\n\n\nFor our prime list, I generate a sufficiently large set of primes that I use to check. Additionally, I’ve made a generator to give me the number each time it’s been right truncated, so we can test these on the fly.\n# file: \"problem037.py\"\ndef rightTrunkNums(x):\n    while x &gt; 10:\n        x //= 10\n        yield x\n\n\nprimes = primesieve.primes(1000000)\n# Keep adding digits to the right\n# of a number which is left to right\n# truncatable. We check these primes\n# to see if they are left to right\n# truncatable. Don't add 4, 6, 8\n# because then it won't be truncatable\n# the other direction\ncount = 0\n# Our starting set are the one digit\n# primes...\nprimeSet = [3, 5, 7]\n# The numbers we can add to the left...\naddingNumbers = [1, 2, 3, 5, 7, 9]\n# While we haven't found all of them.\n# We can deal with pure numbers, because\n# each time, the length of the numbers\n# goes up by one.\ns = 0\ntenPower = 1\nwhile count &lt; 11:\n    # Add all of the possible digits to each\n    # number in our list.\n    primeSet = [[p + digit * (10 ** tenPower) for digit in addingNumbers]\n                    for p in primeSet]\n    # Flatten it.\n    primeSet = [p for digitSet in primeSet for p in digitSet]\n    # Go through, remove each number that isn't prime.\n    primeSet = [p for p in primeSet if p in primes]\n    # We are left with left truncatable primes by definition.\n    # Now go through each prime and check if it's right\n    # truncatable\n    for p in primeSet:\n        for num in rightTrunkNums(p):\n            if num not in primes:\n                break\n        # Check if num is less than 10 and a prime...\n        if num &lt; 10 and num in primes:\n            # We found one...\n            print(p)\n            count += 1\n            s += p\n        # else:\n        #     primeSet.remove(p)\n    # Increase power of ten...\n    tenPower += 1\n\nprint()\nprint(s)\n\nRunning the code mass above, we get,\n23\n53\n73\n37\n313\n373\n317\n797\n3137\n3797\n739397\n\n748317\n0.4748998125831603 seconds.\n\nTherefore, the 11 primes we are looking for are 23, 53, 73, 37, 313, 373, 317, 797, 3137, 3797, and 739397. Their sum is 748317.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-10-037-Truncatable-primes/"
    },{
      
      "title": "#38 - Pandigital multiples",
      "date": "2016-05-16 17:56:00 +0000",
      
      "content": "\n  Take the number 192 and multiply it by each of 1, 2, and 3:\n\n\\[192\\times1=192 \\\\\n192\\times2=384 \\\\\n192\\times3=576\\]\n\n  By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3).\n\n  The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and (1,2,3,4,5).\n\n  What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2,…,$n$) where $n$ &gt; 1?\n\n\n\nWith some trial and error, we can do some optimizations. Firstly, notice that the problem already gave us a large pandigital, 918273645. Therefore, in order for our pandigital to be bigger, it must start with a 9.\n\nHow long is $n$? Suppose that our test number $x$ is a 2-digit number starting with 9. Multiply by 1 and the result is 2-digits long. Multiplying by 2, 3, 4, …, 9, 10, and 11 will get us three digits. However, a 1-9 pandigital is exactly 9 digits long by definition. This means that we are unable to get a concatenated product that is exactly 9 digits long, because the concatenated product of $x$ and (1, 2, 3) will have 8 digits, while including the next number 4 will send us over, with 11 digits.\n\nWith the same analysis assuming $x$ is 3 digits, you can see that $x$ with (1, 2) has 7 digits, but $x$ with (1, 2, 3) has 11 digits, so $x$ can’t have 3 digits either.\n\nHowever, it is possible that $\\mathbf{x}$ is 4 digits. The concatenated product of $x$ with (1, 2) will have excatly 9 digits, so it’s a candidate.\n\nAdditionally, $x$ can’t have more than 4 digits either. If $x$ is $k$ digits long, then $2x$ is at least $k+1$ digits long. Therefore, any $k&gt;4$ will result in a concatenated product exceeding 9 digits.\n\nSo we need a 4 digit number that starts with a 9, which is small enough to brute force. To test if a number is pandigital, we call set(). Since we are looking for the largest, we loop down from 10000.\nfor i in range(10000, 9000, -1):\n    result = int(str(i) + str(2 * i))\n    if set(str(result)) == set('123456789'):\n        print(result)\n        break\n\nRunning this short loop, we get\n932718654\n0.001404046054606883 seconds.\n\nTherefore, the largest 1-9 pandigital concatenated product is 932718654.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-16-038-Pandigital-multiples/"
    },{
      
      "title": "#39 - Integer right triangles",
      "date": "2016-05-17 10:50:00 +0000",
      
      "content": "\n  If $p$ is the perimeter of a right angle triangle with integral length sides, ${a,b,c}$, there are exactly three solutions for $p = 120$.\n\n\\[\\begin{aligned}\n\\{20,48,52\\},\\{24,45,51\\},\\{30,40,50\\}\n\\end{aligned}\\]\n\n  For which value of $p\\leq1000$, is the number of solutions maximised?\n\n\n\nThere are two possible we could go about this: Either we test each $p$ and see which right triangles exist, or we take all right angles with perimeters below 1000 and see which perimeter occurs the most. Personally, I think the latter is the easier way to go, as not every $p$ will have an integer right triangle associated with it.\n\nSo then how do we find all Pythagorean triples with perimeters less than or equal 1000? After some research on methods of generating triples, I came across this Wikipedia page, which details 3 matrices which can be used to find all triples. I have reproduced the matrices below.\n\n[\\begin{aligned}\nA &amp;= \\begin{bmatrix}\n\t1 &amp; -2 &amp; 2 \n\t2 &amp; -1 &amp; 2 \n\t2 &amp; -2 &amp; 3\n\\end{bmatrix} \nB &amp;= \\begin{bmatrix}\n\t1 &amp; 2 &amp; 2 \n\t2 &amp; 1 &amp; 2 \n\t2 &amp; 2 &amp; 3\n\\end{bmatrix} \nC &amp;= \\begin{bmatrix}\n\t-1 &amp; 2 &amp; 2 \n\t-2 &amp; 1 &amp; 2 \n\t-2 &amp; 2 &amp; 3\n\\end{bmatrix}\n\\end{aligned}]\n\nTo generate triples, start with the most basic of them: (3,4,5). Convert this to a vector $\\mathbf{v}=\\langle 3,4,5 \\rangle$. Now multiply this vector by one of the three matrices above on the left i.e. $A\\mathbf{v}$. The result of this is another Pythagorean triple! What’s more, each of the three matrices will always get you 3 distinct triples. For example, $A\\mathbf{v}$ will get you the triple $\\langle 5,12,13 \\rangle$, while $B\\mathbf{v}=\\langle 21,20,29\\rangle$ and $C\\mathbf{v}=\\langle 15,8,17\\rangle$.\n\nThe order also matters during multiplication, as evidenced by the tree structure. For example, multiplying $C$, then $B$, then $A$ gets you $ABC\\mathbf{v}=\\langle 115,252,277\\rangle$.\n\nThis method will only generate primitive Pythagorean triples i.e. $gcd(a,b,c) = 1$ for each triple e.g. $\\langle 10, 24, 26\\rangle$, although a triple, will not be generated.\n\nWe can adapt recursion to this tree structure easily. We recurse down for each matrix, and as soon as we encounter a triple that is larger than our perimeter, we cut the recursion. I’ll also wrap the recursion in a generator, so that we won’t have to store all the triples at once.\n# file: \"problem039.py\"\ndef genPythagoreanTriples(triple, maxP, A, B, C):\n    # Base case...\n    if sum(triple) &gt; maxP:\n        return\n    yield triple\n    # Multiply each matrix\n    for matrix in [A, B, C]:\n        for multTriple in genPythagoreanTriples(np.dot(matrix, triple), maxP, A, B, C):\n            yield multTriple\n\nIn order to test for non-primitive triples, we can keep multiplying our triple until we exceed the perimiter. For $\\langle 3, 4, 5\\rangle$, the maximum multiple will be $\\langle 249, 332, 415\\rangle$ with a perimeter of 996. The np.unique function can be used to gather up unique perimeter values, as well as the number of times we occur.\n# file: \"problem039.py\"\n# Make the matrices\nA = np.array([\n    [1, -2, 2],\n    [2, -1, 2],\n    [2, -2, 3]\n])\nB = np.array([\n    [1, 2, 2],\n    [2, 1, 2],\n    [2, 2, 3]\n])\nC = np.array([\n    [-1, 2, 2],\n    [-2, 1, 2],\n    [-2, 2, 3]\n])\n\nmaxP = 1000\ntrianglePerims = []\nfor triple in genPythagoreanTriples(np.array([3,4,5]), maxP, A, B, C):\n    perimTriple = sum(triple)\n    # Generate all triple multiples that don't exceed maxP\n    # and add it to the list\n    for i in range(1, maxP // perimTriple + 1):\n        trianglePerims.append(i * perimTriple)\n\n# Find the unique solutions\nunique, count = np.unique(trianglePerims, return_counts=True)\n# Find the p with the most solutions\nprint('p =', unique[np.argmax(count)], 'has', np.max(count), 'solutions.')\n\nRunning the code results in an output of,\np = 840 has 8 solutions.\n0.0012768364795974804 seconds.\n\nTherefore, $\\mathbf{p=840}$ is the perimeter with the most solutions (8).\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-17-039-Integer-right-triangles/"
    },{
      
      "title": "#41 - Pandigital prime",
      "date": "2016-05-18 10:26:00 +0000",
      
      "content": "\n  We shall say that an $n$-digit number is pandigital if it makes use of all the digits 1 to $n$ exactly once. For example, 2143 is a 4-digit pandigital and is also prime.\n\n  What is the largest $n$-digit pandigital prime that exists?\n\n\n\nWe need a way to reduce the number of primes we need to check. Let’s do some case-by-case analysis on the size of $n$.\n\nIf $n=9$, then it has 1, 2, …, 9 in the number. The sum of these digits is 45, and recall that if the sum of the digits is 3 or 9, then the original number is divisible by 3 or 9. Thus, $\\mathbf{n\\neq 9}$.\n\nThe same analysis holds for $n=8$, the sum in this case is 36, which means any 8-digit pandigital number is divisible by 9.\n\nThe process breaks for $n=7$, as this sum is 28. However, the pattern holds for both 6-digit (sum = 21) and 5-digit (sum = 15) pandigital numbers, which are all divisible by 3.\n\nTherefore, we will test all 7-digit primes, and hopefully we find a match. If we don’t, then we would test 4-digit numbers on down. We will generate primes between 1000000 and 7654321, and check from the top. The first prime which is pandigital is our answer.\n# file: \"problem041.py\"\nprimes = primesieve.primes(1000000, 7654321)[::-1]\n# Find the first prime (going from largest to smallest)\n# that is pandigital.\nsevenDigitPan = set('1234567')\nfor p in primes:\n    if set(str(p)) == sevenDigitPan:\n        print(p)\n        break\n\nThe result is,\n7652413\n0.048801859630159886 seconds.\n\nTherefore, largest pandigital prime is 7652413.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-18-041-Pandigital-prime/"
    },{
      
      "title": "#40 - Champernowne's constant",
      "date": "2016-05-18 19:49:00 +0000",
      
      "content": "\n  An irrational decimal fraction is created by concatenating the positive integers:\n\n  \n0.123456789101112131415161718192021...\n\n\n  It can be seen that the 12th digit of the fractional part is 1.\n\n  If $d_n$ represents the $n^{\\text{th}}$ digit of the fractional part, find the value of the following expression:\n\n\\[d_1\\times d_{10}\\times d_{100}\\times d_{1000}\\times d_{10000}\\times d_{100000}\\times d_{1000000}\\]\n\n\n\nNothing overly fancy we need to do. Just loop through all the numbers, keeping track of which digit we are at.\n# file: \"problem040.py\"\nnum = 1\nprod = 1\nd = 1\nwhile (d &lt; 1000001):\n    for i in range(len(str(num))):\n        if (d == 1 or d == 10 or\n            d == 100 or d == 1000 or\n            d == 10000 or d == 100000 or\n            d == 1000000):\n            prod = prod * int(str(num)[i:i+1])\n        d = d + 1\n    num = num + 1\nprint(prod)\n\nThe output is,\n210\n0.5373719607973275 seconds.\n\nThus, the product is 210.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-18-040-Champernownes-constant/"
    },{
      
      "title": "#42 - Coded triangle numbers",
      "date": "2016-05-18 20:31:00 +0000",
      
      "content": "\n  The $n^{\\text{th}}$ term of the sequence of triangle numbers is given by, $t_n=\\frac{1}{2}n(n+1)$; so the first ten triangle numbers are:\n\n\\[1,3,6,10,15,21,28,36,45,55,\\dots\\]\n\n  By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is $19+11+25=55=t_{10}$. If the word value is a triangle number then we shall call the word a triangle word.\n\n  Using words.txt (right click and ‘Save Link/Target As…’), a 16K text file containing nearly two-thousand common English words, how many are triangle words?\n\n\n\nLet $w_{word}$ by the word value for $word$. We need to see whether $w_{word}$ is a triangle number. If it is, then by using the quadratic formula,\n\n[\\begin{aligned}\nw_{word} &amp;= \\frac{1}{2}n(n+1) \nn^2+n-2w_{word} = 0 \nn &amp;= \\frac{-1 \\pm \\sqrt{1-4(1)(-2w_{word})}}{2}\n\\ &amp;=\n\\frac{\\sqrt{8w_{word} + 1} - 1}{2}\n\\end{aligned}]\n\nTherefore, for $w_{word}$ to be a triangle number, the last expression has to be an integer, which means $8w_{word}+1$ has to be a square, which will be our simple test.\n\nWe loop over all words, and check if the word value matches the condition. I’ve saved the file words.txt as problem042.txt. The words are in double quotes, so we’ll need to remove them to get the pure words.\n# file: \"problem042.py\"\nwith open(\"problem042.txt\") as f:\n    words = f.readlines()\n# split so it becomes 1D array\nwords = words[0].split(',')\n# Now traverse through the words and remove\n# the double quotes on the ends\nfor i in range(len(words)):\n    words[i] = words[i].replace('\"', '')\n\nletters = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\ncount = 0\nfor i in range(len(words)):\n    num = 0\n    for j in range(len(words[i])):\n        num += letters.index(words[i][j:j+1]) + 1\n    if (8 * num + 1) ** 0.5 == int((8 * num + 1) ** 0.5):\n        count = count + 1\n\nprint(count)\n\nThe output is,\n162\n0.011115430442436482 seconds.\n\nThus, there are 162 triangle words in the file.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-18-042-Coded-triangle-numbers/"
    },{
      
      "title": "#43 - Sub-string divisibility",
      "date": "2016-05-20 10:33:00 +0000",
      
      "content": "\n  The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.\n\n  Let $d_1$ be the 1st digit, $d_2$ be the 2nd digit, and so on. In this way, we note the following:\n\n  \n    $d_2d_3d_4=406$ is divisible by 2\n    $d_3d_4d_5=063$ is divisible by 3\n    $d_4d_5d_6=635$ is divisible by 5\n    $d_5d_6d_7=357$ is divisible by 7\n    $d_6d_7d_8=572$ is divisible by 11\n    $d_7d_8d_9=728$ is divisible by 13\n    $d_8d_9d_{10}=289$ is divisible by 17\n  \n\n  Find the sum of all 0 to 9 pandigital numbers with this property.\n\n\n\nThere are $10!=3\\,628\\,800$ 0 to 9 pandigital numbers. We need to find the quickest way to check each number to see whether it satisfies the conditions. The order in which we check is also important, as some conditions are more restrictive than others.\n\nSince $d_4d_5d_6$ needs to be divisible by 5, that forces $d_6$ to either be 0 or 5. With similar analysis, $d_4$ has to be an even digit.\n\nOnce these conditions are met, we can then check for divisibility. We will check the largest divisibility and then check the smaller ones, since a number being divisible by 17 is less likely than 3.\n\nFor looping through pandigital numbers, we use itertools.permutations.\n# file: \"problem043.py\"\ns = 0\nfor perm in permutations('0123456789'):\n    if perm[0] != '0' and \\\n            (perm[5] == '0' or perm[5] == '5') and \\\n            perm[3] in '02468':\n        perm = ''.join(perm)\n        if int(perm[7:]) % 17 == 0 and \\\n                int(perm[6:9]) % 13 == 0 and \\\n                int(perm[5:8]) % 11 == 0 and \\\n                int(perm[4:7]) % 7 == 0 and \\\n                int(perm[2:5]) % 3 == 0:\n            print(perm)\n            s += int(perm)\n\nprint('-----------')\nprint(s)\n\nThe output of our loop is,\n1406357289\n1430952867\n1460357289\n4106357289\n4130952867\n4160357289\n-----------\n16695334890\n1.2334722367077846 seconds.\n\nWe see that there are only 6 numbers that satisfy the properties, and the sum of them is 16695334890.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-20-043-Sub-string-divisibility/"
    },{
      
      "title": "#44 - Pentagonal numbers",
      "date": "2016-05-20 11:03:00 +0000",
      
      "content": "\n  Pentagonal numbers are generated by the formula, $P_n=\\frac{1}{2}n(3n-1)$. The first ten pentagonal numbers are:\n\n\\[1,5,12,22,35,51,70,92,117,145,\\dots\\]\n\n  It can be seen that $P_4+P_7=22+70=92=P_8$. However, their difference, $70-22=48$, is not pentagonal.\n\n  Find the pair of pentagonal numbers, $P_j$ and $P_k$, for which their sum and difference are pentagonal and $D=\\lvert P_j - P_k\\rvert$.\n\n\n\nJust like #42 - Coded triangle numbers, we need to test if a given number is a pentagonal number. Solving the equation by the quadratic formula, we get,\n\n[n=\\frac{1+\\sqrt{24P_n+1}}{6}]\n\nIf $n$ is an integer for a given input value, then $P_n$ is a valid pentagonal number. This will be the condition that we test. To minimize the difference, $P_j$ and $P_k$ need to be as close as possible to each other.\n\nTherefore, this problem can be solved using two for loops; One to increase $P_k$ and the other to check all pentagonal numbers below $P_k$.\n# file: \"problem044.py\"\ndef isPentagonal(x):\n    n = ((24 * x + 1) ** 0.5 + 1) / 6\n    return int(n) == n\n\nnotFound = True\nk = 2\nwhile notFound:\n    Pk = k * (3 * k - 1) // 2\n    for j in range(k - 1, 0, -1):\n        Pj = j * (3 * j - 1) // 2\n        if isPentagonal(Pk + Pj) and isPentagonal(Pk - Pj):\n            print(Pk - Pj)\n            notFound = False\n            break\n    k += 1\n\nThe output is,\n5482660\n2.5649144140300306 seconds.\n\nThus, $D=\\mathbf{5482660}$.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-20-044-Pentagonal-numbers/"
    },{
      
      "title": "#45 - Triangular, pentagonal, and hexagonal",
      "date": "2016-05-21 11:41:00 +0000",
      
      "content": "\n  Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:\n\n  \n    \n      \n        Type\n        Formula\n        First terms\n      \n    \n    \n      \n        Triangle\n        $T_n=\\frac{1}{2}n(n+1)$\n        1, 3, 6, 10, 15, …\n      \n      \n        Pentagonal\n        $P_n=\\frac{1}{2}n(3n-1)$\n        1, 5, 12, 22, 35, …\n      \n      \n        Hexagonal\n        $H_n=n(2n-1)$\n        1, 6, 15, 28, 45, …\n      \n    \n  \n\n  It can be verified that $T_{285}=P_{165}=H_{143}=40755$.\n\n  Find the next triangle number that is also pentagonal and hexagonal.\n\n\n\nJust like how hexagons are composed of triangles, hexagonal numbers are themselves triangle numbers:\n\n\\(H_n=n(2n-1)=\\frac{1}{2}(2n)(2n-1)=\\frac{1}{2}(2n-1)((2n-1)+1)=T_{2n-1}\\)\nOne equality pair is already done, so now we only have to find the next hexagonal number which is also a pentagonal number. Using the same function as #44 - Pentagonal numbers, we can set up a single loop starting from $H_{143}$ going on up.\n# file: \"problem045.py\"\nn = 144  # H_143 is pentagonal\nhexNum = n * (2 * n - 1)\nwhile not isPentagonal(hexNum):\n    n += 1\n    hexNum = n * (2 * n - 1)\n\nprint(n, hexNum)\n\nRunning this quick loop results in,\n27693 1533776805\n0.03727003511300319 seconds.\n\nTherefore, $H_{27693} = \\mathbf{1533776805}$ is the next number which is triangular, pentagonal, and hexagonal.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-05-21-045-Triangular-pentagonal-hexagonal/"
    },{
      
      "title": "#53 - Combinatoric selections",
      "date": "2016-06-17 14:11:00 +0000",
      
      "content": "\n  There are exactly ten ways of selecting three from five, 12345:\n\n\\[123,\\,\\,124,\\,\\,125,\\,\\,134,\\,\\,135,\\,\\,145,\\,\\,234,\\,\\,235,\\,\\,245,\\,\\,\\text{and }345\\]\n\n  In combinatorics, we use the notation $_5 C_3=10$.\n\n  In general $_nC_r=\\frac{n!}{r!(n-r)!}$, where $r\\leq n, n!=n\\times(n-1)\\times\\dots\\times 3\\times 2\\times 1$, and $0!=1$.\n\n  How many, not necessarily distinct, values of $_nC_r$ for $1\\leq n\\leq 100$, are greater than one-million?\n\n\n\nNotice that the formula for $_nC_r$ has three factorials. Recomputing each of these factorials each time will be time-consuming and inefficient. Instead, we can find $n!$ for all $0\\leq n\\leq 100$, and grab the values we need for each computation. Python’s math package has a quick factorial function we can use:\n\n# file: \"problem053.py\"\nfactorials = [math.factorial(i) for i in range(0, 101)]\ncount = 0\nfor n in range(23, 101):\n    for r in range(n + 1):\n        if factorials[n] / (factorials[r] * factorials[n - r]) &gt; 1000000:\n            count += 1\nprint(count)\n\n\nRunning this short loop results in,\n\n4075\n0.0038949089640585117 seconds.\n\nThus, there are 4075 values that are greater than one million.\nBonus\nWe can actually solve this problem without computing a single factorial! We can use Pascal’s triangle to find $_nC_r$, as the rows of the triangle are the values of $_nC_r$. Pascal’s triangle is constructed in the following manner:\n\n\n  The first row is $1$.\n  The second row is $1\\quad 1$.\n  Each row after the second is formed by placing two ones at the ends, while the middle values are calculated by adding the two numbers above. For example, the first 5 rows are shown below.\n\n\n\n1\n1 1\n1 2 1\n1 3 3 1\n1 4 6 4 1\n\n\nIf the rows are numbered starting from 0, and the elements in the row are also numbered starting from 0, the $r^\\text{th}$ number in the $n^\\text{th}$ row is exactly $_nC_r$. Using the generative nature of Pascal’s triangle, we can continuously generate each row until the 100th row, and count the numbers which are greater than one-million.\n\ncurrRow = [1, 1]\ncount = 0\nfor n in range(2, 101):\n    nextRow = [0] * (n + 1)\n    nextRow[0] = 1\n    nextRow[-1] = 1\n    # Make the next row\n    for i in range(len(currRow) - 1):\n        nextRow[i+1] = currRow[i] + currRow[i+1]\n    # Count how many are bigger than 1 million\n    count += len([x for x in nextRow if x &gt; 1000000])\n    currRow = nextRow\nprint(count)\n\n\nWe have to start from the beginning in order to see what the 23rd row is. Regardless, the output of is the same, although slightly faster.\n\n4075\n0.0015237512804923096 seconds.\n\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2016-06-17-053-Combinatoric-selections/"
    },{
      
      "title": "#46 - Goldbach's other conjecture",
      "date": "2017-01-31 19:47:00 +0000",
      
      "content": "\n  It was proposed by Christian Goldbach that every odd composite number that can be written as the sum of a prime and twice a square.\n\n\\[\\begin{aligned}\n9 &amp;= 7 + 2\\times 1^2\n\\\\\n15 &amp;= 7 + 2\\times 2^2\n\\\\\n21 &amp;= 3 + 2\\times 3^2\n\\\\\n25 &amp;= 7 + 2\\times 3^2\n\\\\\n27 &amp;= 19 + 2\\times 2^2\n\\\\\n33 &amp;= 31 + 2\\times 1^2\n\\end{aligned}\\]\n\n  It turns out that the conjecture was false.\n\n  What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?\n\n\n\nA simple double for loop will work. Unlike before, we actually build the prime list as we go, to minimize running time. Given our starting number, we keep subtracting twice squares from it until it results in a prime. Then, we move to the next number. I use generator iterables in the code to simplify things.\n# file: \"problem046.py\"\nn = 5\nprimes = []\n\nwhile True:\n    # Check if the number is prime\n    if all(n % p for p in primes):\n        primes.append(n)\n    # Check if twice a square being subtracted\n    # from this number results in a prime.\n    else:\n        if not any((n - 2 * k * k) in primes for k in range(1, int((n / 2) ** 0.5) + 1)):\n            break\n    n += 2\n\nprint(n)\n\nRunning the program results in an output of,\n5777\n0.08932956603362126 seconds.\n\nTherefore, 5777 is the first odd composite number that can’t be written as the sum of a prime and twice a square.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-01-31-046-Goldbachs-other-conjecture/"
    },{
      
      "title": "#47 - Distinct prime factors",
      "date": "2017-01-31 20:00:00 +0000",
      
      "content": "\n  The first two consecutive numbers to have two distinct prime factors are:\n\n\\[\\begin{aligned}\n14 &amp;= 2\\times 7\n\\\\\n15 &amp;= 3\\times 5\n\\end{aligned}\\]\n\n  The first three consecutive numbers to have three distinct prime factors are:\n\n\\[\\begin{aligned}\n644 &amp;= 2^2\\times 7\\times 23\n\\\\\n645 &amp;= 3\\times 5\\times 43\n\\\\\n646 &amp;= 2\\times 17\\times 19\n\\end{aligned}\\]\n\n  Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers?\n\n\n\nWe can write a function to quickly compute distinct prime factors, by completely dividing out a factor before moving to the next one.\n\nWe can also do some optimizations on the search. For example, let’s say a candidate set $n$, $n+1$, $n+2$, and $n+3$, has 4, 4, 4, and 3 prime factors respectively. This $n$ is clearly not a candidate. However, we don’t need to check again starting from $n+1$, since we know $n+3$ has only 3 factors. The next number we check is $n+4$. In this way, we can skip a lot of numbers.\n# file: \"problem047.py\"\n# Start from 647...\nprimes = primesieve.primes(500000)\nn = 647\nwhile True:\n    # Calculate starting from this number\n    # the number of distinct prime factors.\n    count = 0\n    while len(set(distinctPrimeFacts(n, primes))) == 4:\n        count += 1\n        n += 1\n    if count == 4:\n        for i in range(n - 4, n):\n            print(i, '==&gt;', distinctPrimeFacts(i, primes))\n        break\n    n += 1\n\nThe output is,\n134043 ==&gt; [3, 7, 13, 491]\n134044 ==&gt; [2, 2, 23, 31, 47]\n134045 ==&gt; [5, 17, 19, 83]\n134046 ==&gt; [2, 3, 3, 11, 677]\n1.6933869983913123 seconds.\n\nTherefore, the set of 4 integers we are looking for are,\n\n\\(\\begin{aligned}\n134043 &amp;= 3\\times 7\\times 13\\times 491\n\\\\\n134044 &amp;= 2^2\\times 23\\times 31\\times 47\n\\\\\n134045 &amp;= 5\\times 17\\times 19\\times 83\n\\\\\n134046 &amp;= 2\\times 3^2\\times 11\\times 677\n\\end{aligned}\\)\nand our starting integer is 134043.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-01-31-047-Distinct-prime-factors/"
    },{
      
      "title": "#48 - Self-powers",
      "date": "2017-02-02 09:10:00 +0000",
      
      "content": "\n  The series, $1^1+2^2+3^3+\\dots+10^{10}=10405071317$.\n\n  Find the last ten digits of the series, $1^1+2^2+3^3+\\dots+1000^{1000}$.\n\n\n\nAll we need is a brute force loop. We then take modulus $10^{10}$ to get the last ten digits.\n# file: \"problem048.py\"\nnums = list(range(1, 1001))\nprint(sum(nums ** nums) % 10 ** 10)\n\nRunning this short program results in,\n9110846700\n0.010996122083266172 seconds.\n\nTherefore, the last ten digits is 9110846700.\nBonus\nIf you have Python, then solving this problem is trivial. However, most other languages have a cap on the size of integers that can be dealt with.  Is there a way to quickly calculate this sum without needing to store a large number such as $1000^{1000}$?\n\nFirst, notice that we took a modulus to get the last ten digits. Modulus is distributive among addition, so that means\n\n\\((a + b)\\mod c\\equiv (a\\mod c + b\\mod c)\\mod c\\)\nand we can reduce the size of the numbers we are adding. The modulus also allows us to quickly calculate the large raw values needed for the sum.\n\nJust like with addition, modulus is also distributive with multiplication:\n\n\\((a\\times b)\\mod c \\equiv ((a\\mod c)\\times(b\\mod c))\\mod c\\)\nPerforming this repeatedly allows us to calculate $a^k\\mod c$ where $k$ is a power of two. For example, $3^{16}\\mod 15$:\n\n\\(\\begin{aligned}\n3^2\\equiv 9\\mod 15\n\\\\\n3^4 = (3^2)^2\\equiv ((3^2\\mod 15)\\times(3^2\\mod 15))\\mod 15\\equiv(9\\times9)\\mod 15\\equiv5\\mod15\n\\\\\n3^8=(3^4)^2\\equiv((3^4\\mod 15)\\times(3^4\\mod 15))\\mod 15\\equiv (5\\times5)\\mod 15\\equiv10\\mod15\n\\\\\n3^{16}\\equiv((3^8\\mod15)\\times(3^8\\mod15))\\mod15\\equiv(10\\times10)\\mod 15\\equiv10\\mod 15\n\\end{aligned}\\)\nHow would we do this for all $k$ though? We can use the binary expansion, as that tells which powers of 2 are used to make the number. For example, let’s do $4^{49}\\mod 11$. First convert $49$ to binary. This is $110001_2=2^5+2^4+2^0$. So this means we are trying to find $4^{2^5+2^4+2^0}\\mod 11 = \\left(4^{2^5}\\times4^{2^4}\\times4^{2^0}\\right)\\mod 11$. In that case, we can use the same method and find the appropriate powers of two:\n\n\\(\\begin{aligned}\n4\\equiv 4\\mod 11\n\\\\\n4^2\\equiv (4\\times4)\\mod 11 \\equiv16\\mod11\\equiv 5\\mod 11\n\\\\\n4^4\\equiv (4^2\\times4^2)\\mod 11\\equiv 25\\mod 11\\equiv 3\\mod 11\n\\\\\n4^8\\equiv (4^4\\times4^4)\\mod 11\\equiv9\\mod 11\\equiv 9\\mod 11\n\\\\\n4^{16}\\equiv (4^8\\times 4^8)\\mod 11\\equiv 81\\mod 11\\equiv 4\\mod 11\n\\\\\n4^{32}\\equiv (4^{16}\\times 4^{16})\\mod 11\\equiv 16\\mod 11\\equiv 5\\mod 11\n\\end{aligned}\\)\nNow we pick the powers of 2 we need, plug them in, and calculate:\n\n\\(\\left(4^{2^5}\\times4^{2^4}\\times4^{2^0}\\right)\\mod 11\\equiv(5\\times4\\times4)\\mod11\\equiv80\\mod 11\\equiv\\boxed{3\\mod 11}\\)\nAnd that’s it! Thun number of times we multiply within the parethesis is proportional to the log base 2 of the power, since we are writing in binary.\n\nIn terms of code, we first generate all mods of powers of 2, and then we multiply the appropriate results using the binary representation.\n# file: \"problem048.py\"\ndef largeMod(a, b, c):\n    # Calculate mod c for all power of 2 &lt;= b.\n    # Index is the power. so the array looks\n    # like [a^(2^0) mod c, a^(2^1) mod c, ...]\n    largestPower = int(math.log2(b))\n    # First element is a^(2^0) = a^1 = a\n    modsOfTwo = [a % c]\n    for _ in range(largestPower):\n        modsOfTwo.append(modsOfTwo[-1] ** 2 % c)\n    # Convert the exponent to binary\n    # to see which mods to use...\n    bbinary = bin(b)[2:][::-1]\n    prod = 1\n    for i, bit in enumerate(bbinary, 0):\n        if bit == '1':\n            prod *= modsOfTwo[i]\n    return prod % c\n\nNow solving the problem is just a simple loop.\n# file: \"problem048.py\"\nlimit = 1000\ns = 0\nfor i in range(1, limit + 1):\n    s += largeMod(i, i, 10 ** 10)\n\nprint(s % 10 ** 10)\n\nRunning the code results in,\n9110846700\n0.008301412421343397 seconds.\n\nWe get the same answer, and slightly faster at that. The function to calculate a large power modulus will be extremely useful, so let’s bookmark this for the future.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-02-02-048-Self-powers/"
    },{
      
      "title": "#49 - Prime permutations",
      "date": "2017-02-02 09:53:00 +0000",
      
      "content": "\n  The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways: (i) each of the three terms are prime, and, (ii) each of the 4-digit numbers of are permutations of one another.\n\n  There are no arithmetic sequences made up 1-, 2-, or 3-digit primes, exhibiting this property, but there is one other 4-digit increasing sequence.\n\n  What 12-digit number do you form by concatenating the three terms in this sequence?\n\n\n\nWe can use a double for loop instead of a triple for loop. For each pair of primes, we check if they are permutations of each other, by converting them to sorted strings and checking for equality.\n# file: \"problem049.py\"\nnumbers = {}\nprimes = primesieve.primes(10 ** 3, 10 ** 4)\nfor i in range(len(primes)):\n    for j in range(i + 1, len(primes)):\n        prime1 = primes[i]\n        prime2 = primes[j]\n        # check if a permutation\n        if sorted(str(prime1)) == sorted(str(prime2)):\n            diff = prime2 - prime1\n            prime3 = prime2 + diff\n            if sorted(str(prime2)) == sorted(str(prime3)) and prime3 in primes:\n                print(prime1, prime2, prime3)\n\nRunning gives us the triplets we need:\n1487 4817 8147\n2969 6299 9629\n0.9628449275774557 seconds.\n\nConcatenating the triplet that’s not in the problem is 296962999629.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-02-02-049-Prime-permutations/"
    },{
      
      "title": "#107 - Minimal network",
      "date": "2017-06-05 10:20:00 +0000",
      
      "content": "\n  The following undirected network consists of seven vertices and twelve edges with a total weight of 243.\n\n  \n\n  The same network can be represented by the matrix below.\n\n  \n    \n      \n         \n        A\n        B\n        C\n        D\n        E\n        F\n        G\n      \n    \n    \n      \n        A\n        -\n        16\n        12\n        21\n        -\n        -\n        -\n      \n      \n        B\n        16\n        -\n        -\n        17\n        20\n        -\n        -\n      \n      \n        C\n        12\n        -\n        -\n        28\n        -\n        31\n        -\n      \n      \n        D\n        21\n        17\n        28\n        -\n        18\n        19\n        23\n      \n      \n        E\n        -\n        20\n        -\n        18\n        -\n        -\n        11\n      \n      \n        F\n        -\n        -\n        31\n        19\n        -\n        -\n        27\n      \n      \n        G\n        -\n        -\n        -\n        23\n        11\n        27\n        -\n      \n    \n  \n\n  However, it is possible to optimise the network by network by removing some edges and still ensure that all points on the network remain connected. The network which achieves the maximum saving is shown below. It has a weight of 93, representing a saving of 243 - 93 = 150 from the original network.\n\n  \n\n  Using network.txt (right click and ‘Save Link/Target As…’), a 6K text file containing a network with forty vertices, and given in matrix form, find the maximum saving which can be achieved by removing redundant edges whilst ensuring that the network remains connected.\n\n\n\nThe meaning of “connected” is exactly as it sounds like: We don’t have a vertex that’s floating off in space. More specifically, starting from any vertex in the graph, a path exists from it to every other vertex.\n\nSince we want the minimum weight, then that means at each step, find the edge with the largest weight that we can remove such that the graph still remains connected.\n\nWhat is our stopping condition? We stop when the graph will become disconnected no matter which edge we remove.\n\nNext, how do we test for connectedness given the adjacency matrix? One way is raise to the matrix to a power $k\\leq n$ where $n$ is the number of nodes and check for nonzero elements, but that is an expensive operation. Instead, we can run a search through the graph, and if the search results in all the nodes being visited, we have a connected graph.\n\nWe will utilize breadth-first-search, which is an iterative search and works very well with an adjacency matrix.\n\n  We start at a node $x$, and then at each loop, we retrieve $x$’s neighbors, and filter them out based on which nodes we haven’t visited yet.\n  Then, the next loop will retrieve $x$’s neighbors’ neighbors, and its neighbors, and so on.\n  We iterate until there are no new neighbors we can visit. At this point, we look at the set of nodes we haven’t visited.\n  If this set is not empty then there are a set of nodes which are unreachable from the node we started at, which means the graph is not connected.\n  If the set is empty, then all nodes were able to be visited from the start node, and so the graph is connected.\n\n\nWe are set to write our function. The file that is provided to us contains dashes (“-“) to represent non-existant edges, and I replace these with 0 in the code. Assuming missing edges are 0, then the is_connected() function is straightforward.\n\nBelow is the function to see if the graph is connected or not. I assume that the nodes are 0, 1, 2, …, $n$, and we start at node 0. I also use set() objects for quick look up and easy subtraction.\n# file: \"problem107.py\"\ndef is_connected(graph):\n    # Does a BFS on the graph. Start at index 0\n    nodes = len(graph)\n    start_node = 0\n    new_neighbors = set(i for i in range(nodes) if graph[start_node][i] != 0)\n    unvisited = set(range(nodes)) - new_neighbors\n    # While we are still finding new neighbors, keep getting the next new neighbors\n    # and updating the unvisited set.\n    while len(new_neighbors) &gt; 0:\n        # Only save the neighbors that we haven't visited yet.\n        new_neighbors = set(i for node in new_neighbors for i in range(nodes) if (graph[node][i] != 0) and i in unvisited)\n        # Update unvisited set\n        unvisited -= new_neighbors\n    # We keep looping as long as we encounter new neighbors, if\n    # we don't encounter any, but we still have nodes in the unvisited set,\n    # then the graph is disjoint.\n    if len(unvisited) &gt; 0:\n        return False\n    return True\n\nNow we just retrieve the set of all edges, sorted from largest to smallest weight, and attempt removal of each one. Arrays are copied by reference during equality, so I utilize copy.deepcopy() which creates a full new matrix object. Removal of the edge constitutes setting that edge’s weight to 0 (it’s in two places in the matrix, since the graph is undirected).\n# file: \"problem107.py\"\nimport copy\n\nwith open('./p107_network.txt', 'r') as f:\n    graph = [line.split(',') for line in f.read().splitlines()]\n    # Convert the numbers to integers, and convert hyphens to 0\n    graph = [[int(weight) if weight != '-' else 0 for weight in node_adj_list]for node_adj_list in graph]\n\n# We need a sorted list of edges from largest to smallest,\n# as well as their locations. An adjacency matrix is symmetric,\n# so make sure not to add edges twice.\nedge_locs = [(i, j, graph[i][j]) for i in range(len(graph)) for j in range(i) if graph[i][j] != 0]\nedge_locs = sorted(edge_locs, key=lambda x: -x[2])\n# Save the current total weight\norig_weight = sum(weight for _, _, weight in edge_locs)\n\nidx = 0\nwhile idx &lt; len(edge_locs):\n    i, j, weight = edge_locs[idx]\n    # Check if the graph is connected if this edge is removed,\n    # so copy the graph.\n    graph_copy = copy.deepcopy(graph)\n    graph_copy[i][j] = 0\n    graph_copy[j][i] = 0  # Symmetric!\n    if is_connected(graph_copy):\n        graph = graph_copy\n        # Delete the edge\n        del edge_locs[idx]\n    else:\n        idx += 1\n# Calculate total weight and subtract from original\ntotal_weight = sum(weight for _, _, weight in edge_locs)\nprint(orig_weight - total_weight)\n\nRunning our loop, we get\n259679\n0.31301869999151677 seconds.\n\nwhich means our total graph savings is 259679.\n",
      "categories": ["project_euler"],
      "tags": ["35_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-05-107-Minimal-network/"
    },{
      
      "title": "#50 - Consecutive prime sum",
      "date": "2017-06-17 11:43:00 +0000",
      
      "content": "\n  The prime 41, can be written as the sum of six consecutive primes:\n\n\\[41=2+3+5+7+11+13\\]\n\n  This is the longest sum of consecutive primes that adds to a prime below one-hundred.\n\n  The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.\n\n  Which prime, below one-million, can be written as the sum of the most consecutive primes?\n\n\n\nNote that we are looking for the longest sum, not the largest sum. Therefore, since we can generate a list of primes, we will start at 2, and keep adding terms consecutively. If we reach a prime, then we update the length of the sum. We keep going until our sum exceeds 1 million. Once we’re done starting our sum from 2, we then move to starting the sum with 3. However, since we have saved the longest sum length so far, we have to add that many terms i.e. If the longest sum starting with 2 is 200 digits long, then we start checking sums starting from 3 from 201 digits onward. Like this, we check through all the primes.\n\n# file: \"problem050.py\"\nprimes = primesieve.primes(1000000)\n# Start from 2, and keeping adding on up until\n# sum exceeds 1 million.\n# If we come across a prime, then update the\n# chain length. Once 2s are done, move on to 3,\n# but now start from the longest chain length.\nchainLength = 1\nmaxPrime = 2\ni = 0\nj = i + chainLength + 1\nwhile j &lt; len(primes):\n    j = i + chainLength + 1\n    s = sum(primes[i:j])\n    while s &lt; 1000000:\n        if s in primes:\n            chainLength = j - i\n            maxPrime = s\n        j += 1\n        s += primes[j - 1]\n    i += 1\n\nprint(maxPrime, 'with', chainLength, 'consecutive primes.')\n\n\nRunning the above results in an output of,\n\n997651 with 543 consecutive primes.\n1.3174206796941914 seconds.\n\n\nTherefore, the longest sum has 543 terms and evaluates to 997561.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-17-050-Consecutive-prime-sum/"
    },{
      
      "title": "#92 - Square digit chains",
      "date": "2017-06-18 10:18:00 +0000",
      
      "content": "\n  A number chain is created by continuously adding the square of the digits in a number to form a new number until it has been seen before.\n\n  For example,\n\n\\[44\\rightarrow 32\\rightarrow 13\\rightarrow \n10\\rightarrow\\mathbf{1}\\rightarrow\\mathbf{1}\n\\\\\n85\\rightarrow\\mathbf{89}\\rightarrow145\\rightarrow 42\\rightarrow20\n\\rightarrow4\\rightarrow16\\rightarrow37\\rightarrow58\\rightarrow\\mathbf{89}\\]\n\n  Therefore any chain that arrives at 1 or 89 will become stuck in an endless loop. What is most amazing is that EVERY starting number will eventually arrive at 1 or 89.\n\n  How many starting numbers below ten million will arrive at 89?\n\n\n\nOne important observation is that the ordering of the digits do not matter. For example, the numbers 5332, 5323, 5233, 3532, 3352, 3325, 3235, 3253, 3523, 2335, 2353, and 2533 all compute to a digit squared sum of $25+9+9+4=\\mathbf{47}$. We can take advantage of this fact to avoid visiting each number and calculating its chain.\n\nOur search space will eventually consist of numbers of the form $abcd$, where $a\\geq b\\geq c\\geq d$. The number 5332 from above would be part of this set, but none of its permutations, so this sum will only be calculated once.\n\nBut remember 5332 had 11 other permutations, which all end at 89 and need to be accounted for. So, for each number in our set, we have to calculate the number of distinct permutations it has. On its own, it is not too complicated to calculate, but we have to watch out for is repeated digits.\n\nIf all our digits are different, then there are exactly $4! = 24$ ways of ordering them. However, there are only 12 permutations of 5332, because there are 2 3s. We have to divide by the number of ways these two 3s can be arranged, which is just 2, and so $24/2 = 12$. In general, if $n_d$ is the number of times the digit $x$ appears in the number, then the number of permutations of our 4-digit number is\n\n\\(Perm(abcd) = \\frac{24}{c_0!c_1!\\dots c_9!} = \n\t\\frac{24}{\\prod_{d=0}^9 c_d!}\\)\nWhat about leading 0s? If our original number was 8400, then the above formula also counts “numbers” such as 0480 and 0084. But this actually works in our favor because we are counting numbers with less than 4 digits! So no external correction is needed here.\n\nTo generate the number set, I use yield and create a generator. This way, the entire list isn’t stored in memory. The looping algorithm is a recursive one, which keeps track of the remaining length of the number. The base case is if the length is 0, in which case we return the number. Otherwise, we append each possible digit, recurse with each of them, and decrement the length by 1. I do not include 0 with the initial loop, since we can’t have leading zeros.\n\nThe function is to calculate the sum of square digits is using integer division 10 to get each digit, as opposed to converting to a string, which saves some time. We also hav a separate function to count the number of permutations.\n# file: \"problem092.py\"\ndef sumOfSquareOfDigits(num):\n    s = 0\n    while num != 0:\n        s += (num % 10) ** 2\n        num = num // 10\n    return s\n\n\ndef loopNumbers(length, currNum=None):\n    if length == 0:\n        yield currNum\n        return\n    # Top level\n    if currNum is None:\n        # Don't start with a 0\n        for n in range(1, 10):\n            for number in loopNumbers(length - 1, n):\n                yield number\n    # Any other level...\n    else:\n        for n in range(currNum % 10 + 1):  # &lt;-- Zero allowed\n            for number in loopNumbers(length - 1, currNum * 10 + n):\n                yield number\n\ndef countPermutations(n):\n    nstr = str(n)\n    digits = '0123456789'\n    return math.factorial(len(nstr)) // \\\n        np.prod([math.factorial(nstr.count(digit)) for digit in digits])\n\n\nis89 = []\nis1 = []\ntotal89 = 0\nfor number in loopNumbers(7):\n    count = countPermutations(number)\n    i = number\n    startingSquare = sumOfSquareOfDigits(i)\n    # Check to see if it's in the 89 list...\n    if startingSquare in is89:\n        total89 += count\n    elif startingSquare in is1:\n        continue\n    else:\n        while i != 89 and i != 1:\n            i = sumOfSquareOfDigits(i)\n        if i == 89:\n            is89.append(startingSquare)\n            total89 += count\n        else:\n            is1.append(startingSquare)\nprint(total89)\n\nRunning our code gets an output of,\n8581146\n0.2859901000000001 seconds.\n\nThus, we have 8581146 numbers below 10 million that end in 89.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-18-092-Square-digit-chains/"
    },{
      
      "title": "#54 - Poker hands",
      "date": "2017-06-18 15:18:00 +0000",
      
      "content": "\n  In the card game poker, a hand consists of five cards and are ranked, from lowest to highest, in the following way:\n\n  \n    High Card: Highest value card.\n    One Pair: Two cards of the same value.\n    Two Pairs: Two different pairs.\n    Three of a Kind: Three cards of the same value.\n    Straight: All cards are consecutive values.\n    Flush: All cards of the same suit.\n    Full House: Three of a kind and a pair.\n    Four of a Kind: Four cards of the same value.\n    Straight Flush: All cards are consecutive values of the same suit.\n    Royal Flush: Ten, Jack, Queen, King, Ace, in same suit.\n  \n\n  The cards are valued in the order: 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace.\n\n  If two players have the same ranked hands then the rank made up of the highest value wins; for example, a pair of eights beats a pair of fives (see example 1 below). But if two ranks tie, for example, both players have a pair of queens, then highest cards in each hand are compared (see example 4 below); if the highest cards tie then the next highest cards are compared, and so on.\n\n  Consider the following 5 hands dealt to two players:\n\n  \n    \n      \n        Hand\n        Player 1\n        Player 2\n        Winner\n      \n    \n    \n      \n        1\n        5H 5C 6S 7S KDPair of Fives\n        2C 3S 8S 8D TDPair of Eights\n        Player 2\n      \n      \n        2\n        5D 8C 9S JS ACHighest card Ace\n        2C 5C 7D 8S QHHighest card Queen\n        Player 1\n      \n      \n        3\n        2D 9C AS AH ACThree Aces\n        3D 6D 7D TD QDFlush with Diamonds\n        Player 2\n      \n      \n        4\n        4D 6S 9H QH QCPair of QueensHighest card Nine\n        3D 6D 7H QD QSPair of QueensHighest card Seven\n        Player 1\n      \n      \n        5\n        2H 2D 4C 4D 4SFull House with Three Fours\n        3C 3D 3S 9S 9DFull House with Three Threes\n        Player 1\n      \n    \n  \n\n  The file, poker.txt, contains one-thousand random hands dealt to two players. Each line of the file contains ten cards (separated by a single space): the first five are Player 1’s cards and the last five are Player 2’s cards, You can assume that all hands are valid (no invalid characters or repeated cards), each player’s hands are in no specific order, and in each hand there is a clear winner.\n\n  How many hands does Player 1 win?\n\n\n\nWe simply need to convert the rules of poker into code. The hand order we check in is important, as we need to check the most restrictive down to the most relaxed hand. The code mostly consists of parsing the file, and then sorting each player’s hand based on card value. Then we grab the counts of each card, which allows to check the hands for four of a kind, full house, etc.\n\nWe also need to keep track of the highest card in each ranking for each player, in case the hand ties in rank. If these cards are still tied, then we need to keep removing the highest ranked card until one player wins.\n# file: \"problem054.py\"\n# Returns the ranking of the hand and the\n# highest card in that ranking\ndef pokerRanking(hand):\n    order = '23456789TJQKA'\n    # First split the hand into a paired list of sorts\n    #hand = list(zip(*[tuple(card) for card in hand]))\n    numbers = [card[0] for card in hand]\n    suits = [card[1] for card in hand]\n    # Go down the list\n    # Royal Flush - T, J, Q, K, A all same suit\n    if all(card in numbers for card in 'TJQKA') and all(suits[0] == s for s in suits):\n        return 'A', 'RF'\n    # Straight Flush - consecutive values\n    sortedNums = sorted(numbers, key=lambda x: order.index(x))\n    if (all(suits[0] == s for s in suits) and\n            all(order.index(sortedNums[i+1]) - order.index(sortedNums[i]) == 1 for i in range(4))):\n        return sortedNums[-1], 'SF'\n    # Four of a kind - only need to look at values\n    unique, counts = np.unique(numbers, return_counts=True)\n    # Sort unique\n    unique = unique[np.argsort(counts)[::-1]]\n    counts = np.sort(counts)[::-1]\n    if counts[0] == 4:\n        return unique[0], 'FK'\n    # Full House\n    if counts[0] == 3 and counts[1] == 2:\n        return unique[0], 'FH'\n    # Flush - all same suit\n    if all(suits[0] == s for s in suits):\n        return max(numbers, key=lambda x: order.index(x)), 'F'\n    # Straight\n    if all(order.index(sortedNums[i+1]) - order.index(sortedNums[i]) == 1 for i in range(4)):\n        return sortedNums[-1], 'S'\n    # Three of a kind\n    if counts[0] == 3:\n        return unique[0], 'TK'\n    # Two pairs\n    if counts[0] == 2 and counts[1] == 2:\n        return max(unique, key=lambda x: order.index(x)), 'TP'\n    # One pair\n    if counts[0] == 2:\n        return unique[0], 'OP'\n    # Highest card\n    return max(numbers, key=lambda x: order.index(x)), 'H'\n\n\nwith open('p054_poker.txt') as f:\n    pokerHands = np.array([[hands[:14].split(' '), hands[-14:].split(' ')] for hands in f.read().splitlines()])\n# Codes for each card ranking.\nrankings = ['H', 'OP', 'TP', 'TK', 'S', 'F', 'FH', 'FK', 'SF', 'RF']\norder = '23456789TJQKA'\np1Wins = 0\nfor hand1, hand2 in pokerHands:\n    hand1Res = pokerRanking(hand1)\n    hand2Res = pokerRanking(hand2)\n    if rankings.index(hand1Res[1]) &gt; rankings.index(hand2Res[1]):\n        p1Wins += 1\n    if rankings.index(hand1Res[1]) == rankings.index(hand2Res[1]):\n        if order.index(hand1Res[0]) &gt; order.index(hand2Res[0]):\n            p1Wins += 1\n        elif order.index(hand1Res[0]) == order.index(hand2Res[0]):\n            # Keep removing the highest card from both sides until\n            # there's a winner\n            numbers1 = [card[0] for card in hand1]\n            numbers2 = [card[0] for card in hand2]\n            while max(numbers1, key=lambda x: order.index(x)) == \\\n                    max(numbers2, key=lambda x: order.index(x)):\n                toRem = max(numbers1, key=lambda x: order.index(x))\n                numbers1.remove(toRem)\n                numbers2.remove(toRem)\n            if (max(numbers1, key=lambda x: order.index(x)) &gt;\n                max(numbers2, key=lambda x: order.index(x))):\n                p1Wins += 1\n\nprint(p1Wins)\n\nRunning this large code block results in,\n376\n0.15291450749056495 seconds.\n\nTherefore, Player 1 wins 376 of the hands listed.\n",
      "categories": ["project_euler"],
      "tags": ["10_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-18-054-Poker-hands/"
    },{
      
      "title": "#64 - Odd period square roots",
      "date": "2017-06-19 10:33:00 +0000",
      
      "content": "\n  All square roots are periodic when written as continued fractions and can be written in the form:\n\n\\[\\sqrt{N}=a_0 + \\frac{1}{a_1 + \\frac{1}{a_2 + \\frac{1}{a_3+\\dots}}}\\]\n\n  For example, let us consider $\\sqrt{23}$:\n\n\\[\\sqrt{23}=4+\\sqrt{23}-4=4 + \\frac{1}{\\frac{1}{\\sqrt{23} - 4}} = 4 + \\frac{1}{1 + \\frac{\\sqrt{23} - 3}{7}}\\]\n\n  If we continue we would get the following expansion:\n\n\\[\\sqrt{23} = 4 + \\frac{1}{1 + \\frac{1}{3 + \\frac{1}{1 + \\frac{1}{8 + \\dots}}}}\\]\n\n  The process can be summarized as follows:\n\n\\[\\begin{aligned}\na_0 &amp;= 4, \\frac{1}{\\sqrt{23}-4} = \\frac{\\sqrt{23} + 4}{7} = 1 + \\frac{\\sqrt{23} - 3}{7}\n\\\\\na_1 &amp;= 1, \\frac{7}{\\sqrt{23}-3} = \\frac{7(\\sqrt{23} + 3)}{14} = 3 + \\frac{\\sqrt{23} - 3}{2}\n\\\\\na_2 &amp;= 3, \\frac{1}{\\sqrt{23}-4} = \\frac{\\sqrt{23} + 4}{7} = 1 + \\frac{\\sqrt{23} - 3}{7}\n\\\\\na_3 &amp;= 1, \\frac{7}{\\sqrt{23}-4} = \\frac{7(\\sqrt{23} + 4)}{7} = 8 + \\sqrt{23} - 4\n\\\\\na_4 &amp;= 8, \\frac{1}{\\sqrt{23}-4} = \\frac{\\sqrt{23} + 4}{7} = 1 + \\frac{\\sqrt{23} - 3}{7}\n\\\\\na_5 &amp;= 1, \\frac{7}{\\sqrt{23}-3} = \\frac{7(\\sqrt{23} + 3)}{14} = 3 + \\frac{\\sqrt{23} - 3}{2}\n\\\\\na_6 &amp;= 3, \\frac{1}{\\sqrt{23}-4} = \\frac{\\sqrt{23} + 4}{7} = 1 + \\frac{\\sqrt{23} - 3}{7}\n\\\\\na_7 &amp;= 1, \\frac{7}{\\sqrt{23}-4} = \\frac{7(\\sqrt{23} + 4)}{7} = 8 + \\sqrt{23} - 4\n\\end{aligned}\\]\n\n  It can be seen that the sequence is repeating. For conciseness, we use the notation $\\sqrt{23}=[4;(1,3,1,8)]$, to indicate that the block (1,3,1,8) repeats indefinitely.\n\n  The first ten continued fraction representation of (irrational) square roots are:\n\n\\[\\begin{aligned}\n\\sqrt{2} &amp;= [1;(2)], \\text{period=1}\n\\\\\n\\sqrt{3} &amp;= [1:(1,2)], \\text{period=2}\n\\\\\n\\sqrt{5} &amp;= [2;(4)], \\text{period=1}\n\\\\\n\\sqrt{6} &amp;= [2;(2,4)], \\text{period=2}\n\\\\\n\\sqrt{7} &amp;= [2;(1,1,1,4)], \\text{period=4}\n\\\\\n\\sqrt{8} &amp;= [2;(1,4)], \\text{period=2}\n\\\\\n\\sqrt{10} &amp;= [3;(6)], \\text{period=1}\n\\\\\n\\sqrt{11} &amp;= [3;(3,6)], \\text{period=2}\n\\\\\n\\sqrt{12} &amp;= [3;(2,6)], \\text{period=2}\n\\\\\n\\sqrt{13} &amp;= [3;(1,1,1,1,6)], \\text{period=5}\n\\end{aligned}\\]\n\n  Exactly four continued fractions, for $N\\leq 13$, have an odd period.\n\n  How many continued fractions for $N\\leq10\\,000$ have an odd period?\n\n\n\nA related problem is #57 - Square root convergents, where we given the fraction and asked to calculate the extended fractions. Here, though we instead need to calculate the period of the fraction. We would need an upper bound to stop generating the next fraction.\n\nAfter some research, I found a little section in this Wikipedia article that reads:\n\n  If $r&gt;1$ is a rational number that is not a perfect square, then\n\n\\[\\sqrt{r} = [a_0;\\overline{a_1,a_2,\\dots,a_2,a_1,2a_0}]\\]\n\n\nThe details of the proof are slightly out of scope for this site, but feel free to read the article if you are interested.\n\nThis gives us a way to calculate the length of the period. In these cases, $a_0$ corresponds to the integer part of $\\sqrt{N}$. We keep generating the next number in the sequence until we reach $2a_0$.\n\nHow do we calculate the next number in the sequence? One simple way is to keep taking the reciprocal and taking the integer part:\n\n  $\\sqrt{23}\\approx 4.79 \\Rightarrow a_0=4$\n  $\\sqrt{23}-\\mathbf{a_0}\\approx 0.79 \\Rightarrow \\frac{1}{0.79}\\approx 1.256 \\Rightarrow a_1 = 1$\n  $\\frac{1}{1.256-\\mathbf{a_1}}\\approx 3.90 \\Rightarrow a_2 = 3$\n  $\\frac{1}{3.90-\\mathbf{a_2}}\\approx 1.11 \\Rightarrow a_3 = 1$\n  $\\frac{1}{1.11-\\mathbf{a_3}}\\approx 8.79 \\Rightarrow a_4=8$\n\n\nSince $a_4 = 8 = 2(4) = 2a_0$, we are done, and the period length is 4. The problem with this method is that we have to constantly keep track of floating point numbers, which can sometimes be inaccurate. An integer-only way to generate the sequence would be much preferred because it is much faster to do integer arithmetic.\n\nI stumbled upon this section in a Wiki article, describing how to generate the sequence using only integers. the algorithm essentially keeps track of the irrational radical fraction that you repeatedly see in the problem example $\\frac{\\sqrt{23}-3}{7}, \\frac{\\sqrt{23}-3}{2}$, etc. It relies on the guaranteed fact that $N-m_{n+1}^2$ always divides $d_n$ at each step. The reason why is a bit out of scope for this answer, and I encourage you to read this math StackExachange question if you are curious.\n\nThe algorithm is simple enough to directly convert into code.\n# file: \"problem064.py\"\ndef periodLength(S):\n    m = 0\n    d = 1\n    # Integer part is a0\n    a0 = int(math.sqrt(S))\n    # Current a\n    a = a0\n    count = 0\n    # Keep going until we get to 2a_0\n    while a != 2 * a0:\n        m = d * a - m\n        d = (S - m ** 2) // d\n        a = int((a0 + m) / d)\n        count += 1\n    return count\n\nNow we loop through all non-square $N$, and see whether the period length is odd.\n# file: \"problem064.py\"\noddPeriod = 0\nfor n in range(2, 10001):\n    # Skip square numbers\n    if int(math.sqrt(n)) == math.sqrt(n):\n        continue\n    # Calculate period length and check if odd\n    length = periodLength(n)\n    if periodLength(n) % 2 == 1:\n        oddPeriod += 1\n\nprint(oddPeriod)\n\nRunning this short loop gets us,\n1322\n0.4687670246846322 seconds.\n\nTherefore, there are 1322 numbers below 10000 where the period length of the continued fraction of the square root is odd.\n",
      "categories": ["project_euler"],
      "tags": ["20_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-19-064-Odd-period-square-roots/"
    },{
      
      "title": "#65 - Convergents of $e$",
      "date": "2017-06-19 11:11:00 +0000",
      
      "content": "\n  The square root of 2 can be written as an infinite continued fraction.\n\n\\[\\sqrt{2} = 1 + \\frac{1}{2 + \\frac{1}{2 + \\frac{1}{2 + \\frac{1}{2+\\dots}}}}\\]\n\n  The infinite continued fraction can be written, $\\sqrt{2}=[1;(2)]$, $(2)$ indicates that 2 repeats ad infinitum. In a similar way, $\\sqrt{23}=[4;(1,3,1,8)]$.\n\n  It turns out that the sequence of partial values of continued fractions for square roots provide the best rational approximations. Let us consider the convergents for $\\sqrt{2}$.\n\n\\[\\begin{aligned}\n1 + \\frac{1}{2} &amp;= \\frac{3}{2}\n\\\\\n1 + \\frac{1}{2 + \\frac{1}{2}} &amp;= \\frac{7}{5}\n\\\\\n1 + \\frac{1}{2 + \\frac{1}{2 + \\frac{1}{2}}} &amp;= \\frac{17}{12}\n\\\\\n1 + \\frac{1}{2 + \\frac{1}{2 + \\frac{1}{2 + \\frac{1}{2}}}} &amp;= \\frac{41}{29}\n\\end{aligned}\\]\n\n  Hence the sequence of the first ten convergents for $\\sqrt{2}$ are:\n\n\\[1,\\frac{3}{2}, \\frac{7}{5}, \\frac{17}{12}, \\frac{41}{29}, \\frac{99}{70}, \\frac{239}{169}, \\frac{577}{408}, \\frac{1393}{985}, \\frac{3363}{2378}, \\dots\\]\n\n  What is most surprising is that the important mathematical constant,\n\n\\[e=[2;1,2,1,1,4,1,1,6,1,\\dots,1,2k,1,\\dots]\\]\n\n  The first ten terms in the sequence of convergents for $e$ are:\n\n\\[2,3,\\frac{8}{3},\\frac{11}{4},\\frac{19}{7}, \\frac{87}{32}, \\frac{106}{39}, \\frac{193}{71}, \\frac{1264}{465}, \\frac{1457}{536},\\dots\\]\n\n  The sum of digits in the numerator of the $\\text{10}^\\text{th}$ convergent is $1+4+5+7=17$.\n\n  Find the sum of digits in the numerator of the $100^\\text{th}$ convergent of the continued fraction for $e$.\n\n\n\nHere we are just calculating a fraction. We’ll need to work from the bottom up. An example for the fourth convergent of $e$:\n\n\\(2+\\frac{1}{1 + \\frac{1}{2+\\frac{1}{1}}} = 2 + \\frac{1}{1+\\frac{1}{\\color{red}{\\frac{3}{1}}}}\n= 2 + \\frac{1}{1 + \\frac{1}{3}} = 2 + \\frac{1}{\\color{red}{\\frac{4}{3}}} = 2 + \\frac{3}{4} =\n\\boxed{\\frac{11}{4}}\\)\nThis allows us to see what the algorithm is. We start from the lowest fraction, and work our way up:\n\n\\(\\frac{1}{a_i + \\frac{N}{D}} = \\frac{1}{\\frac{Da_i+N}{D}} = \\frac{D}{Da_i+N}\\)\nwhere $a_i$ is the current constant, $N$ is the current numerator and $D$ is the current denominator. This provides us with an easy loop for each constant in the continued fraction sequence.\n\nThe first step is generating all of our $a_i$’s. Since we need the 100th convergent, we generate 99 numbers (2 is considered the first iteration, without the fraction). We also need to keep track of the $2k$ constants as well.\n# file: \"problem065.py\"\ncoeffs = []\nn = 1\nwhile len(coeffs) &lt; 99:\n    if len(coeffs) % 3 == 1:\n        coeffs.append(n * 2)\n        n += 1\n    else:\n        coeffs.append(1)\n# Add and flip over and over again\nnum = 1\ndenom = coeffs[-1]\nfor i in range(len(coeffs) - 2, -1, -1):\n    # Add\n    num += coeffs[i] * denom\n    # Flip\n    temp = num\n    num = denom\n    denom = temp\n# Add the final two\nnum += 2 * denom\nprint(sum([int(x) for x in str(num)]))\n\nRunning the code results in an output of,\n272\n0.00021688880320442342 seconds.\n\nTherefore, the sum of the digits in the numerator of the 100th convergent of $e$ is 272.\n",
      "categories": ["project_euler"],
      "tags": ["15_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-19-065-Convergents-of-e/"
    },{
      
      "title": "#79 - Passcode derivation",
      "date": "2017-06-19 11:19:00 +0000",
      
      "content": "\n  A common security method used for online banking is to ask the user for three random characters from a passcode. For example, if the passcode was 531278, they may ask for the 2nd, 3rd, and 5th characters; the expected reply would be: 317.\n\n  The text file, keylog.txt, contains fifty successful login attempts.\n\n  Given that the three characters are always asked for in order, analyze the file so as to determine the shortest possible secret passcode of unknown length.\n\n\n\nLooking through the successful login attempts, two things jump out:\n\n  Every code starts with a 7\n  Every code ends with a 0\n\n\nThis means that the true passcode starts and ends with a 7 and 0 respectively.\n\nSome assumptions before we start searching:\n\n  Each digit appears only once in the full passcode, since we are looking for the shortest possible passcode, and no digit appears twice within each login attempt.\n  No 4s or 5s are in the passcode, since no login attempt had one.\n\n\nWe will store the possibilites of what numbers can come before and after a certain digit by using a dictionary which maps each number to a 2-tuple.\n\nIn order to build the full passcode, we see which digit has no possible digits that come before it. After we’ve selected it, we remove that number from all other instances. We repeat process, until we have exhausted through everything. The ending string is the full passcode.\n# file: \"problem79.py\"\n# Set a bunch of rules, like digit x must come before y.\nrules = {str(digit): (set(), set()) for digit in range(10) if digit != 4 and digit != 5}\n\nwith open('./p079_keylog.txt', 'r') as f:\n    keylogs = f.read().splitlines()\n\nfor log in keylogs:\n    for i in range(len(log)):\n        if i == 0:\n            rules[log[i]][1].add(log[i+1])\n        elif i == len(log) - 1:\n            rules[log[i]][0].add(log[i-1])\n        else:\n            rules[log[i]][0].add(log[i-1])\n            rules[log[i]][1].add(log[i+1])\n# Now we see which digit has nothing\n# come before it. Once we've found it,\n# we remove that from all other lists,\n# and perform the search again...\npassword = ''\nwhile len(password) &lt; 8:\n    nextDigit = None\n    for key, values in rules.items():\n        if len(values[0]) == 0:\n            nextDigit = key\n            break\n    password += nextDigit\n    del rules[nextDigit]\n    # Remove it from the rest...\n    for key, values in rules.items():\n        if nextDigit in values[0]:\n            values[0].remove(nextDigit)\n\nprint('The password is', password)\n\nRunning the above code, we get\nThe password is 73162890\n0.0008719999999999839 seconds.\n\nThus, our full passcode is 73162890.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-19-079-Passcode-derivation/"
    },{
      
      "title": "#89 - Roman numerals",
      "date": "2017-06-19 14:07:00 +0000",
      
      "content": "\n  For a number written in Roman numerals to be considered valid there are basic rules which must be followed. Even though the rules allow some numbers to be expressed in more than one way there is always a “best” way of writing a particular number.\n\n  For example, it would appear that there are at least six ways of writing the number sixteen:\n\n  \nIIIIIIIIIIIIIIII\nVIIIIIIIIIII\nVVIIIIII\nXIIIIII\nVVVI\nXVI\n\n\n  However, according to the rules only XIIIIII and XVI are valid, and the last example is considered to be the most efficient, as it uses the least number of numerals.\n\n  The 11K text file, roman.txt (right click and ‘Save Link/Target As…’), contains one thousand numbers written in valid, but not necessarily minimal, Roman numerals; see About… Roman Numerals for the definitive rules for this problem.\n\n  Find the number of characters saved by writing each of these in their minimal form.\n\n  Note: You can assume that all the Roman numerals in the file contain no more than four consecutive identical units.\n\n\n\nBarring some special edge cases (please see the link) the rule for creating Roman numerals boils down to: From left to right, the numeral must NOT increase, UNLESS it is following the rule of subtraction.\n\nWe need functions that convert back and forth. Converting roman numerals to numbers is straightforward; just look at each pair of numerals and add them to a running total (accounting for subtraction rules when necessary). Going the other direction is a bit more tricky. Looking at the rules, we can deduce that there are really 13 possible denominations:\n\n  1000 - M\n  900 - CM\n  500 - D\n  400 - CD\n  100 - C\n  90 - XC\n  50 - L\n  40 - XL\n  10 - X\n  9 - IX\n  5 - V\n  4 - IV\n  1 - I\n\n\nWe need to continuously check what the biggest denomination less than the given number is. We then subtract off that value, and keep repeating until the number is 0.\n# file: \"problem089.py\"\ndef romanToNum(romanStr):\n    romanVal = {'M':1000, 'D':500, 'C':100,\n                'L':50, 'X':10, 'V':5, 'I':1}\n    value = 0\n    i = 0\n    while i &lt; len(romanStr):\n        r = romanStr[i]\n        if i &lt; len(romanStr) - 1 and romanVal[r] &lt; romanVal[romanStr[i+1]]:\n            value += romanVal[romanStr[i+1]] - romanVal[r]\n            i += 2\n        else:\n            value += romanVal[r]\n            i += 1\n    return value\ndef numToRoman(n):\n    roman = ''\n    # The values that can be encoded are\n    # 1000, 900, 500, 400, 100, 90, 50, 40,\n    # 10, 9, 5, 4, and 1 with one or two numerals\n    # So count down\n    values = [1000, 900, 500, 400,\n              100, 90, 50, 40, 10,\n              9, 5, 4, 1]\n    codings = ['M', 'CM', 'D', 'CD',\n               'C', 'XC', 'L', 'XL',\n               'X', 'IX', 'V', 'IV', 'I']\n    mappings = {value: code for value, code in zip(values, codings)}\n    while n &gt; 0:\n        # Find the greatest denomination that\n        # is less than n...\n        i = 0\n        while values[i] &gt; n:\n            i += 1\n        val = values[i]\n        # Get the mapping, and subtract it off...\n        roman += mappings[val]\n        n -= val\n    return roman\n\nlettersSaved = 0\nwith open('p089_roman.txt') as f:\n    romans = f.read().splitlines()\nfor roman in romans:\n    lettersSaved += len(roman) - len(numToRoman(romanToNum(roman)))\n\nprint(lettersSaved)\n\nRunning this code gets us an output of,\n743\n0.022997900000000016 seconds.\n\nThus, we save 743 letters if we write each roman numeral in its minimal form.\n",
      "categories": ["project_euler"],
      "tags": ["20_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-19-089-Roman-numerals/"
    },{
      
      "title": "#52 - Permuted multiples",
      "date": "2017-06-19 15:07:00 +0000",
      
      "content": "\n  It can be seen that the number, 125874, and its double 251748, contain exactly the same digits, but in a different order.\n\n  Find the smallest positive integer, $x$, such that $2x,3x,4x,5x$ and $6x$, contain the same digits.\n\n\n\nThere are two optimizations we can make for the brute force method. Because we are checking 6 multiples, $x$ should have at least 6 digits. If $x$ has $k$ digits, we only have to check up until $\\lfloor 10^{k}/6 \\rfloor$, because anything bigger than this will lead to $6x$ having $k+1$ digits, ruling it out of contention.\n\nTo check if all the multiples have the same digits, I convert each number to a string, sort each string, and finally call set() on the list. If the set has exactly 1 element, then each sorted string is the same, meaning each number had the same digits. We start at $x=10^5 = 100000$ and keep counting up. If we reach the limit for 6 digits, then we immediately move on to 7 digits.\n# file: \"problem052.py\"\nx = 100000\nwhile True:\n    if x &gt; 10 ** len(str(x)) / 6:\n        x = 10 ** len(str(x))\n        continue\n    # Test x through 6x...\n    multiples = [''.join(sorted(str(x * i))) for i in range(1, 7)]\n    # If it has one element after set()...\n    # then they all have the same digits in different\n    # orders.\n    if len(set(multiples)) == 1:\n        print(x)\n        break\n    x += 1\n\nRunning the loop gets us,\n142857\n0.45314348766162477 seconds.\n\nTherefore, 142857 has all 6 multiples containing the same digits.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-19-052-Permuted-multiples/"
    },{
      
      "title": "#55 - Lychrel numbers",
      "date": "2017-06-19 19:51:00 +0000",
      
      "content": "\n  If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.\n\n  Not all numbers produce palindromes so quickly. For example,\n\n\\[\\begin{aligned}\n349+943 &amp;= 1292\n\\\\\n1292+2921 &amp;= 4213\n\\\\\n4213+3124 &amp;= 7337\n\\end{aligned}\\]\n\n  That is, 349 took three iterations to arrive at a palindrome.\n\n  Although no one has proved it yet, it is thought that some numbers, like 196, never produce a palindrome. A number that never forms a palindrome through the reverse and add process is called a Lychrel number. Due to the theoretical nature of these numbers, and for the purpose of this problem, we shall assume that a number is Lychrel until proven otherwise. In addition you are given that for every number below ten-thousand, it will either (i) become a palindrome in less than fifty iterations, or, (ii) no one, with all the computing power that exists, has managed so far to map it to a palindrome. In fact, 10677 is the first number to be shown to require over fifty iterations before producing a palindrome: 4668731596684224866951378664 (53 iterations, 28-digits).\n\n  Surprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first example is 4994.\n\n  How many Lychrel numbers are there below ten-thousand?\n\n\n\nSince the bound is relatively low, we can do this directly. We keep adding the reverse of the number until a palindrome is reached. We keep track of the number of iterations. If we pass 50, then we break immediately, and add to the count.\n\nThe isPalindrome function is very basic, as it checks if it’s equal to the reverse of the integer. To save a bit of time, I check one-digit and two-digit numbers on their own. All one-digit numbers are palindromes, and a two-digit number is a palindrome if it’s divisible by 11.\n# file: \"problem055.py\"\ndef isPalindrome(n):\n    # One digit number are\n    # automatically palindromes.\n    # If it's two digits, then it\n    # should be divisible by 11.\n    if n &lt; 10 or (n &lt; 100 and n % 11 == 0):\n        return True\n    n = str(n)\n    return n == n[::-1]\n\nisLychrel = 0\nfor n in range(1, 10001):\n    i = n + int(str(n)[::-1])\n    iters = 2\n    # Keep going until iterations are more than 50\n    while iters &lt;= 50 and not isPalindrome(i):\n        i += int(str(i)[::-1])\n        iters += 1\n    # If the first condition failed,\n    # then we have 51 iterations....\n    if iters == 51:\n        isLychrel += 1\n    print('\\r' + str(n) + ' / 10000 numbers finished.', end='')\nprint()\nprint(isLychrel)\n\nRunning the code results in,\n10000 / 10000 numbers finished.\n249\n1.2541913069861503 seconds.\n\nTherefore, there are 245 Lychrel numbers below ten-thousand.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-19-055-Lychrel-numbers/"
    },{
      
      "title": "#56 - Powerful digit sum",
      "date": "2017-06-19 19:55:00 +0000",
      
      "content": "\n  A googol $\\left(10^{100}\\right)$ is a massive number: one followed by one-hundred zeros; $100^{100}$ is almost unimaginably large: one followed by two-hundred zeros. Despite their size, the sum of the digits in each number is only 1.\n\n  Considering natural numbers of the form, $a^b$, where $a, b &lt; 100$, what is the maximum digital sum?\n\n\n\nAnother straightforward problem. All we need to do is loop through all $a$ and $b$, compute $a^b$, and add the digits together.\n# file: \"problem056.py\"\nmaxSum = 0\nfor a in range(1, 100):\n    for b in range(1, 100):\n        s = sum(int(x) for x in str(a ** b))\n        if s &gt; maxSum:\n            maxSum = s\n\nprint(maxSum)\n\noutput of the above is,\nMax digital sum at 99^95 with a sum of 972\n0.2502726912502948 seconds.\n\nThus, $99^{95}$ has the maximum digital sum of 972.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-19-056-Powerful-digit-sum/"
    },{
      
      "title": "#57 - Square root convergents",
      "date": "2017-06-19 20:11:00 +0000",
      
      "content": "\n  Is it possible to show that the square root of two can be expressed as an infinite continued fraction.\n\n\\[\\sqrt{2} = 1 + \\frac{1}{2+\\frac{1}{2 + \\frac{1}{2+\\dots}}} = 1.414213\\dots\\]\n\n  By expanding this for the first four iterations, we get:\n\n\\[\\begin{aligned}\n1 + \\frac{1}{2} &amp;= \\frac{3}{2} = 1.5\n\\\\\n1 + \\frac{1}{2+\\frac{1}{2}} &amp;= \\frac{7}{5} = 1.4\n\\\\\n1 + \\frac{1}{2+\\frac{1}{2+\\frac{1}{2}}} &amp;= \\frac{17}{12} = 1.41666\\dots\n\\\\\n1 + \\frac{1}{2+\\frac{1}{2+\\frac{1}{2+\\frac{1}{2}}}} &amp;= \\frac{41}{29} = 1.41379\\dots\n\\end{aligned}\\]\n\n  The next three expansions are, $\\frac{99}{70},\\frac{239}{169},\\frac{577}{408}$, but the eight expansion, $\\frac{1393}{895}$, is the first example where the number of digits in the numerator exceeds the number of digits in the denominator.\n\n  In the first one-thousand expansions, how many fractions contain a numerator with more digits than denominator?\n\n\n\nWe need to figure out a way to get from one expansion to the next. Recalculating every single expansion each time is inefficient.\n\nLet’s focus on the fraction part, as adding 1 is relatively easy. We can distill the question into: if the current expansion is $\\frac{p}{q}$, then what is the next expansion?\n\nFrom our problem example, the fractional-only expansion of the 2nd and 3rd step is $\\frac{2}{5}$ and $\\frac{5}{12}$ respectively. However, with the 3rd expansion, notice the expression in red:\n\n\\(\\frac{1}{2 + \\color{red}{\\frac{1}{2 + \\frac{1}{2}}}}\\)\nThat is exactly the expression used for the 2nd expansion of $\\frac{2}{5}$! In that case, we can plug this in directly, and end up computing\n\n\\(\\frac{1}{2+\\frac{2}{5}} = \\frac{1}{\\frac{12}{5}}=\\frac{5}{12}\\)\nIn general, this pattern will follow each pair of expansion. As an extra example, the 3rd expansion can be plugged into the 4th in the same way:\n\n\\(\\frac{1}{2 + \\frac{5}{12}} = \\frac{1}{\\frac{29}{12}} = \\frac{12}{29}\\)\nWith $\\frac{p}{q}$, the next expansion becomes\n\n[\\frac{1}{2+\\frac{p}{q}} = \\frac{1}{\\frac{2q+p}{q}} = \\frac{q}{2q+p}]\n\nThis calculation can easily be done in code quickly, as we only need the previous expansion. Adding 1 equates to adding the numerator and denominator together, so that is our check.\n# file: \"problem057.py\"\nexceeding = 0\n# Expansion of sqrt(2) is all 2s\nnum = 0\ndenom = 1\nfor _ in range(1000):\n    num += 2 * denom\n    # Flip\n    temp = num\n    num = denom\n    denom = temp\n    # Check if the length f num exceeds denom\n    # ADD ONE!\n    if len(str(num + denom)) &gt; len(str(denom)):\n        exceeding += 1\nprint(exceeding)\n\nRunning the above results in,\n153\n0.004323158785912579 seconds.\n\nTherefore, there are 153 expansions within the first one-thousand that have more digits in the numerator than that of the denominator.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-19-057-Square-root-convergents/"
    },{
      
      "title": "#58 - Spiral primes",
      "date": "2017-06-20 09:10:00 +0000",
      
      "content": "\n  Starting with 1 and spiral anticlockwise in the following way, a square spiral with side length 7 is formed.\n\n  \n37 36 35 34 33 32 31\n38 17 16 15 14 13 30\n39 18  5  4  3 12 29\n40 19  6  1  2 11 28\n41 20  7  8  9 10 27\n42 21 22 23 24 25 26\n43 44 45 46 47 48 49\n\n\n  It is interesting to note that the odd squares lie along the bottom right diagonal, but what is more interesting is that 8 out of the 13 numbers lying along both diagonals are prime; that is, a ratio of 8/13 ~ 62%.\n\n  If one complete new layer is wrapped around the spiral above, a square spiral with side length 9 will be formed. If this process is continued, what is the side length of the square spiral for which the ratio of primes along both diagonals first falls below 10%?\n\n\n\nWe first need to construct the spiral of numbers. The side length can only be odd, and furthermore, to get from one corner number to the other, you add one less than the length of the side you are on. For example, from 13 to 17, you need to add 4, while the side length is 5.\n\nOur methodology is to keep generating primes from one square to the next, calculate the 4 corner numbers, and see how many are primes. We keep track of the total number of diagonal numbers and the total number of primes.\n# file: \"problem058.py\"\n# Side lengths are always\n# odd. Keep track of\n# primes on diagonals...\nsideLen = 7\nprimesOnDiags = 8\ntotalDiags = 13\nwhile primesOnDiags / totalDiags &gt;= 0.1:\n    # Put one complete layer.\n    diagonalNums = [sideLen ** 2 + (sideLen + 1) * i for i in range(1, 5)]\n    # Generate primes in this layer...\n    primesInLayer = primesieve.primes(sideLen ** 2, (sideLen + 2) ** 2)\n    # Go through each diagonal number, and see if it's\n    # in the prime set...increment the primesOnDiags if it is...\n    primesOnDiags += sum(diag in primesInLayer for diag in diagonalNums)\n    # Number of diagonal numbers increases by 4\n    totalDiags += 4\n    # Side length increases by 2...\n    sideLen += 2\n\nprint(sideLen)\n\nThe output is,\n26241\n3.9868424743338373 seconds.\n\nTherefore, a side length of 26241 is needed before the ratio falls below 10%.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-20-058-Spiral-primes/"
    },{
      
      "title": "#59 - XOR decryption",
      "date": "2017-06-20 09:46:00 +0000",
      
      "content": "\n  Each character on a computer is assigned a unique code and the  preferred standard is ASCII (American Standard Code for Information Interchange). For example, uppercase A = 65, asterisk (*) = 42, and  lowercase k = 107.\n\n  A modern encryption method is to take a text file, convert the bytes to ASCII, then XOR each byte with a given value, taken from a secret key. The advantage with the XOR function is that using the same encryption key on the cipher text, restores the plain text; for example, 65 XOR 42 = 107, then 107 XOR 42 = 65.\n\n  For unbreakable encryption, the key is the same length as the plain text message, and the key is made up of random bytes. The user would keep the encrypted message and the encryption key in different locations, and without both “halves”, it is impossible to decrypt the message.\n\n  Unfortunately, this method is impractical for most users, so the modified method is to use a password as a key. If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message. The balance for this method is using a sufficiently long password key for security, but short enough to be memorable.\n\n  Your task has been made easy, as the encryption key consists of three lower case characters. Using p059_cipher.txt  (right click and ‘Save Link/Target As…’), a file containing the encrypted ASCII codes, and the knowledge that the plain text must contain common English words, decrypt the message and find the sum of the ASCII values in the original text.\n\n\n\nIt seems straightforward: Try every combination of three lowercase letters, decrypt the message, and see if it makes sense. However, there are a couple of problems here:\n\n  All combinations of three lowercase letters is $26^3=17576$, which might not be too bad in this problem, but can get unruly if we have any more letters.\n  What does “if it makes sense” mean? It means “the excerpt is read properly and is legible”, but how do we translate that logic into code?\n\n\nFor the first bullet point, we can take this approach: Since the sequence of three letters will be repeated, that means each letter in the key will decrypt every third letter in the encrypted message. We can examine if every third letter can indeed be translated into a letter, digit, or special character. If it’s outside of this ASCII range, then we can rule out that letter in that position, and drastically reduce the number of possibilities we have to sift through.\n\nFor the second point, note that the problem says that the text contains common English words. More quantitatively, we can conclude that the distribution of the letters in the decrypted text follow closely with that of the English language. Now, the distribution of the letters in the English language can be seen at this Wikipedia page. To measure “closeness”, we can calculate the character-wise distance this frequency vector to that of our decrypted message. The key which produces the smallest distance to the ground truth distribution will be the correct key.\n\nIn Python, we have chr() and ord() which goes back and forth between the character and the integer it represents. The XOR operation in Python is the single carat ^. The valid ASCII range in our problem is from 32 (space) to 122. We use itertools.product to go through all combinations of letters.\n# file: \"problem059.py\"\nwith open('p059_cipher.txt') as f:\n    encryptedMess = [int(a) for a in f.readline().split(',')]\n\n# Find the only possible letters that could\n# be part of the enccryption key.\nencryptedPosses = []\nfor i in range(3):\n    possLetters = []\n    for letter in string.ascii_lowercase:\n        intRep = ord(letter)\n        # Encrypt every 3rd letter starting\n        # from i...\n        decryptedCharas = [intRep ^ encInt for encInt in encryptedMess[i::3]]\n        # All of the decrypted charas have to be\n        # letters, digits, special charas, or spaces.\n        # So integer is between 32 and 122.\n        if all(32 &lt;= charaInt &lt;= 122 for charaInt in decryptedCharas):\n            possLetters.append(letter)\n    encryptedPosses.append(possLetters)\n\n# Ground truth frequency for each letter\n# in english language (from Wikipedia)\ngroundTruth = [0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015,\n               0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749,\n               0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758,\n               0.00978, 0.02360, 0.00150, 0.01974, 0.00074]\nbestKey = ''\nclosestDist = float('inf')\nfor possibleKey in product(*encryptedPosses):\n    # Decrypt text given this key\n    decryptedText = [chr(ord(possibleKey[i % 3]) ^ encryptedMess[i]) for i in range(len(encryptedMess))]\n    # Turn everything to lowercase and grab\n    # only letters...\n    onlyLetters = [chara.lower() for chara in decryptedText if chara.lower() in string.ascii_lowercase]\n    # Calculate counts of each letter\n    letterCounts = np.zeros(26)\n    for letter in onlyLetters:\n        letterCounts[ord(letter) - 97] += 1\n    # Calculate frequency\n    letterFreq = letterCounts / np.sum(letterCounts)\n    # Calculate distance to ground truth\n    # distribution\n    distance = np.linalg.norm(letterFreq - groundTruth)\n    if distance &lt; closestDist:\n        closestDist = distance\n        bestKey = ''.join(possibleKey)\n\nprint('Best key is \"{}\".'.format(bestKey))\n\n# Now decrypt message and add all\n# integers...\ndecryptedSum = sum([ord(bestKey[i % 3]) ^ encryptedMess[i] for i in range(len(encryptedMess))])\nprint('Sum of decrypted integers: {}'.format(decryptedSum))\n\nRunning the entire code results in,\nBest key is \"god\".\nSum of decrypted integers: 107359\n0.07973290677218499 seconds.\n\nTherefore, the key to the message is “god” and the sum is 107359. One more robust change we can make is that we check the decrypted words against a separate dictionary. We were lucky that the smallest distribution distance resulted in the correct answer.\nUpdate July 23, 2019\nDue to the religious nature of the key and the decrypted text, the encrypted message has been changed as of February 5, 2019. Instead, the code produces an output of\nBest key is \"exp\".\nSum of decrypted integers: 129448\n0.02513697772366312 seconds.\n\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-20-059-XOR-decryption/"
    },{
      
      "title": "#67 - Maximum path sum II",
      "date": "2017-06-21 09:29:00 +0000",
      
      "content": "\n  By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.\n\n  \n3\n7 4\n2 4 6\n8 5 9 3\n\n\n  That is, 3 + 7 + 4 + 9 = 23.\n\n  Find the maximum total from top to bottom in triangle.txt (right click and ‘Save Link/Target As…’) a 15K text file containing a triangle with one-hundred rows.\n\n  This is a much more difficult version #18 - Maximum path sum I. It is not possible to try every route to solve this problem, as there are $2^{99}$ altogether! If you could check one trillion $\\left(10^{12}\\right)$ routes every second it would take over twenty billion years to check them all. There is an efficient algorithm to solve it ;o)\n\n\n\nMy answer post on #18 - Maximum path sum I{:.heading.flip-title} has the efficient algorithm in question, so please refer to that post for the algorithm. After replacing the file in the code and running again, our output is\n7273\n0.004878615356596403 seconds.\n\nThus, the max total from top to bottom is 7273.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-21-067-Maximum-path-sum-II/"
    },{
      
      "title": "#71 - Ordered fractions",
      "date": "2017-06-21 10:12:00 +0000",
      
      "content": "\n  Consider the fraction, $n/d$, where $n$ and $d$ are positive integers. If $n&lt;d$ and $HCF(n,d)=1$, it is called a reduced proper fraction.\n\n  If we list the set of reduced proper fractions for $d\\leq 8$ in ascending order of size, we get:\n\n\\[\\frac{1}{8},\\frac{1}{7},\\frac{1}{6},\\frac{1}{5},\\frac{1}{4},\\frac{2}{7},\\frac{1}{3},\\frac{3}{8},\\mathbf{\\frac{2}{5}}, \\frac{3}{7},\\frac{1}{2},\\frac{4}{7},\\frac{3}{5},\\frac{5}{8},\\frac{2}{3},\\frac{5}{7},\\frac{3}{4},\\frac{4}{5},\\frac{5}{6},\\frac{6}{7},\\frac{7}{8}\\]\n\n  It can be seen that $2/5$ is the fraction immediately to the left of $3/7$.\n\n  By listing the set of reduced proper fractions for $d\\leq 1\\,000\\,000$ in ascending order of size, find the numerator of the fraction immediately to the left of $3/7$.\n\n\n\nThere are too many fractions to check for a brute force approach, and reducing all of them will also take time. We can instead ask a related question: Given a denominator $d$ what is the closest fraction to the left of $3/7$? For example, if $d=8$, we can see that $3/8$ is the closest fraction to the left of $3/7$. If we have fixed a denominator, it is simple to find the numerator:\n\n\\(\\frac{n}{d} &lt; \\frac{3}{7} \\Rightarrow n &lt; \\frac{3d}{7}\\)\nNow, $3d/7$ may not be an integer, in which case we take the floor function to get the greater integer for it. Additionally, we also have to be careful to not check denominators which are divisible by 7, since we will get the fraction itself.\n# file: \"problem071.py\"\nminDist = float('inf')\nbestNum = 0\nbestDenom = 1\n\n# Get the reduced fraction with the corresponding denominator\n# that is closest to the left of 3/7. Calculate distance for each one...\nfor denom in range(3, 1000001):\n    # Skip multiples of 7\n    if denom % 7 == 0:\n        continue\n    # Calculate closest numerator\n    num = 3 * denom // 7\n    # Calculate distance\n    dist = 3/7 - num/denom\n    if dist &lt; minDist:\n        minDist = dist\n        bestNum = num\n        bestDenom = denom\nprint(bestNum, '/', bestDenom)\n\nRunning gives,\n428570 / 999997\n0.3996735 seconds.\n\nThus, the fraction that is immediately to the left of $3/7$ is $428\\,570/999\\,997$ and hence the numerator is 428570.\n",
      "categories": ["project_euler"],
      "tags": ["10_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-21-071-Ordered-fractions/"
    },{
      
      "title": "#69 - Totient maximum",
      "date": "2017-06-21 11:37:00 +0000",
      
      "content": "\n  Euler’s Totient function, $\\phi(n)$ [sometimes called the phi function], is used to determine the number of numbers less than $n$ which are relatively prime to $n$. For example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, $\\phi(9)=6$.\n\n  \n    \n      \n        $n$\n        Relatively Prime\n        $\\phi(n)$\n        $n/\\phi(n)$\n      \n    \n    \n      \n        2\n        1\n        1\n        2\n      \n      \n        3\n        1,2\n        2\n        1.5\n      \n      \n        4\n        1,3\n        2\n        2\n      \n      \n        5\n        1,2,3,4\n        4\n        1.25\n      \n      \n        6\n        1,5\n        2\n        3\n      \n      \n        7\n        1,2,3,4,5,6\n        6\n        1.1666…\n      \n      \n        8\n        1,3,5,7\n        4\n        2\n      \n      \n        9\n        1,2,4,5,7,8\n        6\n        1.5\n      \n      \n        10\n        1,3,7,9\n        4\n        2.5\n      \n    \n  \n\n  It can be seen that $n=6$ produces a maximum $n/\\phi(n)$ for $n\\leq 10$.\n\n  Find the value of $n\\leq 1\\,000\\,000$ for which $n/\\phi(n)$ is a maximum.\n\n\n\nThis Wikipedia article states that the actual formula for $\\phi(n)$ is\n\n\\(\\phi(n) = n\\prod_{p|n}\\left(1-\\frac{1}{p}\\right)\\)\nWe take all the distinct prime numbers that divide $n$ and multiply according to the above. For example, 9 only has a prime factor of 3. Thus, $\\phi(9) = 9\\left(1-\\frac{1}{3}\\right) = 9\\left(\\frac{2}{3}\\right) = 6$.\n\nTo calculate for large $n$ we can keep a sieve going. Instead of marking off whether numbers are prime, we store a running value at each position. Furthermore, since we need the maximum value of $n/\\phi(n)$, we’ll actually need the minimum value of $\\prod_{p\\vert n}\\left(1 - \\frac{1}{p}\\right)$. We initialize the arrays with 1 to keep track of where the primes are.\n# file: \"problem069.py\"\n# Basically make a sieve, since totient of a number\n# is (1 - 1/p) for each distinct prime factor p...\nlimit = 1000000\ntotient = np.ones(limit + 1, dtype=float)\n# For each number starting at 2...\nfor n in range(2, limit + 1):\n    # If the value isn't 1, then it was a multiple of a prime factor...\n    if totient[n] != 1:\n        continue\n    # Otherwise, mark ell multiples\n    totient[np.arange(n, limit + 1, n)] *= (1 - 1/n)\n# Minimum value of prod(1 - 1/p) will produce maximum n/totient(n)\nprint(np.argmin(totient))\n\nRunning the above results in an output of,\n510510\n1.3519872 seconds.\n\nThus, $n=\\mathbf{510510}$ produces the largest value of $n/\\phi(n)$.\n",
      "categories": ["project_euler"],
      "tags": ["10_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-21-069-Totient-maximum/"
    },{
      
      "title": "#80 - Square root digital",
      "date": "2017-06-21 11:59:00 +0000",
      
      "content": "\n  It is well known that if the square root of a natural number is not an integer, then it is irrational. The decimal expansion of such square roots is infinite without any repeating pattern at all.\n\n  The square root of two is 1.41421356237309504880…, and the digital sum of the first one hundred decimal digits is 475.\n\n  For the first one hundred natural numbers, find the total of the digital sums of the first one hundred decimal digits for all the irrational square roots.\n\n\n\nIn the built-in decimal package, there is a variable called getcontext().prec. This is where we set how many total digits we want. Since we are going up to 100, 105 total digits is a safe bet. After that, it is simply a matter of converting each number to a string, finding the decimal point, then summing the first 100 digits after it.\n\n# file: \"problem080.py\"\nfrom decimal import *\n\n# square root of 100 is 10 so set precision to 105\n# to cover at least 100 decimal digits\ngetcontext().prec = 105\ns = 0\nfor n in range(2, 100):\n    if n ** 0.5 != int(n ** 0.5):\n        sqrt = str(Decimal(str(n)) ** Decimal('0.5'))\n        sqrt = sqrt.replace('.', '')\n        s += sum(int(val) for val in sqrt[:100])\nprint(s)\n\n\nRunning the short loop above gets us an output of,\n\n40886\n0.05162940000000038 seconds.\n\n\nThus, our desired sum is 40886.\n",
      "categories": ["project_euler"],
      "tags": ["20_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-21-080-Square-root-digital/"
    },{
      
      "title": "#76 - Counting summations",
      "date": "2017-06-21 12:35:00 +0000",
      
      "content": "\n  It is possible to write five as a sum in exactly six different ways:\n\n\\[\\begin{aligned}\n&amp;4 + 1\n\\\\\n&amp;3 + 2\n\\\\\n&amp;3 + 1 + 1\n\\\\\n&amp;2 + 2 + 1\n\\\\\n&amp;2 + 1 + 1 + 1\n\\\\\n&amp;1 + 1 + 1 + 1 + 1\n\\end{aligned}\\]\n\n  How many different ways can one hundred be written as a sum of at least two positive integers?\n\n\n\nBreaking up a number into sets of sums like this are called finding the partitions of a number. It is an area of extensive research.\n\nThe traditional count of partitions of a number also include the number itself, and it is denoted $p(n)$. When presenting the final answer, we need to subtract one.\n\nIntuitively, the value of $p(n)$ should somehow depend on the values before it (you can add one to all the partitions of $n-1$ and get $n$). This article shows the following recursive definition exists for $p(n$):\n\n\\(p(n) = \\sum_{k\\neq 0}^\\infty (-1)^{k+1}p\\left(n - \\frac{k(3k-1)}{2}\\right)\\)\nwhere $p(0)=1$ and $p(n)=0$ if $n&lt;0$. Thus, this sum will contain finitely many non-zero terms. Additionally, $\\frac{k(3k-1)}{2}$ steadily increases as $k$ goes $1, -1, 2, -2, 3, -3, 4, \\dots$. In fact, these are pentagonal numbers. Therefore, using dynamic programming, the solution is simple to code, as we keep an array of the past values.\n# file: \"problem076.py\"\nlimit = 100\n\np = [0] * (limit + 1)\n# Base case\np[0] = 1\nfor i in range(1, len(p)):\n    k = 1\n    # lambda function of pentagonal number\n    pent = lambda x: x * (3 * x - 1) // 2\n    while pent(k) &lt;= i:\n        p[i] += p[i - pent(k)] * int((-1) ** (k + 1))\n        # If k is positive, then it turns into\n        # its negative counterpart,\n        # Otherwise, it goes to the next number\n        if k &gt; 0:\n            k *= -1\n        else:\n            k = k * -1 + 1\nprint(p[limit] - 1)\n\nThe output after running is,\n190569291\n0.0013518999999999615 seconds.\n\nTherefore, 100 can be written as a sum of positive integers in 190569291 ways.\n",
      "categories": ["project_euler"],
      "tags": ["10_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-21-076-Counting-summations/"
    },{
      
      "title": "#81 - Path sum: two ways",
      "date": "2017-06-23 10:24:00 +0000",
      
      "content": "\n  In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right, by only moving to the right and down, is indicated in bold red and is equal to 2427.\n\n\\[\\begin{pmatrix}\n\t\\color{red}{\\mathbf{131}} &amp; 673 &amp; 234 &amp; 103 &amp; 18\n\t\\\\\n\t\\color{red}{\\mathbf{201}} &amp; \\color{red}{\\mathbf{96}} &amp; \n\t\t\\color{red}{\\mathbf{342}} &amp; 965 &amp; 150\n\t\\\\\n\t630 &amp; 803 &amp; \\color{red}{\\mathbf{746}} &amp; \\color{red}{\\mathbf{422}} &amp; 111\n\t\\\\\n\t537 &amp; 699 &amp; 497 &amp; \\color{red}{\\mathbf{121}} &amp; 956\n\t\\\\\n\t805 &amp; 732 &amp; 524 &amp; \\color{red}{\\mathbf{37}} &amp; \\color{red}{\\mathbf{331}}\n\\end{pmatrix}\\]\n\n  Find the minimal path sum from the top left to the bottom right by only moving right and down in matrix.txt (right click and “Save Link/Target As…”), a 31K text file containing an 80 by 80 matrix.\n\n\n\nThe addition in this matrix is a one-way street, since we’re only dealing with positive integers. The sum will only get bigger. We can then save the minimum path sum for any path ending in a cell by comparing adding the number to its right and below it. I’ll show an example using a smaller matrix. Suppose our matrix $M$ is just the top 3 by 3 corner of the example:\n\n\\(M = \\begin{pmatrix}\n\t131 &amp; 673 &amp; 234\n\t\\\\\n\t201 &amp; 96 &amp; 342\n\t\\\\\n\t630 &amp; 803 &amp; 746\n\\end{pmatrix}\\)\nWe also have another matrix $P$ where each element $p_{ij}$ is the minimum path sum of all paths in $M$ ending at the cell in row $i$ and column $j$. Since we only move right or down, the only paths that end in the top row are the ones that only move right.\n\n\\(\\begin{aligned}\n\tp_{12} &amp;= m_{11} + m_{12} = 131 + 673 = 804\n\t\\\\\n\tp_{13} &amp;= m_{11} + m_{12} + m_{13} = 131 + 673 + 234 = 1038\n\\end{aligned}\\)\nWe can make the same deduction of the first column. Our $P$ matrix is now\n\n[P = \\begin{pmatrix}\n\t131 &amp; 804 &amp; 1038 \n\t332 &amp; * &amp; * \n\t962 &amp; * &amp; *\n\\end{pmatrix}]\n\nFor $p_{22}$, all paths ending in the middle cell had to have come from the cell above or the cell to the left. But wait, we already calculated the minimum path sums for those cells! In that case, we need to add those cells and save whichever is smaller. In general,\n\n\\(p_{ij} = \\min\\begin{cases}p_{i-1,j}+m_{ij} \\\\ p_{i,j-1}+m_{ij}\\end{cases}\\)\nWe can quickly fill in $P$:\n\n\\(P = \\begin{pmatrix}\n\t131 &amp; 804 &amp; 1038 \\\\\n\t332 &amp; 428 &amp; 770 \\\\\n\t962 &amp; 1231 &amp; 1516\n\\end{pmatrix}\\)\nNotice that we are not saving the actual path as we go along, since the problem didn’t ask for that. Additionally, during coding, we can overwrite the additional matrix itself, since we only visit each cell once.\n# file: \"problem081.py\"\nwith open('p081_matrix.txt') as f:\n    matrix = [list(map(int, line.split(','))) for line in f.read().splitlines()]\n\nn = 80\n# First fill in cumulative sums on first row\n# and first column\nfor i in range(1, n):\n    matrix[0][i] += matrix[0][i - 1]\nfor i in range(1, n):\n    matrix[i][0] += matrix[i - 1][0]\n# Now update all the cells with the minimum sum\nfor i in range(1, len(matrix)):\n    for j in range(1, len(matrix[i])):\n        matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\nprint(matrix[-1][-1])\n\nRunning this results in an output of,\n427337\n0.005567600000000006 seconds.\n\nThus, the minimum sum in our 80 by 80 matrix is 427337.\n",
      "categories": ["project_euler"],
      "tags": ["10_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-23-081-Path-sum-two-ways/"
    },{
      
      "title": "#84 - Monopoly odds",
      "date": "2017-06-25 08:44:00 +0000",
      
      "content": "\n  In the game, Monopoly, the standard board is set up in the following way:\n\n  \n\n  Monopoly board\n\n  A player starts on the GO square and adds the scores on two 6-sided dice to determine the number of squares they advance in a clockwise direction. Without any further rules we would expect to visit each square with equal probability: 2.5%. However, landing on G2J (Go To Jail), CC (community chest), and CH (chance) changes this distribution.\n\n  In addition to G2J, and one card from each of CC and CH , that orders the player to go directly to jail, if a player rolls three consecutive doubles, they do not advance the result of their 3rd roll. Instead they proceed directly to jail.\n\n  At the beginning of the game,  the CC and CH cards are randomly shuffled. When a player lands on CC or CH they take a card from the top of the respective pile and, after following the instructions, it is returned to the bottom of the pile. There are sixteen cards in each pile, but for the purpose of this problem we are only concerned with cards that order a movement; any instruction not concerned with movement will be ignored and the player will remain on the CC/CH square.\n  \n    Community Chest (2/16 cards):\n      \n        Advance to GO\n        Go to JAIL\n      \n    \n    Chance (10/16 cards):\n      \n        Advance to GO\n        Go to JAIL\n        Go to C1\n        Go to E3\n        Go to H2\n        Go to R1\n        Go to next R (railway company)\n        Go to next R\n        Go to next U (utility company)\n        Go back 3 squares\n      \n    \n  \n\n  The heart of this problem concerns the likelihood of visiting a particular square. That is, the probability of finishing at that square after a roll. For this reason it should be clear that, with the exception of G2J for which the probability of finishing is zero, the CH squares will have the lowest probabilities, as 5/8 request a movement to another square, and it is the final square that the player finishes on that we are interested in. We shall make no distinction between “Just Visiting” and being to sent to JAIL, and we shall also ignore the rule about requiring a double to “get out of jail”, assuming they pay to get out on their next turn.\n\n  By starting on GO and numbering the squares sequentially from 00 to 39 we can concatenate these two-digit numbers to produce strings that correspond with sets of squares.\n\n  Statistically it can be shown that the three most popular squares, in order, are JAIL (6.24%) = Square 10, E3 (3.18%) = Square 24, and GO (3.09%) = Square 00. So these three most popular squares can be listed with the six-digit modal string: 102400.\n\n  If, instead of using two 6-sided dice, two 4-sided dice are used, find the six-digit modal string.\n\n\n\nWe will need to code up the rules of Monopoly no matter what. There isn’t too much to explain here, other than the calculation. To calculate the rates, we can simply run a simulation for a very large number of turns, and see the long-term probability. I’ve chosen to do 500,000 rolls, but it’s also possible it will converge earlier.\n# file: \"problem084.py\"\nspaces = np.array(['GO', 'A1', 'CC1', 'A2', 'T1', 'R1', 'B1', 'CH1',\n          'B2', 'B3', 'JAIL', 'C1', 'U1', 'C2', 'C3', 'R2',\n          'D1', 'CC2', 'D2', 'D3', 'FP', 'E1', 'CH2', 'E2',\n          'E3', 'R3', 'F1', 'F2', 'U2', 'F3', 'G2J', 'G1',\n          'G2', 'CC3', 'G3', 'R4', 'CH3', 'H1', 'T2', 'H2'])\n\n# Methods to find distance to nearest railroad and utility\n# For chance and community chest, I'm not rotating the deck\n# I'm simply taking a random but even then the distribution\n# is still similar\ndef nearestRail(currSquare, spaces=spaces):\n    # Get the railroad spaces\n    RRspaces, = np.where((spaces == 'R1') |\n                        (spaces == 'R2') |\n                         (spaces == 'R3') |\n                          (spaces == 'R4'))\n    # Add the index of the square if it\n    # wrapped around\n    RRspaces = np.append(RRspaces, len(spaces) + np.min(RRspaces))\n    # Subtract each square from current,\n    # smallest positive is the closest\n    dists = RRspaces - currSquare\n    return np.min(dists[dists &gt; 0])\ndef nearestUtility(currSquare, spaces=spaces):\n    # Get the utility spaces\n    Uspaces, = np.where((spaces == 'U1') |\n                        (spaces == 'U2'))\n    Uspaces = np.append(Uspaces, len(spaces) + np.min(Uspaces))\n    dists = Uspaces - currSquare\n    return np.min(dists[dists &gt; 0])\ndef drawCC(currSquare, spaces=spaces):\n    cardNum = np.random.randint(1, 17)\n    if cardNum == 1: # Advance to GO\n        return len(spaces) - currSquare\n    elif cardNum == 2: # Go to JAIL\n        jail = np.where(spaces == 'JAIL')[0][0]\n        dist = jail - currSquare\n        if dist &gt; 0:\n            return dist\n        return len(spaces) + dist\n    else: # Don't move from current\n        return 0\ndef drawCH(currSquare, spaces=spaces):\n    cardNum = np.random.randint(1, 17)\n    dests = ['GO', 'JAIL', 'C1', 'E3', 'H2', 'R1',\n             'RR', 'RR', 'U']\n    if cardNum &lt; 10:\n        spaceToGo = dests[cardNum - 1]\n        # Railroad or Utility\n        if cardNum == 7 or cardNum == 8:\n            return nearestRail(currSquare)\n        elif cardNum == 9:\n            return nearestUtility(currSquare)\n        spaceNum = np.where(spaces == spaceToGo)[0][0]\n        dist = spaceNum - currSquare\n        if dist &gt; 0:\n            return dist\n        return len(spaces) + dist\n    elif cardNum == 10: # Go back 3 spaces\n        return len(spaces) - 3\n    else:\n        return 0\ncounts = np.zeros(len(spaces))\ndiceSize = 4\ncurrSpace = 0\ndoublesInARow = 0\nrounds = 500000\nfor _ in range(rounds):\n    roll1 = np.random.randint(1, diceSize+1)\n    roll2 = np.random.randint(1, diceSize+1)\n    if roll1 == roll2:\n        doublesInARow += 1\n        if doublesInARow == 3: # Go straight to JAIL\n            currSpace = 10\n            doublesInARow = 0\n            continue\n    else:\n        doublesInARow = 0\n    toMove = roll1 + roll2\n    currSpace = (currSpace + toMove) % len(spaces)\n    # Check if you're on Chance or Community Chest or Go to Jail\n    if spaces[currSpace] == 'CH1' or spaces[currSpace] == 'CH2' or spaces[currSpace] == 'CH3':\n        currSpace = (currSpace + drawCH(currSpace)) % len(spaces)\n    elif spaces[currSpace] == 'CC1' or spaces[currSpace] == 'CC2' or spaces[currSpace] == 'CC3':\n        currSpace = (currSpace + drawCC(currSpace)) % len(spaces)\n    elif spaces[currSpace] == 'G2J': # JAIL = 10\n        currSpace = 10\n    # Add to a count\n    counts[currSpace] += 1\n# Get the 3 largest probabilities\nfirst = np.argmax(counts)\n# Set that to negative infinity\ncounts[first] = float('-inf')\nsecond = np.argmax(counts)\ncounts[second] = float('-inf')\nthird = np.argmax(counts)\n\nprint(str(first).zfill(2) + str(second).zfill(2) + str(third).zfill(2))\n\nRunnning thsi long code, we get our model string to be,\n101524\n31.810585500000002 seconds.\n\nThus, JAIL is still the most popular, but now Pennsylvania Railroad and Illinois Avenue come in 2nd and 3rd probability.\n",
      "categories": ["project_euler"],
      "tags": ["35_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-25-084-Monopoly-odds/"
    },{
      
      "title": "#85 - Counting rectangles",
      "date": "2017-06-25 08:54:00 +0000",
      
      "content": "\n  By counting carefully it can be seen that a rectangular grid measuring 3 by 2 contains eighteen rectangles:\n\n  \n\n  Although there exists no rectangular grid that contains exactly two million rectangles, find the area of the grid with the nearest solution.\n\n\n\nThe image shows an approach on how we count the rectangles. We are taking each possible size of the “sub-rectangles”, and counting how many there are. In this case, a 2 by 1 rectangle is different than a 1 by 2 rectangle.\n\nGiven a grid size $m\\times n$, for each possible “sub-rectangle” of dimension $i\\times j$, we’ll count how many these rectangles are contained in the larger grid. We can fit $m-i+1$ rectangles lengthwise, and $n-j+1$ rectangles widthwise before we run out of room on each side. In total, that means there are $(m-i+1)(n-j+1)$ sub-rectangles of dimension $i\\times j$ that can be fit in an $m\\times n$ grid. Now we have to sum over all possible values $i$ and $j$. They both grow up till the original grid size. If $R(m,n)$ is the number of rectangles, then\n\n\\(R(m,n) = \\sum_{i=1}^m\\sum_{j=1}^n (m-i+1)(n-j+1)\\)\nLet’s simplify this expression a bit more. Notice that each product only depends on one of the variables, and not both at the same time. That means we can convert this sum of products into a product of sums. AFter a little alegbra, we have,\n\n\\(\\begin{aligned}\n\tR(m,n) &amp;= \\sum_{i=1}^m\\sum_{j=1}^n(m-i+1)(n-j+1)\n\t\\\\ &amp;=\n\t\\left(\\sum_{i=1}^m (m-i+1)\\right)\n\t\t\\left(\\sum_{j=1}^n (n-j+1)\\right)\n\t\\\\ &amp;=\n\t\\left(\\sum_{i=1}^m(m+1) - \\sum_{i=1}^m i\\right)\n\t\t\\left(\\sum_{j=1}^n(n+1) - \\sum_{j=1}^n j\\right)\n\t\\\\ &amp;=\n\t\\left(m(m+1) - \\frac{m(m+1)}{2}\\right)\n\t\t\\left(n(n+1) - \\frac{n(n+1)}{2}\\right)\n\t\\\\ &amp;=\n\t\\left(\\frac{m(m+1)}{2}\\right)\\left(\\frac{n(n+1)}{2}\\right)\n\t\\\\ &amp;=\n\t\\boxed{\\frac{mn(m+1)(n+1)}{4}}\n\\end{aligned}\\)\nWe now have a direct formula for the number of rectangles in a grid. We can either keep increasing the maximum size and break until we find our solution, or we can set an upper limit and hope it’s\nsmaller. I went with the latter, and had $m$ go until 100.\n# file: \"problem085.py\"\nminDist = float('inf')\ntarget = 2000000\narea = 0\nbestM = 0\nbestN = 0\nfor m in range(1, 101):\n    for n in range(1, m+1):\n        rects = m * n * (m + 1) * (n + 1) // 4\n        if math.fabs(rects - target) &lt; minDist:\n            minDist = math.fabs(rects - target)\n            area = m * n\n            bestM = m\n            bestN = n\nrects = bestM * bestN * (bestM + 1) * (bestN + 1) // 4\nprint('The grid is {} x {} (Area = {}) with {} rectangles.'.format(bestM, bestN, area, rects))\n\nRunning this code, we get an output of,\nThe grid is 77 x 36 (Area = 2772) with 1999998 rectangles.\n0.0024605999999999795 seconds.\n\nThus, a $77\\times 36$ grid has the closest to 2 million rectangles, and its area is 2772.\n",
      "categories": ["project_euler"],
      "tags": ["15_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-25-085-Counting-rectangles/"
    },{
      
      "title": "#101 - Optimum polynomial",
      "date": "2017-06-29 16:59:00 +0000",
      
      "content": "\n  If we are presented with the first $k$ terms of a sequence it is impossible to say with certainty the value of the next term, as there are infinitely many polynomial functions that can model the sequence.\n\n  As an example, let us consider the sequence of cube numbers. This is defined by the generating function, $u_n=n^3: 1,8,27,64,125,216,\\dots$.\n\n  Suppose we were only given the first two terms of this sequence. Working on the principle that “simple is best” we should assume a linear relationship and predict the next term to be 15 (common difference 7). Even if we were presented with the first three terms, by the same principle of simplicity, a quadratic relationship should be assumed.\n\n\n\n  We shall define $OP(k,n)$ to be the $n^{\\text{th}}$ term of the optimum polynomial generating function for the first $k$ terms of a sequence. It should be clear that $OP(k,n)$ will accurately generate the terms of the sequence for $n\\leq k$, and potentially the first incorrect term ($FIT$) will be $OP(k,k+1)$; in which case we shall call it a bad OP ($BOP$).\n\n  As a basis, if we were only given the first term of a sequence, it would be most sensible to assume constancy; that is, for $n\\geq 2, OP(1,n)=u_1$.\n\n  Hence we obtain the following $OP$s for the cubic sequence:\n\n  \n    \n      \n        Optimum Polynomial\n        Sequence\n      \n    \n    \n      \n        $OP(1,n)=1$\n        $1,\\color{red}1\\color{black},1,\\dots$\n      \n      \n        $OP(2,n)=7n-6$\n        $1,8,\\color{red}15\\color{black},\\dots$\n      \n      \n        $OP(3,n)=6n^2-11n+6$\n        $1,8,27,\\color{red}{58}\\color{black},\\dots$\n      \n      \n        $OP(4,n)=n^3$\n        $1,8,27,64,125,\\dots$\n      \n    \n  \n\n  Clearly no $BOP$s exist for $k\\geq 4$.\n\n  By considering the sum of $FIT$s generated by the $BOP$s (indicated in red above), we obatin 1 + 15 + 58 = 74.\n\n  Consider the following tenth degree polynomial generating function:\n\n\\[u_n=1-n+n^2-n^3+n^4-n^5+n^6-n^7+n^8-n^9+n^{10}\\]\n\n  Find the sum of $FIT$s for the $BOP$s.\n\n\n\nThe entire problem revolves around how we find the polynomial function given a sequence of numbers?\nThe mentioning of “common difference” in the problem statement. Essentially, we keep taking the difference between consecutive terms in the sequence, until we are left with a common difference. Let the number of times we take the difference be $t$, and the difference itself be $d$. Then, the coefficient of the $n^t$ term in our $OP$ is $\\frac{d}{t!}$.\n\nSome intuition as to why this is the case. Taking the difference between terms amounts to finding the rate of change in our sequence. In calculus, this can equivalent to a derivative. Going further, taking the difference $t$ times amounts to taking the $t^{\\text{th}}$ derivative. Recall from calculus that the derivative of $x^t$ is $tx^{t-1}$. The second derivative is $t(t-1)x^{t-2}$, and so on. The $t^{\\text{th}}$ derivative will be $t!$, as the exponent to the $x$ term will be zeroed out. We offset this constant in our term, as well as multiply the actual difference we see.\n\nOnce we’ve calculated this term, we subtract it off from our original sequence, and repeat the process to find the next coefficient one degree down. We keep repeating until the sequence is all 0s.\nExample\nLet’s say our sequence was 6, 22, 70, 168, 334. The first step is to keep taking differences until we end with a constant difference.\n\n  1st difference: 16, 48, 98, 166\n  2nd difference: 32, 50, 68\n  3rd difference: 18, 18\n\n\nIt took 3 differences until we reached a common difference of 18. Therefore, this means we have an $n^3$ term in our sequence, and its coefficient is $\\frac{18}{3!}=\\frac{18}{6} = 3$. Next, we subtract off $3n^3$ from the original sequence and repeat the process.\n\nSubtracted off, we have ${6,22,70,168,334}-{3,24,81,192,375}={3,-2,-11,-24,-41}$.\n\n  1st difference: -5, -9, -13, -17\n  2nd difference: -4, -4, -4\n\n\nOur common difference occurred at the 2nd level and is $-4$, so this means the next term is $$\\frac{-4}{2!}n^2=\\frac{-4}{2}n^2 = -2n^2$.\n\nSubtracting it off results in a sequence of 5, 6, 7, 8, 9. We see immediately that the comman difference is 1, so the next term is $n$. Subtracting off one final time we have a sequence of all 4s, which means the last term is just 4. Together, the polynomial is $\\mathbf{3n^3-2n^2+n+4}$.\nBack to the problem…\nNow you’ve seen how we can find the polynomial function. Since this was defined for $k$ terms, we plug in the value $k+1$ and chances are it differs from the sequence. Since the long tenth degree polynomial has a term for each degree, the value will at $k+1$ will be the first incorrect term.\n\nI calculate the coefficients iteratively with the aid of the numpy package.\n# file: \"problem101.py\"\ndef kPoly(sequence):\n    coeffs = []\n    if len(sequence) == 1 and sequence[0] == 0:\n        coeffs = [[0, 0]]\n    # Until we've subtracted off everything...\n    while not all(sequence == 0):\n        subSeq = sequence\n        step = 0\n        # Until we have a common difference\n        while not all(subSeq == subSeq[0]):\n            # Take difference between consecutive terms...\n            subSeq = np.diff(subSeq)\n            step += 1\n        coeffs.append([subSeq[0] / math.factorial(step), step])\n        # Subtract off...\n        sequence -= coeffs[-1][0] * np.arange(1, len(sequence) + 1) ** step\n    # Return coefficients\n    return np.array(coeffs)\n\n# BOPs won't exist for k &gt; n where n is the degree\n# So generate something like the first 12 terms of the sequence\ns = 0\nseq = np.arange(1, 13, dtype=float)\nseq = 1 - seq + seq ** 2 - seq ** 3 + seq ** 4 - seq ** 5 + seq ** 6 - seq ** 7 + seq ** 8 - seq ** 9 + seq ** 10\n# seq = seq ** 3\nfor k in range(1, 11):\n    subSeq = np.copy(seq[:k])\n    coeffs = kPoly(subSeq)\n    # Find the first element which is different\n    fit = np.sum(coeffs[:, 0] * ((k+1) ** coeffs[:, 1]))\n    s += fit\nprint(int(s))\n\nThe output is,\n37076114526\n0.008661100000000033 seconds.\n\nThus, the sum of all $FIT$s is 37076114526.\n",
      "categories": ["project_euler"],
      "tags": ["35_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-29-101-Optimum-polynomial/"
    },{
      
      "title": "#94 - Almost equilateral triangles",
      "date": "2017-06-30 12:58:00 +0000",
      
      "content": "\n  It is easily proved that no equilateral triangle exists with integral length sides and integral area. However, the almost equilateral triangle 5-5-6 has an area of 12 square units.\n\n  We shall define an almost equilateral triangle to be a triangle for which two sides are equal and the third differs by no more than one unit.\n\n  Find the sum of the perimeters of all almost equilateral triangles with integral side lengths and area and whose perimeters do not exceed one billion (1,000,000,000).\n\n\n\nThe first question we will tackle is when does an almost equilateral triangle have integral area? From the description, it is clear that almost equilateral triangles are simply isosceles triangles. Finding the area of an isosceles triangle is straightforward. Let $x$ be the base, and $y$ be the two sides that are equal. If you drop a straight line to the base in an isosceles triangle, then it is perpendicular to the base.\n\n\nThe area of our triangle is $\\frac{1}{2}x\\sqrt{y^2-(x/2)^2}$. This is an integer when $x$ is even and $y^2-(x/2)^2$ is a perfect square. Put another way, if $h$ is our height, it means that $\\mathbf{(x/2, h, y)}$ is a Pythagorean triple.\n\nIncluding our original condition that $x-y = \\pm1$, this means that the triples need to have the property that twice the smallest side differs from the hypotenuse by one. Why the smallest side? Because the right triangle that is formed by cutting the isosceles in half has the shorter leg corresponding to our base of the original.\n\nThe triples will also be primitive. As we scale up a triple, the difference between them is also scaled i.e. (3, 4, 5) follows our property ($3\\times 2 = 6 = 5+1$), but (6, 8, 10) will not, as the difference becomes 2.\n\nTo loop through primitive triples, we use the matrices that were first introduced in #39 - Integer right triangles. They have been reproduced below:\n\n\\(A=\\begin{bmatrix}\n\t1 &amp; -2 &amp; 2 \\\\\n\t2 &amp; -1 &amp; 2 \\\\\n\t2 &amp; -2 &amp; 3\n\\end{bmatrix}\n\\\\\nB=\\begin{bmatrix}\n\t1 &amp; 2 &amp; 2 \\\\\n\t2 &amp; 1 &amp; 2 \\\\\n\t2 &amp; 2 &amp; 3\n\\end{bmatrix}\n\\\\\nC=\\begin{bmatrix}\n\t-1 &amp; 2 &amp; 2 \\\\\n\t-2 &amp; 1 &amp; 2 \\\\\n\t-2 &amp; 2 &amp; 3\n\\end{bmatrix}\\)\nAt each step, you have a choice of 3 matrices to multiply by, and this results in a tree structure.\n\n\nExamining the tree, there are only 4 triples that satisfy our desired property:\n\n  $(3,4,5)\\rightarrow 3\\times 2-5 = 1$\n  $(15,8,17)\\rightarrow 8\\times 2 - 17 = -1$\n  $(33,56,65)\\rightarrow 33\\times 2 - 65 = 1$\n  $(209,120,241)\\rightarrow 120\\times 2 - 241 = -1$\n\n\nFollowing the tree, it appears we are alterating multiplying by $A$ and $C$. This is simple to code, as numpy provides us with vector-matrix multiplication.\n# file: \"problem094.py\"\nA = np.array([[1, -2, 2], [2, -1, 2], [2, -2, 3]])\nC = np.array([[-1, 2, 2], [-2, 1, 2], [-2, 2, 3]])\ntriple = np.array([3, 4, 5])\nPsums = 0\nswitch = 0  # We need to alternate multiplying A and C, starting with C\nwhile np.sum(triple) &lt;= 1000000000:\n    perim = 2 * np.max(triple) + 2 * np.min(triple)\n    # We don't know which one is the minimum,\n    # so multiply the two numbers which aren't\n    # the hypotenuse. We have x/2 so no need to\n    # explicitly divide by 2.\n    area = np.prod(triple[triple != np.max(triple)])\n    if not switch:\n        triple = np.dot(C, triple)  # Multiply by C\n        switch = 1\n    else:\n        triple = np.dot(A, triple)  # Multiply by A\n        switch = 0\n    Psums += perim\nprint(Psums)\n\nRunning this short loop, we get\n518408346\n0.0014765999999999946 seconds.\n\nTherefore, our final sum of the perimeters is 518408346.\n",
      "categories": ["project_euler"],
      "tags": ["35_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-06-30-094-Almost-equilateral-triangles/"
    },{
      
      "title": "#78 - Coin partitions",
      "date": "2017-07-05 14:32:00 +0000",
      
      "content": "\n  Let $p(n)$ represent the number of different ways in which $n$ coins can be separated into piles. for example, five coins can be separated into piles in exactly seven different ways, so $p(5)=7$.\n\n\\[\\bigcirc\\bigcirc\\bigcirc\\bigcirc\\bigcirc\n\\\\\n\\bigcirc\\bigcirc\\bigcirc\\bigcirc\\quad\\bigcirc\n\\\\\n\\bigcirc\\bigcirc\\bigcirc\\quad\\bigcirc\\bigcirc\n\\\\\n\\bigcirc\\bigcirc\\bigcirc\\quad\\bigcirc\\quad\\bigcirc\n\\\\\n\\bigcirc\\bigcirc\\quad\\bigcirc\\bigcirc\\quad\\bigcirc\n\\\\\n\\bigcirc\\bigcirc\\quad\\bigcirc\\quad\\bigcirc\\quad\\bigcirc\n\\\\\n\\bigcirc\\quad\\bigcirc\\quad\\bigcirc\\quad\\bigcirc\\quad\\bigcirc\\]\n\n  Find the least value of $n$ for which $p(n)$ is divisible by one million.\n\n\n\nThis is actually the same problem as #76 - Counting summations, just worded differently. This time, we are counting all the coins as “one pile”. Regardless, we can use the same method for generating $p(n)$. We now have to append to a partition list, and our stopping condition is different.\n\nSince we are checking when $p(n)$ is divisible by one million, we check when $p(n)\\equiv 0\\mod 1000000$. Modulus distributes through sums, so we do not keep the potentially large values of $p(n)$ as we go along, and instead store $p(n)\\mod 1000000$.\n# file: \"problem078.py\"\npartitions = [1]\npent = lambda x: x * (3 * x - 1) // 2\nn = 1\nwhile partitions[-1] != 0:\n    k = 1\n    currP = 0\n    pentk = pent(k)\n    while pentk &lt;= n:\n        currP = (currP + partitions[n - pentk] * (-1) ** (k + 1)) % 1000000\n        # If k is positive, then it turns into\n        # its negative counterpart,\n        # Otherwise, it goes to the next number\n        if k &gt; 0:\n            k *= -1\n        else:\n            k = k * -1 + 1\n        pentk = pent(k)\n    # Append...\n    partitions.append(currP)\n    n += 1\n\nprint('n =', len(partitions) - 1, 'is when p(n) is divisible by 1000000.')\n\nThe output is,\nn = 55374 is when p(n) is divisible by 1000000.\n16.1984474 seconds.\n\nThus, 55374 coins is the fewest number needed. As opposed to a list, we could have also stored a set that maps the coins to the number of piles, for quick look up.\n",
      "categories": ["project_euler"],
      "tags": ["30_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-07-05-078-Coin-partitions/"
    },{
      
      "title": "#121 - Disc game prize fund",
      "date": "2017-07-06 10:16:00 +0000",
      
      "content": "\n  A bag contains one red disc and one blue disc. In a game of chance a player takes a disc at random and its colour is noted. After each turn the disc is returned to the bag, an extra red disc is added, and another disc is taken at random.\n\n  The player pays £1 to play and wins if they have taken more blue discs than red discs at the end of the game.\n\n  If the game is played for four turns, the probability of a player winning is exactly 11/120, and so the maximum prize fund the banker should allocate for winning in this game would be £10 before they would expect to incur a loss. Note that any payout will be a whole number of pounds and also includes the original £1 paid to play the game, so in the example given the player actually wins £9.\n\n  Find the maximum prize fund that should be allocated to a single game in which fifteen turns are played.\n\n\n\nThe key takeaway is that since we are adding a red disc each turn, the probability of drawing a blue disc decreases each turn.\n\nTo find the maximum prize fund, we need to find the probability of winning game, or the probability of drawing 8 or more blue discs in the 15 turns. If the probability stayed constant each time, then this a binomial distribution. If the probability of drawing a blue disc was $p$ at each turn, then the probability of drawing 8 blue discs out of 15 tries is\n\n\\(P(8\\text{ blue discs}) = \\binom{15}{8}p^8(1-p)^7\\)\nThe binomial coefficient arises because you can draw the 8 discs in different ways i.e. drawing them in your first 8 tries vs. drawing in last 8 tries. Since each turn is independent, we multiply $p$ 8 times, and $1-p$ 7 times.\n\nHowever, $p$ is different depending on the turn in our case. Drawing a blue disc in your first 8 turns have a different probability than drawing in the last 8 turns. Thus, we loop through each of the $\\binom{15}{8}$ possibilities and calculate the probability of drawing 8 blue discs. Each possibility is mutually exclusive, so we add the results in the end.\n\nWe then need to find the greatest amount of money that can be allocated to be still seen as a win from the casino’s eyes, or a loser from the player’s eyes. Since the player pays £1 to play, the max amount $M$ such that $MP&lt;1 \\Rightarrow M &lt; \\frac{1}{P}$, where $P$ is the probability of winning the game.\n\nTo loop through each blue disc progression, we use itertools.combinations with the included parameter being the number of blue discs we draw. Yielding the order allows for on the fly generation.\n# file: \"problem121.py\"\ndef kDiscsFromN(n, k):\n    for blues in combinations(range(n), k):\n        order = ['R'] * n\n        for blue in blues:\n            order[blue] = 'B'\n        yield ''.join(order)\n\nN = 15\nbluesToWin = N // 2 + 1\n# Calculate the win probability\nwinProb = 0\nfor blues in range(bluesToWin, N + 1):\n    for progression in kDiscsFromN(N, blues):\n        progProb = 1\n        numOfDiscs = 2\n        for disc in progression:\n            if disc == 'B':\n                progProb *= (1 / numOfDiscs)\n            else:\n                progProb *= ((numOfDiscs - 1) / numOfDiscs)\n            numOfDiscs += 1\n        winProb += progProb\n\nprint('Win Probability:', winProb)\nprint('Max win amount possible before loss:', int(1 / winProb))\n\nRunning the code gives us,\nWin Probability: 0.00044063946502124476\nMax win amount possible before loss: 2269\n0.146565 seconds.\n\nThus, the maximum amount that can be allocated for a 15-turn game is £2269.\n",
      "categories": ["project_euler"],
      "tags": ["35_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-07-06-121-Disc-game-prize-fund/"
    },{
      
      "title": "#123 - Prime square remainders",
      "date": "2017-07-06 11:03:00 +0000",
      
      "content": "\n  Let $p_n$ be the $n^{\\text{th}}$ prime: 2, 3, 5, 7, 11, …, and let $r$ be the remainder when $(p_n-1)^n + (p_n+1)^n$ is divided by $p_n^2$.\n\n  For example, when $n=3$, $p_3=5$, and $4^3 + 6^3 = 280 \\equiv 5\\mod 25$.\n\n  The least value of $n$ for which the remainder first exceeds $10^9$ is 7037.\n\n  Find the least value of $n$ for which the remainder first exceeds $10^{10}$.\n\n\n\nThis is a straightforward problem. The numbers will start to get large beacuse they are raised to the power $n$, so it will be inefficient to directly calculate this value. Instead, we can use the modular approach we first saw in #48 - Self-powers. Outside of that, we just loop up until we get the satisfied value. I use the primesieve package once again.\n# file: \"problem0123.py\"\ndef mod(a, b, c):\n    bbinary = '{0:b}'.format(b)\n    modPowers = np.zeros(len(bbinary), dtype=object)\n    # Calculate a^k mod c for all powers &lt; b\n    modPowers[0] = a % c  # a^1 mod c\n    for i in range(1, len(modPowers)):\n        modPowers[i] = (modPowers[i - 1] * modPowers[i - 1]) % c\n    # Filter out the powers we don't need and multiply them\n    return np.prod(modPowers[[x == '1' for x in bbinary[::-1]]]) % c\n\n# The first p_n that exceeds 100,000 is n = 9593\nn = 9593\nwhile True:\n    prime = nth_prime(n)\n    r = ((mod(prime - 1, n, prime ** 2) + mod(prime + 1, n, prime ** 2)) % prime ** 2)\n    if r &gt; 10 ** 10:\n        print(r)\n        print(n)\n        print(prime)\n        break\n    n += 1\n\nRunning this short program get us,\n10001595590\n21035\n237737\n1.0571725 seconds.\n\nThus, the least value for which we get a remainder above ten billion is the 21035th prime, which is 237737.\n",
      "categories": ["project_euler"],
      "tags": ["30_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-07-06-123-Prime-square-remainders/"
    },{
      
      "title": "#102 - Triangle containment",
      "date": "2017-07-06 14:47:00 +0000",
      
      "content": "\n  Three distinct points are plotted at random on a Cartesian plane, for which $-1000\\leq x,y\\leq 1000$, such that a triangle is formed.\n\n  Consider the following two triangles:\n\n\\[A(-340, 495), B(-153, -910), C(835, -947)\n\\\\\nX(-175, 41), Y(-421, -714), Z(574, -645)\\]\n\n  It can be verified that triangle $ABC$ contains the origin, whereas triangle $XYZ$ does not.\n\n  Using triangles.txt (right click and ‘Save Link/Target As…’), a 27K text file containing the coordinates of one thousand “random” triangles, find the number of triangles for which the interior contains the origin.\n\n  The first two examples in the file represent the triangles in the example given above.\n\n\n\nThe core question is When is the origin contained inside of a triangle? Some googling leads to the structure of barycentric coordinates.\n\nIn the Barycentric coordinate system, we put a weight $\\lambda_i$ for each vertex $i$ of the triangle. Each point $(x,y)$ in the Cartesian plane is a weighted average of the three points of the triangle.\n\nIntuitively, if the weights for a point $(x,y)$ are all between 0 and 1, then $(x,y)$ would be inside the triangle. Conversely, if any of these weights are greater than 1 or negative, then the point lies outside the triangle.\n\nThe conversion section gives a quick formula for calculating two of the weights $\\lambda_i$. Since the weights need to sum to 1, the last weight is easily calculated given two of them.\n\nIf our triangle points are $\\mathbf{r_1}=\\langle x_1,y_1\\rangle, \\mathbf{r_2}=\\langle x_2,y_2\\rangle, \\mathbf{r_3}=\\langle x_3, y_3\\rangle$, the point we are testing is $\\mathbf{r}=\\langle x, y\\rangle$, then we create a 2 by 2 matrix\n\n\\(\\mathbf{T}=\\begin{bmatrix}\n\tx_1-x_3 &amp; x_2-x_3 \\\\\n\ty_1-y_3 &amp; y_2-y_3\n\\end{bmatrix}\\)\nand then, by taking the inverse, we can find two of the weights:\n\n\\(\\begin{bmatrix}\n\t\\lambda_1 \\\\ \\lambda_2\n\\end{bmatrix} = \\mathbf{T}^{-1}(\\mathbf{r}-\\mathbf{r_3})\\)\nThe last weight is $\\lambda_3 = 1-\\lambda_1-\\lambda_2$.\n\nWe can do vector-matrix multiplication with the numpy package. In our case, the test point is $\\mathbf{r}=\\langle 0, 0\\rangle$ so we end up multiplying by $-\\mathbf{r_3}$.\n# file: \"problem102.py\"\nwith open('p102_triangles.txt') as f:\n    triangles = np.reshape([line.split(',')\n                            for line in f.read().splitlines()],\n                           (-1, 3, 2)).astype(int)\n\nnumOfTriangles = 0\nr = np.zeros(2, dtype=int)\nfor triangle in triangles:\n    r1 = triangle[0]\n    r2 = triangle[1]\n    r3 = triangle[2]\n    T = np.array([[r1[0] - r3[0], r2[0] - r3[0]],\n                  [r1[1] - r3[1], r2[1] - r3[1]]])\n    Lam = np.dot(np.linalg.inv(T), r - r3)\n    l1 = Lam[0]\n    l2 = Lam[1]\n    l3 = 1 - l1 - l2\n    if l1 &gt; 0 and l2 &gt; 0 and l3 &gt; 0:\n        numOfTriangles += 1\n\nprint(numOfTriangles)\n\nRunning this short code, we get\n228\n0.04480099999999998 seconds.\n\nThus, there are 228 triangles that contain the origin.\n",
      "categories": ["project_euler"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-07-06-102-Triangle-containment/"
    },{
      
      "title": "#114 - Counting block combinations I",
      "date": "2017-07-27 16:35:00 +0000",
      
      "content": "\n  A row measuring seven units in length has red blocks with a minimum length of three units placed on it, such that any two red blocks (which are allowed to be different lengths) are separated by at least one grey square. There are exactly seventeen ways of doing this.\n\n  \n\n  How many ways can a row measuring fifty units in length be filled?\n\n  Although the example does not lend itself to the possibility, in general it is permitted to mix block sizes. For example, on a row measuring eight units in length you could use red (3), grey (1), and red (4).\n\n\n\nThis type of problem screams dynamic programming. Why DP? If you were to go about this normally, you first place one red block somewhere on the row. Of the black units remaining, how many ways can you put red blocks on the remaining black tiles? This is where it would be handy if you had the previous value to look up.\n\nHow about configurations that are symmetric (such as the red (3), gray (1), and red (3) above)? To avoid double counting, we will only worry about the number of ways of placing blocks in the black tiles to the left of the placed red block.\n\nTo summarize,\n\n  Choose a red block length $\\ell_r$. Let the length of the row be $n$.\n  Slide the red block across the row until the end. This is exactly $n-\\ell_r + 1$ steps.\n  For each position $i$ (0-indexed), take the number of valid black tiles to the left, and look up how many ways are there for that amount of tiles to be filled. Under this problem, there needs to be a gap of one, so the number of valid tiles is $i-1$. We also need to add 1 to count the configuration of all black tiles\n\n\nOur dynamic programming equation is,\n\n\\(F(n) = \\begin{cases}\n\t1 &amp; n &lt; 3\n\t\\\\\n\t\\displaystyle\\sum_{r=3}^n\\sum_{i=0}^{n-r}F(n-1) + 1 &amp; n \\geq 3\n\\end{cases}\\)\nAgain, I’m using numpy’s advanced indexing features.\n# file: \"problem114.py\"\ntargetN = 50\nnVals = np.zeros(targetN+2, dtype=np.int64)\n# -1,0,1,2 are all 1\nnVals[0] = 1\n# Start from n = 3, and find values up to target\nfor n in range(0, targetN+1):\n    configs = 0\n    # From the smallest red block (3) to the largest\n    # (n), move it across and find the number of\n    # configurations you can put in the remaining\n    # usable black blocks\n    for redSize in range(3, n+1):\n        blackSizes = np.arange(-1, n - redSize)\n        # Sum the values at those locations\n        # Add 1\n        configs += np.sum(nVals[blackSizes + 1])\n    # Add 1 to final count because of all black\n    nVals[n + 1] = configs + 1\n\nprint(nVals[-1])\n\nRunning this short loop results in,\n16475640049\n0.022253200000000084 seconds.\n\nThus, there are 16475640049 ways to fill a row measuring 50 units long.\n",
      "categories": ["project_euler"],
      "tags": ["35_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-07-27-114-Counting-block-combinations-I/"
    },{
      
      "title": "#115 - Counting block combinations II",
      "date": "2017-07-28 00:00:00 +0000",
      
      "content": "\n  This is a much more difficult version of #114 - Counting block combinations I\n\n  A row measuring $n$ units in length has red blocks with a minimum length of $m$ units placed on it, such that any two red blocks (which are allowed to be different lengths) are separated by at least one black square.\n\n  Let the fill-count function, $F(m,n)$, represent the number of ways that a row can be filled.\n\n  For example, $F(3,29) = 673135$ and $F(3, 30) = 1089155$.\n\n  That is, for $m=3$, it can be seen that $n=30$ is the smallest value for which the fill-count function first exceeds one-million.\n\n  In the same way, for $m=10$, it can be verified that $F(10, 56) = 880711$ and $F(10, 57) = 1148904$, so $n=57$ is the least value for which the fill-count function first exceeds one million.\n\n  For $m=50$, find the least value of $n$ for which the fill-count function first exceeds one million.\n\n\n\nThe only difference between this problem and #114 - Counting block combinations I is the addition of the minimum block size. In 114, we used a minimum red block size of 3, but here they are asking for 50. In terms of code, we only change the line where we test each possible red block size. Additionally, we now need to keep calculating until we have an amount of one million.\n# file: \"problem115.py\"\nnVals = np.array([], dtype=np.uint64)\n# -1,0,1,2 are all 1\nnVals = np.append(nVals, 0)\n# Start from n = 0, and find values up to target\nn = 0\nminRedBlockSize = 50\nwhile nVals[-1] &lt; 1000000:\n    configs = 0\n    # From the smallest red block (50) to the largest\n    # (n), move it across and find the number of\n    # configurations you can put in the remaining\n    # usable black blocks\n    for redSize in range(minRedBlockSize, n+1):\n        blackSizes = np.arange(-1, n - redSize)\n        # Sum the values at those locations\n        # Add 1\n        configs += np.sum(nVals[blackSizes + 1])\n    # Add 1 to final count because of all black\n    nVals = np.append(nVals, configs + 1)\n    n += 1\n\nprint(n-2)\nprint(int(nVals[-1]))\n\nRunning, we get\n168\n1053389\n0.0759726 seconds.\n\nThus, we need a minimum row length of 168 units before we exceed one million ways to fill it.\n",
      "categories": ["project_euler"],
      "tags": ["35_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-07-28-115-Counting-block-combinations-II/"
    },{
      
      "title": "#116 - Red, green or blue tiles",
      "date": "2017-07-28 10:20:00 +0000",
      
      "content": "\n  A row of five grey square tiles is to have a number of its replaced with coloured oblong tiles chosen from red (length two), green (length three), or blue (length four).\n\n  If red tiles are chosen there are exactly seven ways this can be done.\n\n  \n\n  If green tiles are chosen there are three ways.\n\n  \n\n  And if blue tiles are chosen there are two ways.\n\n  \n\n  Assuming that colours cannot be mixed there are 7 + 3 + 2 = 12 ways of replacing the grey tiles in a row measuring five units in length.\n\n  How many different ways can the grey tiles in a row measuring fifty units in length be replaced if colours cannot be mixed and at least one coloured tile must be used?\n\n  This is related to #117 - Red, green, and blue tiles\n\n\n\nThis is also related to both #114 - Counting block combinations I and #115 - Counting block combinations II. Unlike those problems, we should not include the configuration of all black tiles. Additionally, each colored tile is a specific length.\n\nSince the tiles can’t mix, this actually makes things relatively simple. We keep three separate arrays, one for each color. Since the tiles are constant lengths, we slide it along and calculate the ways to fill the remaining black tiles to the left. In summary, our code is very similar to both 114 and 115 with some slight modifications.\n# file: \"problem116.py\"\ntargetN = 50\n# Red, blue, and green tiles can't be mixed\n# so create three separate arrays\n# No space of at least one so smallest value is n = 0\n# Order is red, green, blue. The size would be the index + 2\ncoloredTiles = np.zeros((3, targetN+1), dtype=np.uint64)\ncoloredTiles[:, :2] = 1\n# Use dynamic programming to find\n# the number for each n of each color\nfor n in range(2, targetN+1):\n    for i in range(len(coloredTiles)):\n        size = i + 2\n        blackSpaceLeft = np.arange(n - size + 1)\n        coloredTiles[i, n] = np.sum(coloredTiles[i, blackSpaceLeft]) + 1\n\n# Subtract 3 to remove the all-black config\n# axis=0 means to sum column by column.\ntotalTiles = np.sum(coloredTiles, axis=0) - 3\nprint(totalTiles[-1])\n\nRunning this code results in an output of,\n20492570929\n0.003920800000000002 seconds.\n\nThus, if mixing colors are prohibited, then there are 20492570929 ways to fill a row that is 50 units long.\n",
      "categories": ["project_euler"],
      "tags": ["30_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-07-28-116-Red-green-or-blue-tiles/"
    },{
      
      "title": "#117 - Red, green and blue tiles",
      "date": "2017-07-28 10:36:00 +0000",
      
      "content": "\n  Using a combination of grey square tiles and oblong tiles chosen from: red tiles (measuring two units), green tiles (measuring three tiles), and blue tiles (measuring four tiles), it is possible to tile a row measuring five units in length in exactly fifteen different ways.\n\n  \n\n  How many ways can a row measuring fifty units in length be tiled?\n\n  This is related to #116 - Red, green or blue tiles\n\n\n\nSince the red block is the smallest we have at 2 units, and the largest is the blue tile at 4 units, it is essentially like #114 - Counting block combinations I where the minimum tile length is 2 and the maximum tile length is 4. One pickle is that there should be no gaps between the tiles. However, this is accounted for by controlling the remaining black tiles for placement. The same concept of dynamic programming applies.\n\nFor the code, notice the blackSize = np.arange(n - blockSize + 1) line. Previously, we had it start at -1, because of how the problem of “one gap required” was set up. Now, our array actually starts at 0.\n# file: \"problem117.py\"\ntargetN = 50\nnVals = np.zeros(targetN+1, dtype=np.int64)\n# 0 is 1\nnVals[0] = 1\n# Start from n = 0, and find values up to target\nfor n in range(0, targetN+1):\n    configs = 0\n    # From the smallest red block (2) to the largest\n    # (4), move it across and find the number of\n    # configurations you can put in the remaining\n    # usable black blocks\n    for blockSize in range(2, 5):\n        blackSizes = np.arange(n - blockSize + 1)\n        # Sum the values at those locations\n        # Add 1\n        configs += np.sum(nVals[blackSizes])\n    # Add 1 to final count because of all black\n    nVals[n] = configs + 1\n\nprint(nVals[-1])\n\nRunning this code, we get\n100808458960497\n0.0025583000000000133 seconds.\n\nTherefore, we have 100808458960497 ways of tiling a row 50 units in length.\n",
      "categories": ["project_euler"],
      "tags": ["35_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-07-28-117-Red-green-and-blue-tiles/"
    },{
      
      "title": "#151 - Paper sheets of standard sizes: an expected-value problem",
      "date": "2017-08-01 10:02:00 +0000",
      
      "content": "\n  A printing shop runs 16 batches (jobs) every week and each batch requires a sheet of special colour-proofing paper of size A5.\n\n  Every Monday morning, the supervisor opens a new envelope, containing a large sheet of the special paper with size A1.\n\n  The supervisor proceeds to cut it in half, thus getting two sheets of size A2. Then one of the sheets is cut in half to get two sheets of size A3 and so on until an A5-size sheet is obtained, which is needed for the first batch of the week.\n\n  All the unused sheets are placed back in the envelope.\n\n  \n\n  At the beginning of each subsequent batch, the supervisor takes from the envelope one sheet of paper at random. If it is of size A5, then it is used. If it is larger, then the ‘cut-in-half’ procedure is repeated until an A5-size sheet is obtained, and any remaining sheets are always placed back in the envelope.\n\n  Excluding the first and last batch of the week, find the expected number of times (during each week) that the supervisor finds a single sheet of paper in the envelope.\n\n  Give your answer rounded to six decimal places using the format x.xxxxxx .\n\n\n\nFrom the problem, it should be rare that we find just one piece of paper inside, since we keep cutting in half each time. The quickest way to solve this problem would be a form of brute force. We model all the possible selection paths we can take over the course of the week. For each path, we keep track of the total probability of the path, and the number of times we encountered a single piece of paper. Since these paths are mutually exclusive, we add all probabilities at the end to get the answer.\n\nEach time we cut up a piece of paper, the lower sizes will each go up by one. The A4 produces two A5 pieces, but we use one of them. The probability of selecting a certain size is the count of that size divided by the total number of pieces.\n\nAll the states will be stored in one large array, and grows each time with each batch. The state will be represented by 6 numbers. The first 4 are the counts of each size A2 through A5. The 5th number is the probability of encountering at the state at the end of all the batches so far. The last number is the number of times we encountered a single piece of paper during the week.\n# file: \"problem151.py\"\nstates = np.array([[1, 1, 1, 1, 1, 0]], dtype=float)  # 4 states, prob, whether or not the path had 1 paper\n\nbatches = 16\ntotalLeaves = 0\nfor currBatch in range(2, batches):\n    numberOfNextStates = np.count_nonzero(states[:, :4])\n    nextStates = np.empty((numberOfNextStates, 6), dtype=float)\n    i = 0\n    for state in states:\n        # Calculate the probabilities of choosing each size\n        papProbs = state[:4] / np.sum(state[:4])\n        for papInd in range(4):\n            # Skip the sizes which don't have pieces\n            if state[papInd] == 0:\n                continue\n            nextStates[i] = state\n            # Cut up the paper, that count goes down by 1\n            nextStates[i, papInd] -= 1\n            # Each of the lower sizes increases by 1\n            nextStates[i, papInd + 1:4] += 1\n            # Multiply the previous state's probability by the probability\n            # of choosing this size\n            nextStates[i, 4] = papProbs[papInd] * state[4]\n            # Copy the encounter flag from last time\n            nextStates[i, 5] = state[5]\n            # If this isn't the last batch and we encountered a single sheet,\n            # then increment the counter\n            if currBatch &lt; 15 and (np.sum(nextStates[i, :4]) == 1):\n                nextStates[i, 5] += 1\n            i += 1\n    states = nextStates\n    totalLeaves += len(nextStates)\n\n# Take all the paths which are True and add up those probs\nexpectation = np.sum(states[:, 4] * states[:, 5])\nprint('The expected value is', expectation)\n\nRunning this nested loop, we get\nThe expected value is 0.464398781601087\n2.0471511000000002 seconds.\n\nPutting it in the format required by the problem, the expected value is 0.464399.\n",
      "categories": ["project_euler"],
      "tags": ["50_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-08-01-151-Paper-sheets-expected-value/"
    },{
      
      "title": "#158 - Exploring strings for which only one character comes lexicographically after its neighbour to the left",
      "date": "2017-08-01 15:31:00 +0000",
      
      "content": "\n  Taking three different letters from the 26 letters of the alphabet, character strings of length three can be formed.\n\n  Examples are ‘abc’, ‘hat’ and ‘zyx’.\n\n  When we study these three examples we see that for ‘abc’ two characters come lexicographically after its neighbour to the left. For ‘hat’ there is exactly one character that comes lexicographically after its neighbour to the left. For ‘zyx’ there are zero characters that come lexicographically after its neighbour to the left.\n\n  In all there are 10400 strings of length 3 for which exactly one character comes lexicographically after its neighbour to the left.\n\n  We now consider strings of $n\\leq 26$ different characters from the alphabet. For every $n$, $p(n)$ is the number of strings of length of $n$ for which exactly one character comes lexicographically after its neighbour to the left.\n\n  What is the maximum value of $p(n)$?\n\n\n\nThis is a counting problem. To put their restriction another way, there is only one pair of letters which are in order This also tells us that the substrings on either side of the pair are in decreasing order.\n\nFor example, with 5 letters: $c, t, m, r, d$, a satisfying string is $tmcrd$. The pair in order is $cr$, and both $tmc$ and $rd$ are in decreasing order.\n\nGiven a group of $n$ letters, we can find a formula for the number of strings satisfying the property $c(n)$. This is not $p(n)$, as that value takes all possible groups. We will aggregate later.\n\nFinding a formula for $c(n)$\nLet’s assume our group of $n$ letters be the first $n$ letters of the alphabet. There are some trivial values for the lower values of $n$:\n\n  $c(0) = c(1) = 0$, because it is impossible to order anything lower than 2 letters.\n  $c(2) = 1$, as the pair is either in order, or out of order.\n  $c(3) = 4$. Those strings are $abc$, $acb$, $bca$, and $bac$.\n  $c(4)=11$. We have a couple of cases here for where $d$ can be placed.\n    \n      We can prepend $d$ to all the satisfactory string and get 4 new satisfactory strings: $dabc$, $dacb$, $dbca$, $dbac$.\n      If $d$ is in position 2, the 1st letter needs to be less than $d$. All of $a$, $b$, and $c$ are, so this produces 3 new strings: $adcb$, $bdca$, $cdba$\n      If $d$ is in position 3, then the first two letters need to be in reversed order. We can choose 2 letters from the 3 in 3 ways to produce 3 strings: $badc$, $cadb$, $cbad$.\n      If $d$ is last, then the first 3 letters need to be reversed, of which there is only 1: $cbad$.\nPlease work through $c(5)$ to get a feel for the pattern. For a given $n$:\n    \n  \n  Prepend the $n^{\\text{th}}$ letter to each of the strings previously. This is $c(n-1)$.\n  For the $i^{\\text{th}}$ position i the string ($i\\geq 2$), the $i-1$ letters before it need to be reversed. We can choose the letters from the remaining group a total of $\\binom{n-1}{i-1}$ ways, and produces as many strings.\n  Repeat for all $i$ and add up all values (from 2 to $n$).\n\n\nIn conclusion,\n\n\\(\\begin{aligned}\nc(n) &amp;= \\binom{n-1}{1}+\\binom{n-1}{2}+\\cdots+\\binom{n-1}{n}+c(n-1) \n\\\\ &amp;= \\sum_{i=1}^n\\binom{n-1}{i}+c(n-1) \n\\\\ &amp;= \\boxed{2^{n-1}-1+c(n-1)}\n\\end{aligned}\\)\nFinding a formula for $p(n)$\nNow that we have $c(n)$, finding a formula for $p(n)$ is actually simple. Although we demonstrated with the first $n$ letters, the group of letters actually does not matter for the value of $c(n)$. The value of $p(n)$ takes into account the value of $c(n)$ for all groups of $n$ letters. There are $\\binom{26}{n}$ different groups. Therefore,\n\n\\(p(n)=\\binom{26}{n}c(n)\\)\nImplementation\nThe recursive nature of $c(n)$ allows us to precompute values of $c(n)$ beforehand. We create an array of values of $p(n)$ and check the maximum afterwards. I use the math.factorial to compute the binomial coefficient.\n# file: \"problem158.py\"\ndef binom(n, r):\n    return math.factorial(n) / (math.factorial(r) * math.factorial(n - r))\n\nvalues = [0]\nfor n in range(1, 27):\n    values.append(2 ** (n - 1) - 1 + values[-1])\n# Now multiply each by 26 choose n\nvalues = [int(value * binom(26, i)) for i, value in enumerate(values)]\nprint('Max value of', np.max(values), 'at n =', np.argmax(values))\n\nRunning our loop get us,\nMax value of 409511334375 at n = 18\n0.0015439999988302588 seconds.\n\nTherefore, the maximum value of $p(n)$ is 409511334375.\n",
      "categories": ["project_euler"],
      "tags": ["55_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-08-01-158-Exploring-lexicographic-pairs/"
    },{
      
      "title": "#72 - Counting fractions",
      "date": "2017-08-04 12:13:00 +0000",
      
      "content": "\n  Consider the fraction, $n/d$, where $n$ and $d$ are positive integers. If $n&lt;d$ and $HCF(n,d)=1$, it is called a reduced proper fraction.\n\n  If we list the set of reduced proper fractions for $d\\leq 8$ in ascending order of size, we get:\n\n\\[\\frac{1}{8},\\frac{1}{7},\\frac{1}{6},\\frac{1}{5},\\frac{1}{4},\\frac{2}{7},\\frac{1}{3},\\frac{3}{8},\\mathbf{\\frac{2}{5}}, \\frac{3}{7},\\frac{1}{2},\\frac{4}{7},\\frac{3}{5},\\frac{5}{8},\\frac{2}{3},\\frac{5}{7},\\frac{3}{4},\\frac{4}{5},\\frac{5}{6},\\frac{6}{7},\\frac{7}{8}\\]\n\n  It can be seen that there are 21 elements in this set.\n\n  How many elements would be contained in the set of reduced proper functions for $d\\leq 1\\,000\\,000$?\n\n\n\nThis is the same setup as #71 - Ordered fractions, but we have to now count the fractions. A fraction is in the list if the fraction is reduced, or when the numerator $n$ and denominator $d$ have no common factors, or that $n$ and $d$ are coprime.\n\nSo now we need to count how many numbers are prime to a given denominator $d$. But this Euler’s totient function $\\phi(n)$ which was introduced in #69 - Totient maximum. We can use the exact method of calculating the totients, and simply sum them all.\n# file: \"problem072.py\"\nlimit = 10 ** 6\ntotients = np.ones((limit + 1, 2), dtype=object)\nfor n in range(2, limit + 1):\n    if totients[n, 0] and totients[n, 1] != 1:\n        continue\n    totients[np.arange(n, limit + 1, n)] *= [n - 1, n]\n\ntotientValues = np.arange(limit + 1) * totients[:, 0] // totients[:, 1]\nprint(np.sum(totientValues[2:]))\n\nRunning this gives an output of,\n303963552391\n2.6249155 seconds.\n\nThus, there are a total of 303963552391 fractions in the set.\n",
      "categories": ["project_euler"],
      "tags": ["20_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-08-04-072-Counting-fractions/"
    },{
      
      "title": "#73 - Counting fractions in a range",
      "date": "2017-08-04 14:52:00 +0000",
      
      "content": "\n  Consider the fraction, $n/d$, where $n$ and $d$ are positive integers. If $n&lt;d$ and $HCF(n,d)=1$, it is called a reduced proper fraction.\n\n  If we list the set of reduced proper fractions for $d\\leq 8$ in ascending order of size, we get:\n\n\\[\\frac{1}{8},\\frac{1}{7},\\frac{1}{6},\\frac{1}{5},\\frac{1}{4},\\frac{2}{7},\\frac{1}{3},\\mathbf{\\frac{3}{8}},\\mathbf{\\frac{2}{5}}, \\mathbf{\\frac{3}{7}},\\frac{1}{2},\\frac{4}{7},\\frac{3}{5},\\frac{5}{8},\\frac{2}{3},\\frac{5}{7},\\frac{3}{4},\\frac{4}{5},\\frac{5}{6},\\frac{6}{7},\\frac{7}{8}\\]\n\n  It can be seen that there are 3 fractions between $1/3$ and $1/2$.\n\n  How many fractions lie between $1/3$ and $1/2$ in the sorted set of reduced proper fractions for $d\\leq12000$?\n\n\n\nThe “set of reduced proper fractions” has a name called the Farey sequence. The link also shows how to generate the fractions in order given two consecutive fractions in the sequence.\n\nParaphrasing the article, if we have two consecutive fractions $a/b$ and $c/d$, then the next fraction is $p/q$ where\n\n\\(\\begin{aligned}\n\tp &amp;= \\lfloor \\frac{n + b}{d} \\rfloor c - a\n\t\\\\\n\tq &amp;= \\lfloor \\frac{n + b}{d} \\rfloor d - b\n\\end{aligned}\\)\nWe already have one of the fractions we start with, namely $1/3$, but we need the fraction immediately to its left. But we’ve done that already in #71 - Ordered fractions. All we need to do is slightly adapt, then continue generating the next fraction until we hit $1/2$.\n\nI’ve created a general function following #71’s logic to find the fraction immediately to the left of $a/b$, given the maximum denominator.\n# file: \"problem073.py\"\ndef findClosestFraction(n, a, b):\n    minDist = float('inf')\n    bestNum = 0\n    bestDenom = 1\n    for denom in range(3, n):\n        # Skip multiples of b\n        if denom % b == 0:\n            continue\n        # Calculate closest\n        num = a * denom // b\n        dist = a/b - num/denom\n        if dist &lt; minDist:\n            minDist = dist\n            bestNum = num\n            bestDenom = denom\n    return bestNum, bestDenom\n\nn = 12000\na, b = findClosestFraction(n, 1, 3)\n\ncount = 0\nc, d = 1, 3\nwhile c/d != 1/2:\n    k = (n + b) // d\n    a, b, c, d = c, d, k * c - a, k * d - b\n    count += 1\n\nprint(count - 1)\n\nRunning this code gives us,\n7295372\n2.8874196000397205 seconds.\n\nTherefore, when $d=12000$, we have 7295372 fractions between $1/3$ and $1/2$.\n",
      "categories": ["project_euler"],
      "tags": ["15_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-08-04-073-Counting-fractions-in-range/"
    },{
      
      "title": "#225 - Tribonacci non-divisors",
      "date": "2017-08-08 09:52:00 +0000",
      
      "content": "\n  The sequence 1, 1, 1, 3, 5, 9, 17, 31, 57, 105, 193, 355, 653, 1201 … is defined by $T_1=1, T_2=1, T_3=1$ and $T_n=T_{n-1}+T_{n-2}+T_{n-3}$.\n\n  It can be shown that 27 does not divide any terms of this sequence. In fact, 27 is the first odd number with this property.\n\n  Find the 124th odd number that does not divide any number of this sequence.\n\n\n\nIf $a$ is divisible by $b$, then $a\\equiv 0\\mod b$. This sequence is very closely related to the Fibonacci series, which adds only the previous two. On the subject of Fibonacci numbers and modular arithmetic, there is the Pisano period. If you were to take $F_n\\mod k$ for any integer $k$, then eventually the sequences of remainders will repeat. The length of this repeating sequence (a.k.a period) is the Pisano period.\n\nSince the Tribonacci series is built the same way, we will get the same repeating sequence. So when we test to see if a number divides the sequence, we only need to test the values in the period.\n\nWhen does the sequence repeat. The first 3 values are all ones, which are less than any number we test. Therefore, the modular of this will still be 1. After the first 3 ones, if we encounter 3 ones again, then the sequence has repeated.\n\nIf we encounter a 0 anywhere in the sequence, then we stop checking and move to the next odd number.\n# file: \"problem225.py\"\noddNums = 0\nn = 27\nwhile oddNums &lt; 124:\n    vals = [1,1,1,3]\n    while vals[-3:] != [1,1,1] and vals[-1] != 0:\n        vals.append(sum(vals[-3:]) % n)\n    # Check if it's 111 or 0\n    if vals[-1] != 0:\n        oddNums += 1\n    n += 2\n# We went two over, so subtract 2...\nprint(n - 2)\n\nRunning our loop, we get\n2009\n2.212874299963005 seconds.\n\nTherefore, the 124th odd number is 2009.\n",
      "categories": ["project_euler"],
      "tags": ["45_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-08-08-225-Tribonacci-non-divisors/"
    },{
      
      "title": "#63 - Powerful digit counts",
      "date": "2017-08-08 12:09:00 +0000",
      
      "content": "\n  The 5-digit number, $16807=7^5$, is also a fifth power. Similarly, the 9-digit number, $134\\,217\\,728=8^9$, is a ninth power.\n\n  How many $n$-digit positive integers exist which are also an $n$th power?\n\n\n\nFirst, we need to find some bounds for the solution to this problem. An $n$th power $a^n$ can only be an $n$-digit number if\n\n\\(10^{n-1}&lt;a^n&lt;10^n\\)\nWe immediately see that $a&lt;10$. For $n$, we can solve for it using the left half of the inequality:\n\n[\\begin{aligned}\n10^{n-1} &amp;&lt; a^n\n\n\\log_{10}\\left(10^{n-1}\\right) &amp;&lt; \\log_{10}\\left(a^n\\right)\n\nn-1 &amp;&lt; n\\log_{10}a\n\nn-n\\log_{10}a &amp;&lt; 1\n\nn &amp;&lt; \\frac{1}{1-\\log_{10}a}\n\\end{aligned}]\n\nThe last expression is our upper bound for a given $a$. To check the length, the easiset way is to convert the number to a string.\n# file: \"problem063.py\"\ncount = 0\nfor a in range(2, 10):\n    n = 1\n    # Bound for the power\n    while n &lt;= 1/(1 - math.log10(a)):\n        if len(str(a ** n)) == n:\n            count += 1\n        n += 1\n\nprint(count + 1) # for 1 ^ 1 = 1\n\nRunning this short gets an answer immediately,\n49\n7.499998901039362e-05 seconds.\n\nThus, there are 49 $n$-digit integers that are also $n$th powers.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-08-08-063-Powerful-digit-counts/"
    },{
      
      "title": "#144 - Investigating multiple reflections of a laser beam",
      "date": "2017-08-17 03:38:00 +0000",
      
      "content": "\n  In laser physics, a “white cell” is a mirror system that acts as a delay line for the laser beam. The beam enters the cell, bounces around on the mirrors, and eventually works its way back out.\n\n  The specific white cell we will be considering is an ellipse with the equation $4x^2+y^2=100$.\n\n  The section corresponding to $-0.01\\leq x\\leq 0.01$ at the top is missing, allowing the light to enter and exit through the hole.\n\n   \n\n  The light beam in this problem starts at the point (0.0, 10.1) just outside the white cell, and the beam first impacts the mirror at (1.4, -9.6).\n\n  Each time the laser beam hits the surface of the ellipse, it follows the usual law of reflection “angle of incidence equals angle of reflection.” That is, both the incident and reflected beams make the same angle with the normal line at the point of incidence.\n\n  In the figure on the left, the red line shows the first two points of contact between the laser beam and the wall of the white cell; the blue line shows the line tangent to the ellipse at the point of incidence of the first bounce.\n\n  The slope $m$ of the tangent line at any point $(x,y)$ of the given ellipse is: $m=-4x/y$.\n\n  The normal line is perpendicular to this tangent line at the point of incidence.\n\n  The animation on the right shows the first 10 reflections of the beam.\n\n  How many times does the beam hit the internal surface of the white cell before exiting?\n\n\n\nOne term I’ll define: The normal line at a point on the ellipse is the line that is perpendicular to the line tangent to the point. This line will be heavily used, as the laser beam will be reflected across this line. The slopes of two lines that are perpendicular to each other are negative reciprocals of each other.\n\nTwo points make a line. A vector and a point also make a line. Since the first two points are given to us, and we know the slope of the normal line, we can reflect the incident laser beam across this line. The reflected laser beam will be pointing in the direction of the next point.\n\n  Find vector associated with incident laser beam.\n  Find the normal vector using the slope of the normal line and the reflection point.\n  Reflect the incident vector across the normal vector to get the reflected vector.\n  Find the equation of the reflected line, and find the other intersection point with the ellipse.\n\n\nTo reflect a vector across another vector, this Math StackExchange answer provides an explanation to the formulas required. If $\\mathbf{d}$ is the incident vector and $\\hat{\\mathbf{n}}$ is the normalized normal vector, then the reflection vector $\\mathbf{r}$ is given by\n\n[\\mathbf{r} = \\mathbf{d} - 2(\\mathbf{d}\\cdot\\hat{\\mathbf{n}})\\hat{\\mathbf{n}}]\n\nwhere we use the dot product. Next, we need to find the point where the reflected laser point bounces off of.\nFinding the next point\nWe need the previous two reflection points $(x_0,y_0)$ and $(x_1,y_1)$. Initially, we have $(x_0,y_0) = (0.0, 10.1)$ and $(x_1, y_1)=(1.4,-9.6)$. The vector associated with this line is $\\mathbf{v} = \\langle x_1-x_0, y_1-y_0 \\rangle$.\nThe normal vector\nNext, we need the vector that is normal to the tangent line. Since the slope of the tangent line is $-4x/y$, the slope of the normal line is $y/4x$. Converting to a vector, we have $\\mathbf{n}=\\langle 4x,y\\rangle$. For reflection calculations, we need to normalize this: $\\hat{\\mathbf{n}}=\\frac{\\mathbf{n}}{\\left\\lVert \\mathbf{n} \\right\\rVert}$.\nThe intersection point\nThe reflected vector is $\\mathbf{r} = \\mathbf{v} - 2(\\mathbf{v}\\cdot\\hat{\\mathbf{n}})\\hat{\\mathbf{n}}$. We now convert this vector into its corresponding line equation, so that we can set this equal to the ellipse equation and solve for 2 intersection point. One of these will be the points we just reflected from. We can write the line equation in point-slope form, like so:\n\n[y=m_r(x-x_1)+y_1]\n\nwhere $m_r=\\frac{r_2}{r_1}$.\n\nWe can plug this into the ellipse equation for $y$ directly and with some algebra, we have\n\n[\\begin{aligned}\n\t4x^2+y^2 &amp;= 100\n\t\n\t4x^2 + \\left(m_r(x-x_1) + y_1\\right)^2 &amp;= 100\n\t\n\t4x^2 + m_r^2(x-x_1)^2 + 2m_r(x-x_1)y_1 + y_1^2 &amp;= 100\n\t\n\t4x^2 + m_r^2x^2-2m_r^2xx_1+m_r^2x_1^2+2m_rxy_1-2m_rx_1y_1+y_1^2-100 &amp;= 0\n\t\n\tx^2\\left[4 + m_r^2\\right] + x\\left[2m_ry_1-2m_r^2x_1\\right] + \\left[m_r^2x_1^2 - 2m_rx_1y_1+y_1^2-100\\right] &amp;= 0\n\t\n\tx_2\\big[ 4+m_r^2 \\big] + x\\big[ 2m_r(y_1-m_rx_1) \\big] + \\big[ (m_rx_1-y_1)^2-100 \\big] &amp;= 0\n\\end{aligned}]\n\nAlthough messy, we have a quadratic equation in $ax^2+bx+c=0$ on the last line, where\n\n[\\begin{aligned}\n\ta &amp;= 4 + m_r^2\n\t\n\tb &amp;= 2m_r\\left(y_1-m_rx_1\\right)\n\t\n\tc &amp;= (m_r x_1 - y_1)^2 - 100\n\\end{aligned}]\n\nNow plugging into the quadratic formula\n\n[x = \\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}]\n\nwill output two $x$ values. One of these will be the point we just reflected off of, and so we need the other. There isn’t a way to tell which sign we should use, so we have to calculate both and choose. Once we’ve set our $x$, the value of $y$ is given by the normal line equation, and we have our point.\nImplementation\nThe code is just the steps I outlined above in code. To account for possible floating point errors from the square roots, divisions, etc., I used the np.isclose() function.\n# file: \"problem144.py\"\ndef getNextPoint(p0, p1):\n    v = p1 - p0\n    n = np.array([4 * p1[0], p1[1]])\n    n /= np.linalg.norm(n)\n    r = v - 2 * np.dot(v, n) * n\n    # Slope of the reflection line\n    m = r[1] / r[0]\n    # Quadratic coefficients\n    a = 4 + m ** 2\n    b = 2 * m * (p1[1] - m * p1[0])\n    c = (p1[0] * m - p1[1]) ** 2 - 100\n    # Calculate the two solutions...\n    sols = [(-b - (b * b - 4 * a * c) ** 0.5) / (2 * a), (-b + (b * b - 4 * a * c) ** 0.5) / (2 * a)]\n    # One of these is original point...\n    if np.isclose(sols[0], p1[0]):\n        xNew = sols[1]\n    else:\n        xNew = sols[0]\n    yNew = m * (xNew - p1[0]) + p1[1]\n    return np.array([xNew, yNew])\n\n\np0 = np.array([0, 10.1])\np1 = np.array([1.4, -9.6])\npNew = getNextPoint(p0, p1)\nbounces = 1\nwhile np.abs(pNew[0]) &gt; 0.01 or np.abs(10 - pNew[1]) &gt; 0.00002:\n    pNew = getNextPoint(p0, p1)\n    bounces += 1\n    p0 = p1\n    p1 = pNew\n\n# Due to the while statement, it counted the exit as a \"bounce\",\n# so subtract one...\nprint(f'The total number bounces inside the cell is {bounces - 1}')\n\nRunning, we have\nThe total number bounces inside the cell is 354.\n0.013191799982450902 seconds.\n\nTherefore, the laser beam bounces off the wall 354 times before it exits back through the hole at the top.\n",
      "categories": ["project_euler"],
      "tags": ["50_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-08-17-144-Multiple-laser-beam-reflections/"
    },{
      
      "title": "#100 - Arranged probability",
      "date": "2017-08-18 01:05:00 +0000",
      
      "content": "\n  If a box contains twenty-one coloured discs, composed of fifteen blue discs and six red discs, and two discs were taken at random, it can be seen that the probability of taking two blue discs $P(BB)=(15/21)\\times(14/20)=1/2$.\n\n  The next such arrangement, for which there is exactly 50% chance of taking two blue discs at random, is a box containing eighty-five blue discs and thirty-five red discs.\n\n  By finding the first arrangement to contain over $10^{12}=1\\,000\\,000\\,000\\,000$ discs in total, determine the number of blue discs that the box would contain.\n\n\n\nIf we have $n$ total discs and $b$ blue discs in the box (we don’t replace the first disc one we’ve taken it out), then the probability of taking 2 blue discs is\n\n[P(BB)=\\left(\\frac{b}{n}\\right)\\left(\\frac{b-1}{n-1}\\right)]\n\nWe want this to be $1/2$, so let’s set this equal and try to simplify:\n\n[\\begin{aligned}\n\t\\left(\\frac{b}{n}\\right)\\left(\\frac{b-1}{n-1}\\right) &amp;=\n\t\t\\frac{1}{2}\n\t\n\t\\frac{b^2-b}{n^2-n} &amp;= \\frac{1}{2}\n\t\n\t2b^2-2b &amp;= n^2-n\n\t\n\t2b^2-2b+n-n^2 &amp;= 0\n\\end{aligned}]\n\nWe have a quadratic in $b$, so apply the quadratic formula and solve it:\n\n[\\begin{aligned}\n\tb &amp;= \\frac{2\\pm\\sqrt{4-4(2)(n-n^2)}}{4}\n\t\\ &amp;=\n\t\\frac{2\\pm2\\sqrt{1-2n+2n^2}}{4}\n\t\\ &amp;=\n\t\\frac{1}{2}\\left(1 + \\sqrt{2n^2-2n+1}\\right)\n    \\ &amp;=\n    \\frac{1}{2}\\left(1 + \\sqrt{n^2+(n-1)^2}\\right)\n\\end{aligned}]\n\nSo this means the number of blue discs will only be an integer if $n^2+(n-1)^2$ is a perfect square. This is a sum of two squares which needs to equal another square, so another way to frame the restriction is that if $z=\\sqrt{n^2+(n-1)^2}$, then ${n, n-1, z}$ has to be a Pythagorean triple.\n\nLooking at the Tree of Pythagorean triples, repeatedly multiplying by the $B$ matrix will preserve the property that the two smaller sides are within one unit of each other.\n\n[B=\\begin{bmatrix}\n\t1 &amp; 2 &amp; 2 \n\t2 &amp; 1 &amp; 2 \n\t2 &amp; 2 &amp; 3\n\\end{bmatrix}]\n\nTha value of $n$ will be the larger of the two sides, which during the multiplication, will alternate being the first and second value (${3,4,5}\\rightarrow {21,20,29}\\rightarrow {119,120,169}\\rightarrow\\dots$). 85 blue discs is associated with $n=120$.\n\nBoth the alternation and the matrix multiplication are simple to code. We calculate $n$, then $b$.\n# file: \"problem100.py\"\nb = 15\nn = 21\nswitch = 0\nwhile n &lt; 10 ** 12:\n    n = 3 * n - 1 + 2 * (2 * b - 1)\n    if switch:\n        n -= 1\n    b = (int((2 * n ** 2 - 2 * n + 1) ** 0.5) + 1) // 2\n\nprint('b:', b)\nprint('n:', n)\n\nRunning our code, we get\nb: 756872327473\nn: 1070379110497\n0.00012419999999999792 seconds.\n\nThus, we have 756872327473 blue discs in the box when the number of total discs first surpasses $10^{12}$.\n",
      "categories": ["project_euler"],
      "tags": ["30_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-08-18-100-Arranged-probability/"
    },{
      
      "title": "#97 - Large non-Mersenne prime",
      "date": "2017-08-18 01:10:00 +0000",
      
      "content": "\n  The first known prime found to exceed one million digits was discovered in 1999, and is a Mersenne prime of the form $2^{6972593}-1$; it contains exactly 2,098,960 digits. Subsequently other Mersenne primes, of the form $2^p-1$, have been found which contain more digits.\n\n  However, in 2004 there was found a massive non-Mersenne prime which contains 2,357,207 digits: $28433\\times2^{7830457}+1$.\n\n  Find the last ten digits of this prime number.\n\n\n\nWe take the mod $10^{10}$ to find the last ten digits of a number. Calculate the number directly with Python:\n# file: \"problem097.py\"\nprint((28433 * 2 ** 7830457 + 1) % (10 ** 10))  # one line!!\n\nWe get an answer instantly,\n8739992577\n0.038738599978387356 seconds.\n\nTherefore, the last ten digits are 8739992577.\nAlternative method\nIf our language is unable to hold large numbers, then we will need to take an approach that was first demonstrated in #48 - Self-powers, where through the use of clever modular tricks, we calculate the value of\n\n\\(28433\\times2^{7830457}+1\\mod 10^{10}\\)\ndirectly. Please see that problem for implementation details. We would first calculate $2^{7830457}\\mod 10^{10}$ before multiplying and adding through.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-08-18-097-Large-non-Mersenne-prime/"
    },{
      
      "title": "#99 - Largest exponential",
      "date": "2017-08-18 01:40:00 +0000",
      
      "content": "\n  Comparing the two numbres written in index form like $2^{11}$ and $3^7$ is not difficult, as any calculator would confirm that $2^{11}=2048&lt;3^7=2187$.\n\n  However, confirming that $632382^{518061}&gt;519432^{525806}$ would be much more difficult, as both numbers contain over three million digits.\n\n  Using base_exp.txt (right click and ‘Save Link/Target As…’), a 22K text file containing one thousand lines with a base/exponent pair on each line, determine which line number has the greatest numerical value.\n\n  The first two lines in the file represent the numbers in the example given above.\n\n\n\nEven calculating all these large numbers in Python is not that efficient. We can take the logarithm of both sides, and retain the monotonicity of the exponentials. So if beforehand, $a^b &gt; c^d$, then $\\log a^b &gt; \\log c^d$. We can simplify this further with $b\\log a &gt; d\\log c$, which will be the condition we’ll check.\n# file: \"problem099.py\"\nexponents = np.genfromtxt(\n    'p099_base_exp.txt', delimiter=',', dtype=np.int64)\nlogs = exponents[:, 1] * np.log10(exponents[:, 0])\n# Now find the maximum argument and print its line\nindex = np.argmax(logs)\nprint(index + 1)\nprint(exponents[index].tolist())\n\nRunning this short code results in an output,\n709\n[895447 504922]\n0.011759600000000037 seconds.\n\nThus, $895447^{504922}$ is the largest number in our list, and it happens at line 709.\n",
      "categories": ["project_euler"],
      "tags": ["10_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-08-18-099-Largest-exponential/"
    },{
      
      "title": "#205 - Dice Game",
      "date": "2017-08-25 01:29:00 +0000",
      
      "content": "\n  Peter has nine four-sided (pyramidal) dice, each with faces numbered 1, 2, 3, 4. Colin has six six-sided (cubic) dice, each with faces numbered 1, 2, 3, 4, 5, 6.\n\n  Peter and Colin roll the dice and compare totals: the highest total wins. The result is a draw if the totals are equal.\n\n  What is the probability that Pyramidal Peter beats Cubic Colin? Give your answer rounded to seven decimal places in the form 0.abcdefg\n\n\n\nWe can directly brute force this solution. The totals range from 9 to 36 for Peter, and 6 to 36 for Colin. We compute the probability of getting that total for each one. Since the totals are independent probabilities, then probability that they both happen is the product of the two. We loop through each pair, and we add the product, since the occurrences are mutually exclusive.\n\nI use defaultdict to automatically set a value of 0 for uninitialized values. We run a double for loop going through each possible pair of totals.\n# file: \"problem205.py\"\npyrProbs = defaultdict(float)\ncubeProbs = defaultdict(float)\n# There are 9 pyramids. Each configuration has\n# probability 1 / (4 ^ 9).\nnumberOfDice = 9\nprob = 1 / (4 ** numberOfDice)\nfor config in product(np.arange(1, 5), repeat=numberOfDice):\n    total = sum(config)\n    pyrProbs[total] += prob\n# Do the same for the cubes\nnumberOfDice = 6\nprob = 1 / (6 ** numberOfDice)\nfor config in product(np.arange(1, 7), repeat=numberOfDice):\n    total = sum(config)\n    cubeProbs[total] += prob\n\nwinProb = 0\n# Go through each value in the pyramid and the cube and add those\n# which win\nfor pyrSum, pyrProb in pyrProbs.items():\n    for cubeSum, cubeProb in cubeProbs.items():\n        if pyrSum &gt; cubeSum:\n            winProb += pyrProb * cubeProb\n\nprint(f'Peter beats Colin with a probability of {winProb:0.7f}.')\n\nWe got an output of,\nPeter beats Colin with a probability of 0.5731441.\n0.4863471 seconds.\n\nTherefore, the probability that Peter beats Colin is 0.5731441.\n",
      "categories": ["project_euler"],
      "tags": ["15_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2017-08-25-205-Dice-game/"
    },{
      
      "title": "104 - Pandigital Fibonacci ends",
      "date": "2018-05-18 16:51:00 +0000",
      
      "content": "\n  The Fibonacci sequence is defined by the recurrence relation:\n\n\\[F_n=F_{n-1}+F_{n-2}\n\\\\\nF_1=1\n\\\\\nF_2=1\\]\n\n  It turns out that $F_{541}$, which contains 113 digits, is the first Fibonacci number for which the last nine digits are 1-9 pandigital (contain all the digits 1 to 9, but not necessarily in order). And $F_{2749}$, which contains 575 digits, is the first Fibonacci number for which the first nine digits are 1-9 pandigital.\n\n  Given the $F_k$ is the first Fibonacci number for which the first nine digits AND the last nine digits are 1-9 pandigital, find $k$.\n\n\n\nWe do $n\\mod 10^d$ to get the last $d$ digits of a number. To find the first $d$ digits of a number after the first digit, we can do $\\lfloor n/10^d\\rfloor$. To get the actual first diigt, we need to do $\\log_{10}$, which gets us the number of digits minus one.Subtract this by 10, put it as the power, and we have a way to get the first $d$ digits of a number.\n\nFinding the leading digits of a number is generally a bit more expensive, so we’ll only perform that calculation if we have a 1-9 pandigital at the end. At each step, we perform $F_k\\mod 10^9$, and if we see a pandigital, we then perform $\\lfloor F_k/10^{\\lfloor \\log_{10}F_k\\rfloor - 8}\\rfloor$. To test whether a number is pandigital, we convert to a string, and the convert it to a set. We then compare it to the set of the digits 1-9. If they’re the same, then it’s pandigital.\n# file: \"problem104.py\"\na = 1\nb = 1\nk = 3\nnotFound = True\npandigital19 = set('123456789')\nwhile notFound:\n    c = a + b\n    lastNine = c % 1000000000\n    if set(str(lastNine)) == pandigital19:\n        # Only check the first 9 digits if the last 9 are okay.\n        # Check first 9 is more expensive.\n        firstNine = c // 10 ** (int(math.log(c, 10)) - 8)\n        if set(str(firstNine)) == pandigital19:\n            print('k = ' + str(k) + ' with ' + str(int(math.log(c, 10) + 1)) + ' digits.')\n            notFound = False\n    a = b\n    b = c\n    k += 1\n\nRunning our loop, we get\nk = 329468 with 68855 digits.\n7.580941600026563 seconds.\n\nThus, the 329468th Fibonacci number, with 68855 digits, has both a 1-9 pandigital at the beginning and end.\n",
      "categories": ["project_euler"],
      "tags": ["25_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2018-05-18-104-Pandigital-Fibonacci-ends/"
    },{
      
      "title": "#82 - Path sum: three ways",
      "date": "2018-05-27 09:30:00 +0000",
      
      "content": "\n  This problem is a more challenging version of #81 - Path sum: two ways\n\n  The minimal path sum in the 5 by 5 matrix below, by starting in any cell in the left column and finishing in any cell in the right column, and only moving up, down, and right, is indicated in red and bold; the sum is equal to 994.\n\n\\[\\begin{pmatrix}\n\t131 &amp; 673 &amp; \\color{red}{\\mathbf{234}} &amp; \\color{red}{\\mathbf{103}} &amp; \\color{red}{\\mathbf{18}}\n\t\\\\\n\t\\color{red}{\\mathbf{201}} &amp; \\color{red}{\\mathbf{96}} &amp; \n\t\t\\color{red}{\\mathbf{342}} &amp; 965 &amp; 150\n\t\\\\\n\t630 &amp; 803 &amp; 746 &amp; 422 &amp; 111\n\t\\\\\n\t537 &amp; 699 &amp; 497 &amp; 121 &amp; 956\n\t\\\\\n\t805 &amp; 732 &amp; 524 &amp; 37 &amp; 331\n\\end{pmatrix}\\]\n\n  Find the minimal path sum from the left column to the right column in matrix.txt (right click and “Save Link/Target As…”), a 31K text file containing an 80 by 80 matrix.\n\n\n\nThis is a proper step up from #81 - Path sum: two ways, because now we have an extra direction we have to worry about. However, we can still adapt the same concepts to this problem.\n\nSince we’re going column by column, we would update the cells in each colunm to reflect the minimum sum ending in that cell. There is no reason to move up or down when we get to the last column.\n\nTo compute the minimum cells in each column, we need another loop to go through all possible paths:\n\nBecause we have an extra direction, we are spending a quadratic amount of time in each column, which ultimately leads to a cubic algorithm. This makes intuitive sense, as the two-way problem had a quadratic solution.\n\nThe np.cumsum function can quickly calculate the vertical sums.\n\n# file: \"problem082.py\"\nmatrix = np.loadtxt('./p082_matrix.txt', dtype='int32', delimiter=',')\n\n# We start on the second column and find the minimum\n# sum going from any cell in the previous column to\n# that cell. We keep doing this for each column,\n# and finally simply add the number directly to\n# the right for the second to last column and take the min.\n\nfor j in range(1, matrix.shape[1] - 1):\n    minSums = np.zeros(matrix.shape[0], dtype='int32')\n    for i in range(matrix.shape[0]):\n        # Find min of all possible sums coming from the previous column\n        # When we come from the bottom (matrix[:i+1,j]) we need to reverse the array...\n        minSums[i] = np.min(np.append(np.cumsum(matrix[:i+1, j][::-1]) + matrix[:i+1, j-1][::-1],\n                                         np.cumsum(matrix[i:, j]) + matrix[i:, j-1]))\n\n    matrix[:, j] = minSums\n# Now just add the last two columns together and take\n# the minimum\nprint(np.min(matrix[:, -2] + matrix[:, -1]))\n\nRunning our loop results in an output of,\n260324\n0.6649046999999999 seconds.\n\nAnd so, our minimum sum from the left column to the right column is 260324.\n",
      "categories": ["project_euler"],
      "tags": ["20_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2018-05-27-082-Path-sum-three-ways/"
    },{
      
      "title": "#62 - Cubic permutations",
      "date": "2018-05-27 15:36:00 +0000",
      
      "content": "\n  The cube, $41063625 \\left(345^3\\right)$, can be permuted to produce two other cubes: $56623104 \\left(384^3\\right)$ and $66430125 \\left(405^3\\right)$. In fact, 41063625 is the smallest cube which has exactly three permutations of its digits which are also cube.\n\n  Find the smallest cube for which exactly five permutations of its digits are cube.\n\n\n\nNotice they didn’t give us any digit bounds. We keep increasing the number of digits, until we get a set of 5 permutations. For each number of digits $k$, we generate all cubes that have $k$ digits. Next, we sort each cube on its digits. One cube is a permutation of another if its sorted set of digits is exactly the same. Therefore, the thing we are looking for is the same sorted digit string appearing 5 times.\n\nDoing sorted(str()) will convert to a sorted string, and we can vectorize it so that it applies to every element in an array. The np.unique function can allow us to get the counts of each permutation.\n# file: \"problem062.py\"\nnDigs = 2\nfoundCube = False\n# The following function sorts the digits\n# of a number\nsortDigits = lambda x: \"\".join(sorted(str(x)))\n# Vectorize so it can be applied to each\n# element in one go.\nvectSortDigs = np.vectorize(sortDigits)\nwhile not foundCube:\n    # Find the upper and lower bound cube for these digits.\n    lower = int(10 ** ((nDigs - 1) / 3)) + 1\n    upper = int(10 ** (nDigs / 3))\n    # Form an array of numbers cubed\n    nums = np.arange(lower, upper + 1, dtype=np.uint64) ** 3\n    # Get the sorted list of digits for each number...\n    perms = vectSortDigs(nums)\n    # Get all unique permutations and their counts\n    uniques, counts = np.unique(perms, return_counts=True)\n    # We check here whether or not we got 5 perms\n    # Grab the index of the 5 perm, if it's not there\n    # it will throw an IndexError\n    try:\n        fivePerm = uniques[np.where(counts == 5)[0][0]]  # Will throw IndexError if it doesn't exist\n        origNums = nums[np.where(perms == fivePerm)[0]]\n        print('The five cubes are: ', origNums)\n        print('The cube roots are: ', origNums ** (1/3))\n        print(nDigs)\n        foundCube = True\n    except IndexError:\n        pass  # Skip, we didn't find a 5 set with this many digits...\n    nDigs += 1\n\n\nRunning the loop gets us an output of,\n\nThe five cubes are:  [127035954683 352045367981 373559126408 569310543872 589323567104]\nThe cube roots are:  [5027. 7061. 7202. 8288. 8384.]\n12 digits\n0.030961370484396847 seconds.\n\nTherefore, $5027^3, 7061^3, 7202^3, 8288^3$ and $8384^3$ are all permutations of each other, with the smallest being 127035954683.\n",
      "categories": ["project_euler"],
      "tags": ["15_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2018-05-27-062-Cubic-permutations/"
    },{
      
      "title": "#66 - Diophantine equation",
      "date": "2018-05-30 14:57:00 +0000",
      
      "content": "\n  Consider quadratic Diophantine equations of the form: $x^2-Dy^2=1$.\n\n  For example, when $D=13$, the minimal solution in $x$ is $649^2-13\\times 180^2 = 1$.\n\n  It can be assumed that there are no solutions in positive integers when $D$ is square.\n\n  By finding minimal solutions in $x$ for $D = {2,3,5,6,7}$, we obtain the following:\n\n\\[\\begin{aligned}\n3^2-2\\times2^2 &amp;= 1\n\\cr\n2^2-3\\times1^2 &amp;= 1\n\\cr\n\\color{red}{9}^2-5\\times4^2 &amp;= 1\n\\cr\n5^2-6\\times2^2 &amp;= 1\n\\cr\n8^2-7\\times3^2 &amp;= 1\n\\end{aligned}\\]\n\n  Hence, by considering minimal solutions in $x$ for $D\\leq 7$, the largest $x$ is obtained when $D=5$.\n\n  Find the value of $D\\leq 1000$ in minimal solutions of $x$ for which the largest value of $x$ is obtained.\n\n\n\nFor a fixed $D$ (non-square), there are an infinite number of integers pairs $(x,y)$ that satisfy the equation above. The question is asking us to find the smallest $x$ for each $D$, then report which $D$ has the largest “smallest” $x$ solution.\n\nA Diophantine equation is any polynomial equation where we only want integer solutions. This particular equation is known as Pell’s equation. The article lists many ways to solve it; we will use the following method:\n\n  Let $\\frac{h_i}{k_i}$ denote the sequence of convergents to the regular continued fraction for $\\sqrt{n}$. This sequence is unique. Then the pair $(x_1, y_1)$ solving Pell’s equation and minimizing $x$ satisfies $x_1 = h_i$ and $y_1 = k_i$ for some $i$.\nThe article uses $n$ instead of $D$. So to solve this, all we need to do is calculate the convergents of $\\sqrt{D}$ until we encounter a pair which solves the equation. This is guaranteed to be the pair that minimizes $x$. Both #64 - Odd period square roots and #65 - Convergents of $e$ deal with computing convergents of continued fractions. We can use those algorithms in this problem.\n\n\nI’ll have one method that returns the periodic coefficients of the continued fraction of $\\sqrt{D}$. Each solution pair is saved.\n# file: \"problem066.py\"\ndef periodCoeffs(S):\n    m = 0\n    d = 1\n    a0 = int(S ** 0.5)\n    coeffs = [a0]\n    a = a0\n    while a != 2 * a0:\n        m = d * a - m\n        d = (S - m ** 2) // d\n        a = int((a0 + m) / d)\n        coeffs.append(a)\n    return coeffs\n\n# Diophantine equations of the form x^2 - Dy^2 = 1 are\n# known as Pell's equations. As long as D is not square,\n# a solution always exists. The minimizing x solution\n# can be derived by testing successive convergents\n# of the continued fraction of sqrt(D). This is\n# what I'll be doing here.\n\nmaxD = 1000\nxySols = np.zeros((maxD, 3), dtype=object)\nxySols[:, -1] = np.arange(1, maxD+1)\n\nfor D in range(2, maxD + 1):\n    # If D is not a perfect square\n    sqrtD = D ** 0.5\n    if sqrtD != int(sqrtD):\n        # Find the coefficients of the\n        # continued fraction\n        aCo = periodCoeffs(D)\n        hP = aCo[0]\n        kP = 1\n        h = aCo[1] * hP + 1\n        k = aCo[1]\n        n = 2\n        while h ** 2 - D * k ** 2 != 1:\n            an = aCo[(n - 1) % (len(aCo) - 1) + 1]\n            temphP, tempkP = hP, kP\n            hP, kP = h, k\n            h = an * h + temphP\n            k = an * k + tempkP\n            n += 1\n        # We're here when a solution has been found.\n        # It has been proven that this solution minimizes x\n        xySols[D - 1, :2] = [h, k]\n        print('\\rD: ' + str(D) + '/' + str(maxD), end='')\nprint()\nmaxX = np.argmax(xySols[:, 0])\nprint('The max x occurs when D = {} with (x, y) = ({}, {}).'\n      .format(maxX + 1, xySols[maxX, 0], xySols[maxX, 1]))\n\nRunning the loop above results in an output of,\nD: 1000/1000\nThe max x occurs when D = 661 with (x, y) = (16421658242965910275055840472270471049, 638728478116949861246791167518480580).\n0.03699100005906075 seconds.\n\nThus, the largest minimal solution in $x$ occurs when $D=\\mathbf{661}$.\n",
      "categories": ["project_euler"],
      "tags": ["25_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2018-05-30-066-Diophantine-equation/"
    },{
      
      "title": "#125 - Palindromic sums",
      "date": "2018-06-01 09:51:00 +0000",
      
      "content": "\n  The palindromic number 595 is interesting because it can be written as the sum of consecutive squares: $6^2+7^2+8^2+9^2+10^2+11^2+12^2$.\n\n  There are exactly eleven palindromes below one-thousand that can be written as consecutive square sums, and the sum of these palindromes is 4164. Note that $1^2=0^2+1^2$ has not been included as this problem is concerned with the squares of positive integers.\n\n  Find the sum of all the numbers less than $10^8$ that are both palindromic and can be written as the sum of consecutive squares.\n\n\n\nWe can do a brute force solution, where we loop through all possible consecutive square sums. The maximum number in this sum will be $\\left(10^4\\right)^2$. If we encounter a palindrome sum, then we add to a running list. We can also cut off the sum if we exceed the limit. We also want to set() the final list, to get rid of duplicates.\n# file: \"problem125.py\"\nlimit = 10 ** 8\nsquareLim = int(limit ** 0.5)\ncumsumSquares = []\nfor i in range(1, squareLim + 1):\n    s = i ** 2\n    for j in range(i+1, squareLim + 1):\n        s += j ** 2\n        if s &gt; limit:\n            break\n        if str(s) == str(s)[::-1] and s not in cumsumSquares:\n            cumsumSquares.append(s)\nprint(sum(set(cumsumSquares)))\n\nRunning this short double for loop, we get\n2906969179\n0.49573599999999995 seconds.\n\nThus, the sum of all palindromes that can be written as a consecutive square sum is 2906969179.\n",
      "categories": ["project_euler"],
      "tags": ["25_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2018-06-01-125-Palindromic-sums/"
    },{
      
      "title": "#75 - Singular integer right triangles",
      "date": "2018-06-03 16:16:00 +0000",
      
      "content": "\n  It turns out that 12 cm is the smallest length of wire that can be bent to form an integer sided right angle triangle in exactly one way, but there are many more examples.\n\n\\[\\mathbf{12}\\textbf{ cm}: (3,4,5)\n\\\\\n\\mathbf{24}\\textbf{ cm}: (6,8,10)\n\\\\\n\\mathbf{30}\\textbf{ cm}: (5,12,13)\n\\\\\n\\mathbf{36}\\textbf{ cm}: (9,12,15)\n\\\\\n\\mathbf{40}\\textbf{ cm}: (8,15,17)\n\\\\\n\\mathbf{48}\\textbf{ cm}: (12,16,20)\\]\n\n  In contrast, some lengths of wire, like 20 cm, cannot be bent to form an integer sided right angle triangle, and other lengths allow more than one solution to be found; for example, using 120 cm it is possible to form exactly three different integer sided right angle triangles.\n\n\\[\\mathbf{120}\\textbf{ cm}: (30,40,50), (20,48,52), (24,45,51)\\]\n\n  Given that $L$ is the length of the wire, for how many values of $L\\leq 1\\,500\\,000$ can exactly one integer sided right angle triangle be formed?\n\n\n\n#39 - Integer right triangles is extremely similar to this. Like that problem, we will generate the sides of the triangles first. The method of generating the triples will be the same as that problem. Please consult that write-up on the actual method of generation.\n\nThe method only generates primitive triples however. We need to take multiples in order to properly check anything. We calculate each perimeter and add to a list. Then np.unique() along with return_counts=True will allow us to which values occur only once.\n# file: \"problem075.py\"\nmaxi = 1500000\nsums = []\nfor triple in genTriples(np.array([3, 4, 5]), maxi=maxi):\n    primPerim = np.sum(triple)\n    sums.extend(range(primPerim, maxi + 1, primPerim))\nuniques, counts = np.unique(sums, return_counts=True)\nexactlyOnce = uniques[np.where(counts == 1)]\nprint(exactlyOnce.size)\n\nRunning the above results in an output of,\n161667\n2.8955301999999996 seconds.\n\nThus, there are 161667 values under 1.5 million such that there exists exactly one integer-sided right angle triangle.\n",
      "categories": ["project_euler"],
      "tags": ["25_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2018-06-03-075-Singular-integer-right-triangles/"
    },{
      
      "title": "#77 - Prime summations",
      "date": "2018-06-05 12:18:00 +0000",
      
      "content": "\n  It is possible to write ten as the sum of primes in exactly five different ways:\n\n\\[\\begin{aligned}\n&amp;7+3\n\\\\\n&amp;5+5\n\\\\\n&amp;5+3+2\n\\\\\n&amp;3+3+2+2\n\\\\\n&amp;2+2+2+2+2\n\\end{aligned}\\]\n\n  What is the first value which can be written as the sum of primes in over five thousand different ways?\n\n\n\nLike with #76 - Counting summations, I researched for a possible recursive definition when using only prime numbers. This Math StackExchange post shows a way to do it.\n\nThe number of partitions $\\kappa(n)$ is given by\n\n[\\kappa(n) = \\frac{1}{n}\\left(\\text{sopf}(n) + \\sum_{j=1}^{n-1}\\text{sopf}(n)\\kappa(n-j)\\right)]\n\nwhere $\\kappa(1) = 0$. The function $\\text{sopf}(n)$ is the sum of prime factors function, where we add the distinct prime factors of $n$.\n\nTo find distinct prime factors, we can completely divide out a prime factor when we encounter a factor to save some time. The number of partitions generally explodes exponentially, so we do not need to do anything fancy with our prime search. The summation involves multiplying the reverse of the values, and I use numpy to quickly do element-wise multiplication.\n# file: \"problem077.py\"\ndef sopf(n):\n    s = 0\n    i = 2\n    while i &lt;= n:\n        if n % i == 0:\n            s += i\n            # Completely divide out the factor\n            while n % i == 0:\n                n //= i\n        else:\n            i += 1\n    return s\n\nsopfs = [0, 0]\nkappas = [0, 0]\nn = 2\nwhile kappas[-1] &lt;= 5000:\n    sopfs.append(sopf(n))\n    kappas.append(1/n * (sopfs[n] + sum(sopfs[1:n] * np.array(kappas[1:][::-1]))))\n    n += 1\nprint(len(kappas) - 1, 'is the first value which can be written in 5000+ ways.')\n\nThe extra 0 in the beginning is so that the index matches the value of $n$. Running this results in,\n71 is the first value which can be written in 5000+ ways.\n0.0018762999999999974 seconds.\n\nTherefore, 71 is the first integer such that there are at least 5000 different ways to write sums.\n",
      "categories": ["project_euler"],
      "tags": ["25_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2018-06-05-077-Prime-summations/"
    },{
      
      "title": "#83 - Path sum: four ways",
      "date": "2019-01-19 12:19:00 +0000",
      
      "content": "\n  In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right, by moving left, right, up, and down, is indicated in bold red and is equal to 2297.\n\n\\[\\begin{pmatrix}\n\t\\color{red}{\\mathbf{131}} &amp; 673 &amp; \\color{red}{\\mathbf{234}} &amp; \\color{red}{\\mathbf{103}} &amp; \\color{red}{\\mathbf{18}}\n\t\\\\\n\t\\color{red}{\\mathbf{201}} &amp; \\color{red}{\\mathbf{96}} &amp; \n\t\t\\color{red}{\\mathbf{342}} &amp; 965 &amp; \\color{red}{\\mathbf{150}}\n\t\\\\\n\t630 &amp; 803 &amp; 746 &amp; \\color{red}{\\mathbf{422}} &amp; \\color{red}{\\mathbf{111}}\n\t\\\\\n\t537 &amp; 699 &amp; 497 &amp; \\color{red}{\\mathbf{121}} &amp; 956\n\t\\\\\n\t805 &amp; 732 &amp; 524 &amp; \\color{red}{\\mathbf{37}} &amp; \\color{red}{\\mathbf{331}}\n\\end{pmatrix}\\]\n\n  Find the minimal path sum from the top left to the bottom right by moving left, right, up, and down in matrix.txt (right click and “Save Link/Target As…”), a 31K text file containing an 80 by 80 matrix.\n\n\n\nUnlike the previous two path sum problems, each cell can have its path coming from any direction. We can take a different approach, and think of the matrix as a topological graph. Each matrix entry represents a vertex, while incoming edges represents how much you need to add.\n\nOnly the edges will have our numbers, not our vertices. The $v_{22}$ will be the vertex in the 2nd row and 2nd column. This vertex will have incoming edges from $v_{12}, v_{21}, v_{23}$ and $v_{32}$ with edge weights 673, 201, 342, and 803 respectively.\n\nWith a graph now, the question is “What is the path with the shortest weight from $v_{11}$ to $v_{nn}$?” One of the most famous algorithms that find shortest paths is Dijkstra’s Algorithm. We will implement this algorithm below. I leave out the top left corner value because it is an initial value. Instead, I add it at the very end.\n# file: \"problem083.py\"\ndef getNeighbors(index, width, height):\n    # Grab the row and column (0-indexed)\n    row = index // height\n    column = index % width\n    # Calculate the 4 neighbors in\n    # each direction\n    RCNeighs = [\n        (row, column - 1),  # Left\n        (row - 1, column),  # Up\n        (row, column + 1),  # Right\n        (row + 1, column)   # Down\n    ]\n    # Filter out locations that are\n    # outside the range. These would be\n    # negatives or numbers bigger than width/height\n    RCNeighs = list(filter(lambda loc: (0 &lt;= loc[0] &lt; height) and (0 &lt;= loc[1] &lt; width), RCNeighs))\n    return RCNeighs\n\nstart = time.perf_counter()\n\nmatrix = np.loadtxt('./p083_matrix.txt', dtype='int32', delimiter=',')\n\nheight, width = matrix.shape\n\n# We are going to take Dijkstra's approach and treat\n# the digits as edge weights. The graph will be\n# directed because going from backwards adds a different number.\n# The nodes will numbered 0 to whatever number, across the columns\n# then down the rows. Due to this, when we find the minimum\n# distance, we must ADD THE TOP LEFT.\nedgeWeights = {}\n\nfor i in range(width * height):\n    neighbors = getNeighbors(i, width, height)\n    weights = []\n    # For each neighbor, calculate index value\n    # and grab the value...\n    for row, col in neighbors:\n        indexVal = row * width + col\n        weights.append((indexVal, matrix[row, col]))\n    # Assign the weights for this index...\n    edgeWeights[i] = weights\n\n# Now we can do Dijkstra's algorithm. The start index\n# is the node value 0 (top left).\n# We need a unvisited array and an array to hold the minimum\n# values.\nminValues = np.ones(len(edgeWeights.keys())) * float('inf')\nunvisited = list(edgeWeights.keys())\n\n# As a first step, the start node will have distance 0.\nminValues[0] = 0\n\n# While we still have vertices to visit.\nwhile len(unvisited) &gt; 0:\n    # Choose the index with the lowest distance which\n    # hasn't been visited yet.\n    nextIndex = unvisited[np.argmin(minValues[unvisited])]\n    # Grab the unvisited neighbors\n    unvisitedNeighs = list(filter(lambda x: x[0] in unvisited, edgeWeights[nextIndex]))\n    # For each unvisited neighbor, add the weight to\n    # the current min value of nextIndex and see if it should\n    # be updated\n    for neigh, weight in unvisitedNeighs:\n        if minValues[nextIndex] + weight &lt; minValues[neigh]:\n            minValues[neigh] = minValues[nextIndex] + weight\n    # The index is now visited, so remove it...\n    unvisited.remove(nextIndex)\n\n# The value in the bottom right is the last value\n# in the minValues array. Add this to the value in\n# the top left to get our minimum sum.\nprint(int(minValues[-1] + matrix[0, 0]))\n\nRunning the algorithm gets us an output of,\n425185\n4.2442820999999995 seconds.\n\nThus, the smallest corner to corner sum is 425185.\n",
      "categories": ["project_euler"],
      "tags": ["25_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-01-19-083-Path-sum-four-ways/"
    },{
      
      "title": "#112 - Bouncy numbers",
      "date": "2019-02-11 12:01:00 +0000",
      
      "content": "\n  Working from left-to-right if no digit is exceeded by the digit to its left it is called an increasing number; for example, 134468.\n\n  Similarly if no digit is exceeded by the digit to its right it is called a decreasing number; for example, 66420.\n\n  We shall call a positive integer that is neither increasing nor decreasing a “bouncy” number; for example, 155349.\n\n  Clearly there cannot be any bouncy numbers below one-hundred, but just over half of the numbers below one-thousand (525) are bouncy. In fact, the least number for which the proportion of bouncy numbers first reaches 50% is 538.\n\n  Surprisingly, bouncy numbers become more and more common and by the time we reach 21780 the proportion of bouncy numbers is equal to 90%.\n\n  Find the least number for which the proportion of bouncy numbers is exactly 99%.\n\n\n\nWe can do a brute force check to see if a number is bouncy. We can scan the number left to right, and find the first pair of numbers which does not follow the bouncy characteristic. In this way, we have a “fast-fail” approach where we don’t have to search the whole number if it’s bouncy.\n\nFor example, 155349 is bouncy. The first two digits are “15”, and since $5&gt;1$, all digits after that should be non-decreasing. However, “53” violates this, thus the number is bouncy. We will start from 21780, and count up until we reach a proportion of 99\\%.\n# file: \"problem112.py\"\ndef isBouncy(x):\n    # Convert to list of digits\n    digits = [int(d) for d in str(x)]\n    # Find the first distinct pair\n    # and set whether the number should\n    # be increasing or decreasing.\n    i = 0\n    while i &lt; len(digits) - 1 and digits[i] == digits[i+1]:\n        i += 1\n    # If we've reached the end, then\n    # all numbers are the same, so\n    # it's not bouncy\n    if i == len(digits) - 1:\n        return False\n    # Otherwise, find the direction\n    if digits[i + 1] &lt; digits[i]:\n        increasing = False\n    else:\n        increasing = True\n    # Now starting from the next pair,\n    # see if the condition holds\n    i += 1\n    while i &lt; len(digits) - 1:\n        if (digits[i + 1] &lt; digits[i] and increasing) or \\\n                (digits[i + 1] &gt; digits[i] and not increasing):\n            return True\n        i += 1\n    return False\n\nbouncyNums = 21780 * 9 / 10\nn = 21780\n\nwhile bouncyNums / n &lt; 0.99:\n    n += 1\n    if isBouncy(n):\n        bouncyNums += 1\n\nprint('First reaches 99% at n =', n)\n\nRunning this short loop, we get\nFirst reaches 99% at n = 1587000\n4.4108225 seconds.\n\nThus, 1587000 is the first number which results in 99\\% bouncy numbers below it.\n",
      "categories": ["project_euler"],
      "tags": ["15_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-02-11-112-Bouncy-numbers/"
    },{
      
      "title": "#113 - Non-bouncy numbers",
      "date": "2019-02-11 13:46:00 +0000",
      
      "content": "\n  Working from left-to-right if no digit is exceeded by the digit to its left it is called an increasing number; for example, 134468.\n\n  Similarly if no digit is exceeded by the digit to its right it is called a decreasing number; for example, 66420.\n\n  We shall call a positive integer that is neither increasing nor decreasing a “bouncy” number; for example, 155349.\n\n  As $n$ increases, the proportion of bouncy numbers below $n$ increases such that there are only 12951 numbers below one-million that are not bouncy and only 277032 non-bouncy numbers below $10^{10}$.\n\n  How many numbers below a googol ($10^{100}$) are not bouncy?\n\n\n\nWith #112 - Bouncy numbers, we explicitly tested whether each number was bouncy. However, in this case, the limit is massive, which means we must take a clever counting approach.\n\nFrom the problem, a number will fall into 3 distinct groups: an increasing number, a decreasing number, or neither. The former two collectively refer to non-bouncy numbers.\n\nIncreasing numbers\nOne important note is that the number of increasing numbers differs depending on what digit the number starts with. For example, there are 5 two-digit increasing numbers that start with 5 (55-59), but only 2 that start with 8 (88 and 89). It appears, at least in the two-digit case, that the number of increasing numbers starting with digit $d$ is $10-d$.\n\nIn the 3-digit case, something interesting case. Let’s say our 3-digit number starts with 4. This means the next digit can be anything between 4-9. However, now we are essentially finding all two-digit increasing numbers that start with 4-9. The sum of these gives us the number of 3-digit increasing numbers that start with 4. The same logic can be used to see how many there are that start with each digit.\n\nA quick example with 4-digit numbers\nWe keep track of the number of increasing numbers per starting digit, except 0 because numbers can’t start with 0, and an increasing number can’t contain a 0.\n\n\n  Our array looks like [1, 1, 1, 1, 1, 1, 1, 1, 1], because there’s only 1 number for each starting digit.\n  For two digits, the array now looks like [9, 8, 7, 6, 5, 4, 3, 2, 1] i.e. there are 9 2-digit numbers that start with 1 (11-19), 8 that start with 2 (22-29), …\n  For three digits, the array looks like [45, 36, 28, 21, 15, 10, 6, 3, 1]. The first element is calculated by 9 + 8 + 7 + … + 1 = 45, the second element is calculated by 8 + 7 + 6 + …., because 3-digit increasing numbers that start with 2 can’t have 1 as a second digit. This is a cumulative sum.\n  For four digits, the array looks like [165, 120, 84, 56, 35, 20, 10, 4, 1]. It should make sense that the right-most number is 1, since there’s always only 1 increasing number that starts with 9, and that is 99…99.\n\n\nUsing np.cumsum we can do this operation in one line.\nDecreasing numbers\nFor decreasing numbers, the method is exactly the same, just that the cumulative sum travels in the other direction. Additionally, we need to include 0 in our calculations. This is because it is possible for decreasing numbers to have zeroes in them i.e. 2100 is a decreasing number.\n\nDouble-counting\nIf we add the number of increasing and decreasing numbers, we’ll almost have the answer, but we have double counted numbers with all the same digit. A number like 5555 is both increasing and decreasing. We need to subtract these out (as well the “number” of all 0s which we have counted as a decreasing number). There are 10 of these in total (0s, 1s, 2s, …).\n\nCode\nnumpy makes this consice.\n# file: \"problem113.py\"\nincrNums = np.ones(9, object)\ndecrNums = np.ones(10, object)  # Count 0 as a decreasing digit\n# All one digit #s are not bouncy\ntotal = 9\ndigitMax = 100\n\nfor digit in range(2, digitMax+1):\n    # Calculate number of increasing and decreasing numbers for the current digit length\n    incrNums = np.cumsum(incrNums)\n    decrNums = np.cumsum(decrNums)\n    # Add the total of each of these to the total.\n    # However, we have to subtract 10, because one we counted is 00...0, which isn't a number.\n    # We also double-counted numbers that go like 1...1, 22...2, ..., 99...9; there are nine of them.\n    total += np.sum(incrNums) + np.sum(decrNums) - 10\n\nprint('There are', total, 'non-bouncy numbers below 10 ^', digitMax)\n\nRunning the loop gets us,\nThere are 51161058134250 non-bouncy numbers below 10 ^ 100\n0.002906500012613833 seconds.\n\nTherefore, there are 51161058134250 non-bouncy numbers below a googol.\n",
      "categories": ["project_euler"],
      "tags": ["30_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-02-11-113-Non-bouncy-numbers/"
    },{
      
      "title": "#206 - Concealed Square",
      "date": "2019-03-24 11:17:00 +0000",
      
      "content": "\n  Find the unique positive integer whose square has the form 1_2_3_4_5_6_7_8_9_0, where each “_” is a single digit.\n\n\n\nShort and sweet. The first thing to note is that the square ends in a 0. The only square numbers that end in 0 are multiples of 100, which means the final blank is a 0. We can now instead look for a square that looks like 1_2_3_4_5_6_7_8_9.\n\nWe want a square that ends in 9, which means the square root of this number ends in a 3 or 7 (since $3^2=9$ and $7^2=49$, both end in 9s). We can brute force this problem.\n\nThe largest possible number is where only 9s are filled in i.e. 19293949596979899.The largest square less than this is $138\\,902\\,662^2=19\\,293\\,949\\,510\\,686\\,244$. We start with 138902657, since we want a number ending in 3 or 7. Then we alternatively subtract 4 and 6 to keep the last digit 3 or 7. A short function to test if the square follows the pattern is also needed.\n# file: \"problem206.py\"\ndef isValid(n):\n    # Only need to check until the \"8\"\n    # because our number ends in \"900\".\n    for k in range(1, 9):\n        if int(str(n)[2 * (k - 1)]) != k:\n            return False\n    return True\n\n# Start with the root of the largest number\n# 19293949596979899 -&gt; 138,902,662\nn = 1389026657\nsubtracting = 4\nwhile not isValid(n ** 2):\n    n -= subtracting\n    # Alternate subtracting 4 and 6\n    # to get numbers ending in 3 and 7\n    if subtracting == 4:\n        subtracting = 6\n    else:\n        subtracting = 4\nprint(f'{n * 10}^2 = {n * n * 100}')\n\nRunning the loop, we get\n1389019170^2 = 1929374254627488900\n0.0008701999999999877 seconds.\n\nThus, our unique number whose square follows the pattern is 1389019170. The time is very quick because the answer is fairly close to the upper limit.\n",
      "categories": ["project_euler"],
      "tags": ["05_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-03-24-206-Concealed-square/"
    },{
      
      "title": "#61 - Cyclical figurate numbers",
      "date": "2019-06-01 14:26:00 +0000",
      
      "content": "\n  Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:\n\n  \n    \n      \n        Type\n        Formula\n        Series\n      \n    \n    \n      \n        Triangle\n        $P_{3,n}=\\frac{1}{2}n(n+1)$\n        1, 3, 6, 10, 15, …\n      \n      \n        Square\n        $P_{4,n}=n^2$\n        1, 4, 9, 16, 25, …\n      \n      \n        Pentagonal\n        $P_{5,n}=\\frac{1}{2}n(3n-1)$\n        1, 5, 12, 22, 35, …\n      \n      \n        Hexagonal\n        $P_{6,n}=n(2n-1)$\n        1, 6, 15, 28, 45, …\n      \n      \n        Heptagonal\n        $P_{7,n}=\\frac{1}{2}n(5n-3)$\n        1, 7, 18, 34, 55, …\n      \n      \n        Octagonal\n        $P_{8,n}=n(3n-2)$\n        1, 8, 21, 40, 65\n      \n    \n  \n\n  The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.\n\n  \n    The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with first).\n    Each polygonal type: triangle ($P_{3,127}=8128$), square ($P_{4,91}=8281$), and pentagonal ($P_{5,44}=2882$), is represented by a different number in the set.\n    This is the only set of 4-digit numbers with this property.\n  \n\n  Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.\n\n\n\nIt is very inefficient to check every possible set of 6 numbers, as there are 6 different types. However, we can create a ~search tree”, where we continuously cut down the list of valid numbers. For example, suppose we pick the smallest 4-digit octagonal number $P_{8,19}=1045$. If we assume the next number in the chain is heptagonal, then the only possible value is $P_{7,43}=4558$. Next, no 4-digit hexagonal, pentagonal, or square numbers start with 58. Only the triangular number $P_{3,108}=5886$ can follow. We keep going with the process. Eventually, if it’s an invalid solution, we will reach a point where no remaining number starts with the two digits we need, and we start the search with the next octagonal number.\n\nOur function will be a recursive one, and additionally, if a number has a 0 in the third position, then it’s impossible to form a chain, as that would mean the next number starts with 0.\n\n\n  Base case -  If we have zero choices to make for the next number AND our chain length is 6, then we have found a chain, so return it! Otherwise, this chain is invalid so cut off the tree and stop looking.\n  If our chain length is 0, then simply loop through all starting numbers and start the chain up.\n  Recursive step - For each polygonal set, grab all numbers that can be tacked on to our ongoing chain. If it’s the last number, then also look at the first two digits of the first number in the chain list. Recurse, with the addition of each valid number, removing the list the number came from in the recursive call.\n\n\n# file: \"problem061.py\"\ndef genPolyNums(degree, low, high):\n    # Generate the lambda function...\n    if degree == 3:\n        f = lambda x: x * (x + 1) // 2\n    elif degree == 4:\n        f = lambda x: x ** 2\n    elif degree == 5:\n        f = lambda x: x * (3 * x - 1) // 2\n    elif degree == 6:\n        f = lambda x: x * (2 * x - 1)\n    elif degree == 7:\n        f = lambda x: x * (5 * x - 3) // 2\n    else:\n        f = lambda x: x * (3 * x - 2)\n    # Increment n until our polygonal\n    # number is bigger than 'low',\n    # then loop until it's bigger than\n    # 'high'.\n    n = 1\n    while f(n) &lt;= low:\n        n += 1\n    nums = []\n    while f(n) &lt; high:\n        nums.append(f(n))\n        n += 1\n    return nums\n\n# Recursive function to generate\n# cyclic chains using exactly\n# one number from a list of sets.\ndef findCyclicSets(numSets, currChain, chainLength):\n    # Base case is when we\n    # have no more numbers to choose from.\n    # If our chain isn't long enough, then\n    # it's failed branch. Otherwise, we return the\n    # chain.\n    if len(numSets) == 0:\n        if len(currChain) == chainLength:\n            return currChain\n        else:\n            return\n    # Recursive cases.\n    # If our currChain is length 0,\n    # start it up by using each number from\n    # the first set.\n    if len(currChain) == 0:\n        for num in numSets[0]:\n            # Skip numbers that have a 0 in\n            # the 3rd position\n            if num % 100 &lt; 10:\n                continue\n            result = findCyclicSets(numSets[1:], [num], chainLength)\n            if result is not None:\n                return result\n    # Otherwise, take the last number\n    # in the chain, take each set, and\n    # recurse with the number that forms\n    # a chain. If it's going to be the last\n    # number in the chain, then we have to check the\n    # first number in the chain as well.\n    lastTwoDigits = currChain[-1] % 100\n    for i in range(len(numSets)):\n        numSet = numSets[i]\n        # Filter out numbers that form chain.\n        validNums = [n for n in numSet if (n // 100) == lastTwoDigits]\n        # Filter out numbers that form chain for\n        # the first number IF it's the last number.\n        if len(currChain) == chainLength - 1:\n            firstNumFirstTwo = currChain[0] // 100\n            validNums = [n for n in validNums if firstNumFirstTwo == n % 100]\n        # Recurse using each valid number, removing\n        # the set to prevent future selections from the\n        # set.\n        for valid in validNums:\n            # Don't bother checking ones that\n            # have a zero as the second to last digit.\n            if valid % 100 &lt; 10:\n                continue\n            # Recurse, making sure to not include this set.\n            result = findCyclicSets(numSets[:i] + numSets[i+1:], currChain + [valid], chainLength)\n            if result is not None:\n                return result\n# Generate triangle through octogonal\n# numbers...\npolyNums = [genPolyNums(i, 1000, 10000) for i in range(8, 2, -1)]\ncyclicSet = findCyclicSets(polyNums, [], 6)\nprint(cyclicSet)\nprint(sum(cyclicSet))\n\nRunning this long code results in an output of,\n[1281, 8128, 2882, 8256, 5625, 2512]\n28684\n0.0008549132425034104 seconds.\n\nThus, the chain goes 1281, 8128, 2882, 8256, 5625, and 2512. The sum of these numbers is 28684.\n",
      "categories": ["project_euler"],
      "tags": ["20_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-06-01-061-Cyclical-figurate-numbers/"
    },{
      
      "title": "#74 - Digit factorial chains",
      "date": "2019-06-01 17:31:00 +0000",
      
      "content": "\n  The number 145 is well known for the property that the sum of the factorial of its digits is equal to 145:\n\n\\[1! + 4! + 5! = 1 + 24 + 120 = 145\\]\n\n  Perhaps less well known is 169, in that it produces the longest chain of numbers that link back to 169; it turns out that there are only three such loops that exist:\n\n\\[\\begin{aligned}\n\t&amp; 169 \\rightarrow 363601 \\rightarrow 1454 \\rightarrow 169\n\t\\\\\n\t&amp; 871 \\rightarrow 45361 \\rightarrow 871\n\t\\\\\n\t&amp; 872 \\rightarrow 45362 \\rightarrow 872\n\\end{aligned}\\]\n\n  It is not difficult to prove that EVERY starting number will eventually get stuck in a loop. For example,\n\n\\[\\begin{aligned}\n\t&amp; 69 \\rightarrow 363600 \\rightarrow 1454 \\rightarrow 169 \\rightarrow 363601\\,(\\rightarrow 1454)\n\t\\\\\n\t&amp; 78 \\rightarrow 45360 \\rightarrow 871 \\rightarrow 45361\\,(\\rightarrow 871)\n\t\\\\\n\t&amp; 540 \\rightarrow 145\\,(\\rightarrow 145)\n\\end{aligned}\\]\n\n  Starting with 69 produces a chain of five non-repeating terms, but the longest non-repeating chain with a starting number below one million is sixty terms.\n\n  How many chains, with a starting number below one million, contain exactly sixty non-repeating terms?\n\n\n\nTo calculate the digit factorial sum, I’ll be taking a mathematical approach, instead of converting to string and iterating, as that could slow things down. The ones digit in a number $n$ is obtained through $n\\mod 10$. Meanwhile, $\\lfloor n/10 \\rfloor$ will delete the last digit. Using these two operations we can go through each digit without converting to a string.\n\nBecause we are dealing with chains, during calculation of the current chain, anytime we encounter a number whose chain length has already been calculated, we can immediately stop calculation and add the length. This drastically reduces the number of computations we need to do.\n\nTo account for the possibility that starting numbers under one million can have numbers greater than that in their chain, I’ll use defaultdict to store the chain lengths.\n\nWe can also store the initial loop chain lengths to prevent any other numbers from falling into a loop. 40585 is actually another number that equals itself when taking the sum of the factorials of its digits.\n# file: \"problem074.py\"\nchainLengths = defaultdict(int)\n# 1! = 1, 2! = 2, 145! ==&gt; 145\n# 40585! ==&gt; 40585\n# set these to 1\nchainLengths[1] = 1\nchainLengths[2] = 1\nchainLengths[145] = 1\nchainLengths[40585] = 1\n# 871, 45361, 872, 45362\n# have lengths of 2\nfor num in [871, 872, 45361, 45362]:\n    chainLengths[num] = 2\n# 169, 363601, 1454 have length 3\nfor num in [169, 363601, 1454]:\n    chainLengths[num] = 3\n\n# Calculate length\n# of chains for everything less\n# than 1 million\nlimit = 1000000\nfor n in range(3, limit):\n    # See if it's been calculated\n    if chainLengths[n] &gt; 0:\n        continue\n    # Calculate until we've reached a\n    # number that has been calculated...\n    num = n\n    length = 1\n    visited = [num]\n    while chainLengths[num] == 0:\n        num = factorialDigitSum(num)\n        visited.append(num)\n        length += 1\n    # Now set the visited numbers...\n    # l is an offset.\n    for l, k in enumerate(visited[::-1]):\n        chainLengths[k] = l + chainLengths[num]\n\n# Count how many numbers have chain length 60\ncountOfLength60 = 0\nfor num, length in chainLengths.items():\n    if num &lt; limit and length == 60:\n        countOfLength60 += 1\n\nprint(countOfLength60)\n\nA 0 means the chain hasn’t been calculated yet. Running the code above results in,\n402\n3.9272377 seconds.\n\nThus, there are 402 terms with exactly 60 non-repeating terms in their chain. If we check the length of chainLengths, we see that there are 1000208, meaning we ended up storing 208 numbers above our limit.\n",
      "categories": ["project_euler"],
      "tags": ["15_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-06-01-074-Digit-factorial-chains/"
    },{
      
      "title": "#86 - Cuboid route",
      "date": "2019-06-10 20:25:00 +0000",
      
      "content": "\n  A spider, S, sits in one corner of a cuboid room, measuring 6 by 5 by 3, and a fly, F, sits in the opposite corner. By travelling on the surfaces of the room the shortest “straight line” distance from S to F is 10 and the path is shown on the diagram.\n\n  \n\n  However, there are up to three “shortest” path candidates for any given cuboid and the shortest route doesn’t always have integer length.\n\n  It can be shown that there are exactly 2060 distinct cuboids, ignoring rotations, with integer dimensions, up to a maximum size of $M$ by $M$ by $M$, for which the shortest route has integer length when $M=100$. This is the least value of $M$ for which the number of solutions first exceeds two thousand; the number of solutions when $M=99$ is 1975.\n\n  Find the least value of $M$ such that the number of solutions first exceeds one million.\n\n\n\nSince this is an optimization problem, the quickest way to solve this is single-variabled calculus. Next, I also want to show the three possible candidates for the shortest paths that the problem talked about. Like above, the spider would have to go over an edge, and so, **each path corresponds to each edge spider goes over **. She can either go over the 6 edge, the 5 edge, or the 3 edge. I’ve displayed them below.\n\n\n\nWhich edge corresponds to the actual shortest path from $S$ to $F$? Intuitively, it is the longest edge, because the spider is cutting across it through both legs (before going over the edge, and after). If the spider cross any of the shorter edges, she would have cover that longest edge in just of the two legs, which would lead a slightly longer distance.\n\nI’ll assume a cuboid measuring $a\\times b\\times c$, with $a\\geq b\\geq c$. Our assumption is that the spider goes over edge $a$, and so the variable we would be optimizing is where she does it. Let’s call this point $x$. The picture below helps with visualizing.\n\n\n\nEach of the two parts are hypotenuses of two right triangles. The triangle on the $ab$ face, has sides $x$ and $b$, and thus has a hyponetuse of $\\sqrt{x^2+b^2}$. The other triangle has sides $c$ and $a-x$. Therefore, our distance function is\n\n[f(x)=\\sqrt{x^2+b^2}+\\sqrt{(a-x)^2+c^2}]\n\nTo minimize this, we take the derivative and set it equal to 0. This will tell us the crossing point, which we plug into $f(x)$ to find the distance. Lots of algebra and simplying is needed:\n\n[\\begin{aligned}\n\t\\frac{df}{dx}&amp;=\\frac{1}{2}(x^2+b^2)^{-\\frac{1}{2}}(2x)+\n\t\t\\frac{1}{2}(x^2-2ax+a^2+c^2)^{-\\frac{1}{2}}\n\t\t(2x-2a)\n\t\n\t0 &amp;= \\frac{x}{\\sqrt{x^2+b^2}}+\\frac{x-a}\n\t\t{\\sqrt{x^2-2ax+a^2+c^2}}\n\t\n\t\\frac{a-x}{\\sqrt{x^2-2ax+a^2+c^2}} &amp;=\n\t\t\\frac{x}{\\sqrt{x^2+b^2}}\n\t\n\t(a-x)\\sqrt{x^2+b^2} &amp;= x\\sqrt{x^2-2ax+a^2+c^2}\n\t\n\t(a-x)^2(x^2+b^2) &amp;= x^2(x^2-2ax+a^2+c^2)\n\t\n\t(x^2-2ax+a^2)(x^2+b^2) &amp;= x^4-2ax^3+a^2x^2+c^2x^2\n\t\n\tx^4+b^2x^2-2ax^3-2ab^2x+a^2x^2+a^2b^2 &amp;=\n\t\tx^4-2ax^3+a^2x^2+c^2x^2\n\t\n\t(b^2-c^2)x^2-2ab^2x+a^2b^2 &amp;= 0\n\\end{aligned}]\n\nThe last line is a quadratic equation in $x$:\n\n[\\begin{aligned}\n\tx &amp;= \\frac{2ab^2\\pm\\sqrt{4a^2b^4-4(b^2-c^2)a^2b^2}}\n\t\t{2(b^2-c^2)}\n\t\\ &amp;=\n\t\\frac{2ab^2\\pm\\sqrt{4a^2b^4-4a^2b^4+4a^2b^2c^2}}\n\t\t{2b^2-2c^2}\n\t\\ &amp;=\n\t\\frac{2ab^2\\pm\\sqrt{4a^2b^2c^2}}{2b^2-2c^2}\n\t\\ &amp;=\n\t\\frac{2ab^2\\pm 2abc}{2b^2-2c^2}\n\t\\ &amp;=\n\t\\frac{ab^2\\pm abc}{b^2-c^2}\n\\end{aligned}]\n\nWe choose the negative sign, since $x$ has to be less than $a$.\n\n[\\frac{ab^2-abc}{b^2-c^2} = \\frac{ab(b-c)}{(b-c)(b+c)}=\\boxed{\\frac{ab}{b+c}}]\n\nNow we have the minimizing point, which we plug into our function to find the distance.\n\n[\\begin{aligned}\n\tf\\left(\\frac{ab}{b+c}\\right) &amp;=\n\t\t\\sqrt{\\left(\\frac{ab}{b+c}\\right)^2 + b^2} +\n\t\t\\sqrt{\\left(a-\\frac{ab}{b+c}\\right)^2+c^2}\n\t\\ &amp;=\n\t\\sqrt{\\frac{(ab)^2}{(b+c)^2}+\\frac{b^2(b+c)^2}{(b+c)^2}} +\n\t\t\\sqrt{\\left(\\frac{a(b+c)}\n\t\t{b+c}-\\frac{ab}{b+c}\\right)^2 + c^2}\n\t\\ &amp;=\n\t\\frac{b}{b+c}\\sqrt{a^2+(b+c)^2} +\n\t\t\\frac{c}{b+c}\\sqrt{a^2+(b+c)^2}\n\t\\ &amp;=\n\t\\left(\\frac{b}{b+c}+\\frac{c}{b+c}\\right)\n\t\t\\sqrt{a^2+(b+c)^2}\n\t\\ &amp;=\n\t\\boxed{\\sqrt{a^2+(b+c)^2}}\n\\end{aligned}]\n\nAn extra step you can do is assume $x$ is on the smaller sides $b$ or $c$, and convince yourself those distances are larger than this one.\n\nLet the minimum distance be $D$. We want $D$ to be an integer, which menas the expression inside the square root needs to be a perfect square:\n\n[a^2+(b+c)^2=D^2]\n\nThis looks exactly like the Pythagorean formula, which means $\\mathbf{a}$, $\\mathbf{b+c}$, and $\\mathbf{D}$ all have to form a Pythagorean triple. For example, having $a=6$, $b=5$, and $c=3$ corresponds to the triple ${6,8,10}$ and indeed 10 is the shortest path, as the example in the problem shows. We have looped through Pythagorean triples before in #39 - Integer right triangles. But there are some cases we must consider…\n\nWhen we loop through triples $\\alpha, \\beta, \\gamma$ (with $\\alpha\\leq\\beta\\leq\\gamma$), the hypotenuse corresponds to $D$ directly. But we have choices for the other two sides. Either our largest side $a=\\alpha$, or $a=\\beta$, with differing consequences.\n$a=\\alpha$\nIf we set our largest side to be $\\alpha$, then we must split up $\\beta$ into two values $b$ and $c$ such that $a$ are greater than both. This will only work if $\\beta \\leq 2$. Assuming this is true, how many solutions are there for a fixed triple in this case?\n\nWithout any constraints, there are $\\lfloor \\beta/2\\rfloor$ distinct pairs of sums. Of these, exactly $\\beta-\\alpha$ of them have a number which is greater than $\\alpha$, so we need to subtract these out. However, we also have to add back in the sum with an operand that is equal to $\\alpha$, since that is also allowed. Therefore, the total number of solutions in this case are $\\boxed{\\lfloor \\beta/2\\rfloor - (\\beta-\\alpha)+1}$.\n$a=\\beta$\nSince $\\beta\\geq\\alpha$, all partitions of $\\alpha$ are valid solutions. Thus, the number of solutions in this case is $\\lfloor \\alpha/2\\rfloor$.\n\nImplementation\nWe can use our recursive function from Problem 39, but when do we stop the generation? Well, $a$ is our biggest side, and this can’t exceed $M$. Based on our two cases above, we stop when either $\\alpha &gt; M$, or when both $\\beta &gt;M$ and $\\beta &gt;2\\alpha$, as this prevents us from partitioning $\\beta$.\n\nThis method is quick for a specific value of $M$. However, the problem requires the first $M$ whose solutions exceed one million, which implies we need to compute solutions for all values until that point. This can get really slow. To combat this, I increment $M$ by 100 in my loop. Eventually when we overshoot the value, we can slowly decrement the value back down to find the exact $M$ we need.\n# file: \"problem086.py\"\ndef genPythagoreanTriples(triple, maxSide, A, B, C):\n    # Find min and second largest\n    # value. Never the last value...\n    if triple[0] == min(triple):\n        minVal, secVal = triple[0], triple[1]\n    else:\n        minVal, secVal = triple[1], triple[0]\n    # Base case...\n    if min(triple) &gt; maxSide or (secVal &gt; maxSide and secVal &gt; 2 * minVal):\n        return\n    yield np.sort(triple)\n    # Multiply each matrix\n    for matrix in [A, B, C]:\n        for multTriple in genPythagoreanTriples(np.dot(matrix, triple), maxSide, A, B, C):\n            yield multTriple\ndef calculateSols(triple, maxSide, A, B, C):\n    s = 0\n    for pythTriple in genPythagoreanTriples(triple, maxSide, A, B, C):\n        print(pythTriple)\n        # Check to see if the second value is\n        # less than twice the lowest value.\n        # Otherwise, we can't break up the second value\n        # into two sides less than the lowest...\n        if pythTriple[1] &lt;= 2 * pythTriple[0]:\n            # Loop through, keeping the minimum side\n            # constant...\n            # Number of solutions is secVal // 2 - (secVal - firstVal) + 1\n            for i in range(1, maxSide // pythTriple[0] + 1):\n                multTriple = i * pythTriple\n                v1 = multTriple[1] // 2 - (multTriple[1] - multTriple[0]) + 1\n                s += v1\n        # Keep the second value constant,\n        # breaking the lowest value into all\n        # possible unique partitions...\n        for i in range(1, maxSide // pythTriple[1] + 1):\n            v2 = int((i * pythTriple)[0] // 2)\n            s += v2\n    return s\nA = np.array([\n    [1, -2, 2],\n    [2, -1, 2],\n    [2, -2, 3]\n], dtype=object)\nB = np.array([\n    [1, 2, 2],\n    [2, 1, 2],\n    [2, 2, 3]\n], dtype=object)\nC = np.array([\n    [-1, 2, 2],\n    [-2, 1, 2],\n    [-2, 2, 3]\n], dtype=object)\n\ntriple = np.array([3,4,5], dtype=object)\nmaxSide = 100\nmaxSolutions = 1000000\nnumSolutions = 1\nwhile numSolutions &lt; maxSolutions:\n    numSolutions = calculateSols(triple, maxSide, A, B, C)\n    # Save time by increasing the side by 100\n    maxSide += 100\n# Now slowly decrease the maxSide until we're less\nwhile numSolutions &gt; maxSolutions:\n    maxSide -= 1\n    numSolutions = calculateSols(triple, maxSide, A, B, C)\n# Add one because we went one\n# over with the while loop.\nprint('M = {} with {} solutions.'.format(maxSide + 1, calculateSols(triple, maxSide + 1, A, B, C)))\n\nRunning it all together, we get an output of,\nM = 1818 with 1000457 solutions.\n3.3048678999766707 seconds.\n\nThus, the first side length which has the number of solutions exceed one million is 1818.\n",
      "categories": ["project_euler"],
      "tags": ["35_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-06-10-086-Cuboid-route/"
    },{
      
      "title": "#124 - Ordered radicals",
      "date": "2019-06-12 18:45:00 +0000",
      
      "content": "\n  The radical of $n$, $\\text{rad}(n)$, is the product of the distinct prime factors of $n$. For example, $504=2^3\\times3^2\\times7$, so $\\text{rad}(504)=2\\times3\\times7=42$.\n\n  If we calculate $\\text{rad}(n)$ for $1\\leq n\\leq 10$, then sort them on $\\text{rad}(n)$, and sorting on $n$ if the radical values are equal we get:\n\n  \n    \n      \n        Unsorted\n         \n         \n        Sorted\n         \n         \n      \n    \n    \n      \n        $\\mathbf{n}$\n        $\\textbf{rad}\\mathbf{(n)}$\n         \n        $\\mathbf{n}$\n        $\\textbf{rad}\\mathbf{(n)}$\n        $\\mathbf{k}$\n      \n      \n        1\n        1\n         \n        1\n        1\n        1\n      \n      \n        2\n        2\n         \n        2\n        2\n        2\n      \n      \n        3\n        3\n         \n        4\n        2\n        3\n      \n      \n        4\n        2\n         \n        8\n        2\n        4\n      \n      \n        5\n        5\n         \n        3\n        3\n        5\n      \n      \n        6\n        6\n         \n        9\n        3\n        6\n      \n      \n        7\n        7\n         \n        5\n        5\n        7\n      \n      \n        8\n        2\n         \n        6\n        6\n        8\n      \n      \n        9\n        3\n         \n        7\n        7\n        9\n      \n      \n        10\n        10\n         \n        10\n        10\n        10\n      \n    \n  \n\n  Let $E(k)$ be the $k^{\\text{th}}$ element in the sorted $n$ column; for example, $E(4) = 8$ and $E(6) = 9$.\n\n  If $\\text{rad}(n)$ is sorted for $1\\leq n \\leq 100000$, find $E(10000)$.\n\n\n\nSince we are sorting, we must calculate the radical for each $n$ up to 100000. A brute force solution calculates the prime factorization each time, but we can do better. The key point to realize is that the radical stays constant as long as the distinct prime factors are the same. For example, using the example in the problem, any number with 2, 3, and 7 as its distinct prime factors, will have a radical of 42. Since each integer has a unique prime factorization, we can loop through all possible distinct prime factor sets, then add all numbers stemming from those factor sets into an array (along with its constant radical) and finally sort it.\nLooping through factor sets\nWe use a recursive algorithm to loop through all factor sets of a certain size up to a limit. For example, let’s say the set size was 3 and our limit was 100. The set with the smallest product is {2, 3, 5}, which is 30.  Now, keeping 2 and 3 constant, this means $2\\times3\\times p \\leq 100 \\rightarrow p \\leq 16.67$. Thus, the only possibilities for the last factor is 5, 7, 11, and 13. Then, in the next loop, the second factor becomes 5, which leads to the last factor being no more than 10 (7 being the only satisfactory factor). To avoid duplicating the sets, we’ll make sure the primes are increasing when going left to right.\n\nOnce this set size is finished, we move on to a set size of 4. We keep increasing the set size until multiplying the smallest $t$ prime numbers leads to exceeding the limit. In the 100 case, it is 3. For 1000, it is 4 (2, 3, 5, and 7).\n# file: \"problem124.py\"\ndef loopThroughFactorizations(numOfFacts, primes, limit):\n    if numOfFacts == 1:\n        i = 0\n        while (i &lt; len(primes)) and (primes[i] &lt; limit):\n            yield [primes[i]]\n            i += 1\n    else:\n        upperBound = limit ** (1 / numOfFacts)\n        i = 0\n        while (i &lt; len(primes)) and (primes[i] &lt; upperBound):\n            for subFactorization in loopThroughFactorizations(numOfFacts - 1, primes[i + 1:], limit / primes[i]):\n                yield [primes[i]] + subFactorization\n            i += 1\n\nBut this only gets the distinct prime factor set. We still need all integers with that set of distinct prime factors.\nLooping through all integers with specific distinct prime factors\nThis portion is also recursive. We increment the power on each prime, and calculate the maximum power of the remainign prime factors using logarithms. For example, with a limit of 1000 and the set of {2, 3, 7}, the maximum exponent 2 can have is $\\lfloor \\log_2\\frac{1000}{3\\times 7}\\rfloor = \\mathbf{5}$. Setting an exponent on 2 will effect the maximum exponents for the rest of the prime factors.\n# file: \"problem124.py\"\ndef loopThroughFactorPowers(factorization, limit):\n    if len(factorization) == 1:\n        base = factorization[0]\n        powerLimit = math.log(limit, base)\n        for power in range(1, math.ceil(powerLimit)):\n            yield [power]\n    else:\n        prodOfRemaining = 1\n        for number in factorization[1:]:\n            prodOfRemaining *= number\n        base = factorization[0]\n        powerLimit = math.log(limit / prodOfRemaining, base)\n        for power in range(1, math.ceil(powerLimit)):\n            for remPowers in loopThroughFactorPowers(factorization[1:], limit / base ** power):\n                yield [power] + remPowers\n\nImplementation\nI use primesieve.primes to get my primes, and initialize my array with (1, 1). Passing in a list of tuples to the sorted() function will result in sorting the values by the first value, and then the second value, which we can take advantage of by placing the radical value first, then the integer.\n# file: \"problem124.py\"\nlimit = 100001\nprimes = primesieve.primes(limit)\nrads = [(1, 1)]\n# Find the maximum number of primes we can \n# multiply together\nmaxPrimes = 0\nprod = 1\nwhile prod &lt; limit:\n    prod *= primes[maxPrimes]\n    maxPrimes += 1\n\nfor numOfFacts in range(1, maxPrimes):\n    for factorization in loopThroughFactorizations(numOfFacts, primes, limit):\n        rad = 1\n        for factor in factorization:\n            rad *= factor\n        for factorPowers in loopThroughFactorPowers(factorization, limit):\n            number = 1\n            for factor, power in zip(factorization, factorPowers):\n                number *= factor ** power\n            rads.append((rad, number))\nE = sorted(rads)\nprint(E[9999])\n\nRunning this code leads to an output of,\n(1947, 21417)\n0.41047860006801784 seconds.\n\nTherefore, $E(10000)=\\mathbf{21417}$, whose radical is 1947.\n",
      "categories": ["project_euler"],
      "tags": ["25_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-06-12-124-Ordered-radicals/"
    },{
      
      "title": "#126 - Cuboid layers",
      "date": "2019-06-21 09:21:00 +0000",
      
      "content": "\n  The minimum number of cubes to cover every visible face on a cuboid measuring 3 x 2 x 1 is twenty-two.\n\n  \n\n  If we then add a second layer to the solid it would require forty-six cubes to cover every visible face, the third layer would require seventy-eight cubes, and the fourth layer would require one-hundred and eighteen cubes to cover every visible face.\n\n  However, the first layer on a cuboid measuring 5 x 1 x 1 also requires twenty-two cubes; similarly the first layer on cuboids measuring 5 x 3 x 1, 7 x 2 x 1, 11 x 1 x 1 all contain forty-six cubes.\n\n  We shall define $C(n)$ to represent the number of cuboids that contain $n$ cubes in one of its layers. So $C(22) = 2, C(46) = 4, C(78) = 5$, and $C(118) = 8$.\n\n  It turns out that 154 is the least value of $n$ for which $C(n) = 10$.\n\n  Find the least value of $n$ for which $C(n) = 1000$.\n\n\n\nWe need to find a formula for the number of cubes given the initial dimensions and the layer. Then we need some bounds on the dimensions and layer amounts to perform an exhaustive search.\nFormula for the number of cubes\nSince we are completely covering the previous layer, the number of cubes will depend on the surface area of the initial cuboid. In the example, the surface area of the $3\\times 2\\times 1$ cuboid is 22, so we need 22 cubes for this first layer. Calculating the surface area after that is tricky, and the following graphic will help visualize the cubes. he squares marked in blue are where the “surface-area” cubes will lie, and then ones marked on red squares are where the rest will lie. These squares in red are repeated 4 times throughout the cuboid, so we multiply by 4 as shown.\n\n\n\nOur formula looks like it should be be $2(\\ell w + \\ell h+ wh) + 4(\\ell + w + h)(k-1)$. This works for $k=1$ and $k=2$. However, when $k=3$, the formula gives 70 cubes, while the actual answer is 78. The undercounting only grows as $k$ grows.\nExtra cubes\nFrom the 3rd layer on, we get extra corner cubes that do not get completely colored. Below, you can see what the second layer looks like. Each stud corresponds to a single cube.\n\n\n\nNow, if we were to cover it with the cubes we accounted for using the formula, here is what we cover. Remember, we cover the original shape, and the sides for each previous layer.\n\n\n\nNotice the yellow areas left uncovered on each corner? We can cover them with 2 cubes per corner, for a total of 8 cubes, which is exactly how many we were short. Just like how we have a $k-1$ factor for covering the steps, we have the same factor here because each time a layer gets added, an extra corner piece has to be added to be compensated. This, coupled with the fact these start appearing from the 3rd layer, means our extra factor is $4(k-2)(k-1)$. We can merge this and the previous factor to get our final formula of,\n\n[Cubes(\\ell, w, h, k) = 2(\\ell w+\\ell h + wh) + 4(\\ell + w + h + k - 2)(k-1)]\n\nFinding $C(n)$\nTo avoid looking at duplicate cubes, I’ll assume that $\\ell\\geq w\\geq h$. The method will examine all possible cuboid dimensions given the layer. Thus, we will start from the 1st layer, look at all cuboids whose first layer cubes don’t exceed a limit, then move onto the 2nd layer and do the same thing. We keep going until the worst-case cuboid (a 1 x 1 x 1) will exceed the cubes limit on the $k^{\\text{th}}$ layer.\n\nTo find bounds on the dimensions given the layer, we look at worst-case cuboids. If we leave the length to be variable, then in the worst-case, we have $w = h = 1$. If our cubes limit is $N$, then plugging in these values into our equation means we have\n\n[Cubes(\\ell, 1, 1, k) = 4k\\ell + 4k^2 - 4k + 2 \\leq N]\n\nSolving for $\\ell$, we get that\n\n\\(\\ell\\leq\\frac{n-2}{4k}-k+1\\)\nFor each value of $\\ell$, we constrain the width the same way, by assuming that the worst-case height is 1. The height is similar, only now both values of the length and width is inserted. As you can guess, the equations get more complicated:\n\n\\(\\begin{aligned}\n\tw &amp;= 2 + \\frac{2k(k+\\ell) - \\ell + n/2}{2k+\\ell-1}\n\t\\\\\n\th &amp;= 2 + \\frac{2k(1-k-\\ell-w)-\\ell w + n/2}{2k+\\ell+w-2}\n\\end{aligned}\\)\nImplementation\nThe code is a deep for-loop, with functions to calculate the upper bounds on the dimensions as well to calculate the number of cubes. I keep a running array of how many times I’ve calculated the same number of cubes. In the end, I find the smallest value where the count is 1000, which is achieved natively through .index(). I also needed some trial and error for the limit.\n# file: \"problem126.py\"\ndef cubesInKthLayer(l, w, h, k):\n    return 4 * (k - 1) * (l + w + h + k - 2) + 2 * (l * h + w * h + l * w)\n# Function to get maximum L possible given a k and\n# number of cubes n\ndef getMaxL(k, n):\n    return 1 - k + (n - 2) / (4 * k)\n# Function to maximu W possible given k, n, l\ndef getMaxW(l, k, n):\n    return 2 + (2 * k * (k + l) - l + n / 2) / (2 * k + l - 1)\n# Function to get max H possible given all others...\ndef getMaxH(l, w, k, n):\n    return 2 + (2 * k * (1 - k - l - w) - l * w + n / 2) / (2 * k + l + w - 2)\n\nlimit = 20000\n# Create array of this long which holds\n# C(n) for each index...\n# Values start with C(1) so\n# C(n) = C[n - 1]\nC = [0] * limit\n\n# While the kth layer results\n# in possible cuboids...\nk = 1\nL = getMaxL(k, limit)\nwhile L &gt; 1:\n    # Iterate over each length...\n    for l in range(1, int(L) + 1):\n        # Calculate max possible width\n        W = min(l, getMaxW(l, k, limit))\n        for w in range(1, int(W) + 1):\n            H = min(w, getMaxH(l, w, k, limit))\n            for h in range(1, int(H) + 1):\n                # Calculate number of cubes\n                # given the cuboid dimensions and\n                # layer k. Increment in the array\n                # by 1.\n                cuboids = cubesInKthLayer(l, w, h, k)\n                C[cuboids - 1] += 1\n\n    # Move up one layer and recalculate\n    # maximum possible length\n    k += 1\n    L = getMaxL(k, limit)\n\n# We want the first element in\n# C which is 1000.\nprint(C.index(1000) + 1)\n\nThe output the program gives us is\n18522\n2.3773630000650883 seconds.\n\nThus, the minimum value such that $C(n) = 1000$ is 18522.\n",
      "categories": ["project_euler"],
      "tags": ["55_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-06-21-126-Cuboid-layers/"
    },{
      
      "title": "#137 - Fibonacci golden nuggets",
      "date": "2019-06-21 14:19:00 +0000",
      
      "content": "\n  Consider the infinite polynomial series $A_F(x) = xF_1 + x^2F_2 + x^3F_3 + \\dots$, where $F_k$ is the $k^{\\text{th}}$ term in the Fibonacci sequence: 1, 1, 2, 3, 5, 8, …; that is, $F_k = F_{k-1} + F_{k-2}$, $F_1=1$ and $F_2=1$.\n\n  For this problem we shall be interested in values of $x$ for which $A_F(x)$ is a positive integer.\n\n  Surprisingly,\n\n\\[\\begin{aligned}\n\tA_F\\left(\\frac{1}{2}\\right) &amp;= \\left(\\frac{1}{2}\\right)(1) + \\left(\\frac{1}{2}\\right)^2(1) + \\left(\\frac{1}{2}\\right)^3(2) + \\left(\\frac{1}{2}\\right)^4(3) + \\cdots\n\t\\\\ &amp;=\n\t\\frac{1}{2} + \\frac{1}{4} + \\frac{2}{8} + \\frac{3}{16} + \\frac{5}{32} + \\cdots\n\t\\\\ &amp;= 2\n\\end{aligned}\\]\n\n  The corresponding values of $x$ for the first five natural numbers are shown below.\n\n  \n    \n      \n        $\\mathbf{x}$\n        $\\mathbf{A_F(x)}$\n      \n    \n    \n      \n        $\\sqrt{2}-1$\n        1\n      \n      \n        $\\frac{1}{2}$\n        2\n      \n      \n        $\\frac{\\sqrt{13}-2}{3}$\n        3\n      \n      \n        $\\frac{\\sqrt{89}-5}{8}$\n        4\n      \n      \n        $\\frac{\\sqrt{34}-3}{5}$\n        5\n      \n    \n  \n\n  We shall call $A_F(x)$ a golden nugget if $x$ is rational, because they become increasingly rarer; for example, the 10th golden nugget is 74049690.\n\n  Find the 15th golden nugget.\n\n\n\nI had to do a bit of research as to when exactly the golden nuggets occur, but it was worth it. Firstly though, infinite series are a tad annoying to work with, so I came up with a closed form formula for it.\n\n[\\begin{aligned}\n\tA_F(x) &amp;= \\sum_{n=1}^\\infty F_nx^n\n\t\\ &amp;=\n\tF_1x + F_2x^2 + \\sum_{n=3}^\\infty F_nx^n\n\t\\ &amp;=\n\tx + x^2 + \\sum_{n=3}^\\infty(F_{n-1} + F_{n-2})x^n\n\t\\ &amp;=\n\tx + x^2 + x\\sum_{n=3}^\\infty F_{n-1}x^{n-1} + x^2\\sum_{n=3}^\\infty F_{n-2}x^{n-2}\n\t\\ &amp;=\n\tx + x^2 + x\\sum_{n=2}^\\infty F_nx^n + x^2\\sum_{n=1}^\\infty F_nx^n\n\t\\ &amp;=\n\tx + x^2 + x(A_F(x) - x) + x^2A_F(x)\n\t\\ &amp;=\n\tx + xA_F(x) + x^2A_F(x)\n\t\n\tA_F(x) &amp;= \\frac{x}{1-x-x^2}\n\\end{aligned}]\n\nWe must find when this equals an integer $C$. Since we have a quadratic equation $x$, we can solve directly,\n\n[\\begin{aligned}\n\tC &amp;= \\frac{x}{1-x-x^2}\n\t\n\tCx^2 + x(C+1)-C &amp;= 0\n\t\n\tx &amp;= \\frac{-(C+1)\\pm\\sqrt{(C+1)^2-4C(-C)}}{2C}\n\t\\ &amp;=\n\t\\frac{-(C+1)\\pm\\sqrt{(C+1)^2+(2C)^2}}{2C}\n\\end{aligned}]\n\nRegardless of what happens with the other terms, the discriminant has to evaluate to a perfect square. This will lead to $x$ being rational and a golden nugget.\n\nFinding when the discriminant is a perfect square\nThis is where I had to some digging, and found a great paper by Dae S. Hong, When is the Generating Function of the Fibonacci Numbers an Integer?. All credit goes to the author for the insights. I’ve purposely written it as a sum of two squares to signify that we are in fact looking for Pythagorean triples of that form. I experimented and found the first 4 values where it results in a perfect square.\n| $C$ | Root of Discriminant | $x$             |\n| —– | ——————– | —————– |\n| 2     | 5                    | $\\frac{1}{2}$   |\n| 15    | 34                   | $\\frac{3}{5}$   |\n| 104   | 233                  | $\\frac{8}{13}$  |\n| 714   | 1597                 | $\\frac{21}{34}$ |\nNotice the numerator and denominator of the $x$ values. They are consecutive Fibonacci numbers! This shouldn’t come as a surprise since we started with a Fibonacci series.\n\nIf we assume $x=\\frac{F_n}{F_{n+1}}$ and plug it into $A_F(x)$, we get\n\n[\\begin{aligned}\nA_F\\left(\\frac{F_n}{F_{n+1}}\\right) &amp;= \\frac{\\frac{F_n}{F_{n+1}}}{1-\\frac{F_n}{F_{n+1}}-\\left(\\frac{F_n}{F_{n+1}}\\right)^2}\n\\ &amp;=\n\\frac{F_nF_{n+1}}{F_{n+1}^2-F_nF_{n+1}-F_n^2}\n\\ &amp;=\n\\frac{F_nF_{n+1}}{F_{n+1}(F_{n+1}-F_n)-F_n^2}\n\\ &amp;=\n\\frac{F_nF_{n+1}}{F_{n+1}F_{n-1}-F_n^2}\n\\end{aligned}]\n\nCassini’s Identity can result in simplifying all the way through,\n\n[A_F\\left(\\frac{F_n}{F_{n+1}}\\right) = (-1)^nF_nF_{n+1}]\n\nWe get an integer! With reference to the table above, $A_F(x)=2$ corresponds to $n=2$, and $A_F(x)=15$ corresponds to $n=4$. Our golden nuggets occur when $n$ is even. The reason is that when $n$ is odd, $(-1)^n$ will result in $A_F(x)$ being negative. However, $x$ is still positive, and when plugging that in to our infinite series, means the series is positive as well. Thus, having $n$ be odd is a mismatch to the infinite series definition.\n\nEvaluation\nSince $n$ is even, we can write it as $2k$. This means the $k^{\\text{th}}$ golden nugget is\n\n\\(A_F\\left(\\frac{F_{2k}}{F_{2k+1}}\\right) = (-1)^{2k}F_{2k}F_{2k+1} = F_{2k}F_{2k+1}\\)\nWe can verify from the problem statement that $k=10$ should result in 74049690 and we see it immediately:\n\n[F_{2(10)}F_{2(10)+1}=F_{20}F_{21}=6765(10946)=74049690]\n\nThus, to get the answer to the problem, just plug in 15!\n\n\\(F_{2(15)}F_{2(15)+1}=F_{30}F_{31}=832040(1346269)=1120149658760\\)\nTherefore, the 15th golden nugget is 1120149658760. No code required, unless we want to write a Fibonacci generator to find the 30th and 31st Fibonacci numbers.\n",
      "categories": ["project_euler"],
      "tags": ["50_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-06-21-137-Fibonacci-golden-nuggets/"
    },{
      
      "title": "#140 - Modified Fibonacci golden nuggets",
      "date": "2019-06-23 16:06:00 +0000",
      
      "content": "\n  Consider the infinite polynomial series $A_G(x) = xG_1+x^2G_2+x^3G_3+\\cdots$, where $G_k$ is the $k$th term of the second order recurrence relation $G_k=G_{k-1}+G_{k-2}$, $G_1=1$ and $G_2=4$; that is, $1,4,5,9,14,23, \\dots$.\n\n  For this problem we shall be concerned with values of $x$ for which $A_G(x)$ is a positive integer.\n\n  The corresponding values of $x$ for the first five natural numbers are shown below.\n\n  \n    \n      \n        $x$\n        $A_G(x)$\n      \n    \n    \n      \n        $\\frac{\\sqrt{5}-1}{4}$\n        1\n      \n      \n        $\\frac{2}{5}$\n        2\n      \n      \n        $\\frac{\\sqrt{22}-2}{6}$\n        3\n      \n      \n        $\\frac{\\sqrt{137}-5}{14}$\n        4\n      \n      \n        $\\frac{1}{2}$\n        5\n      \n    \n  \n\n  We shall call $A_G(x)$ a golden nugget if $x$ is rational, because they become increasingly rarer; for example, the 20th golden nugget is 211345365.\n\n  Find the sum of the first thirty golden nuggets.\n\n\n\nThis problem is very similar to #137 - Fibonacci golden nuggets where we dealt with Fibonacci numbers. These are Fibonacci-like, but not quite the same sequence. However, it’s natural to assume a similar pattern will follow, and so we will do the same steps. First, we’ll rewrite the sequence definition as a closed form formula:\n\n[\\begin{aligned}\n\tA_G(x) &amp;= \\sum_{n=1}^\\infty G_n x^n\n\t\\ &amp;=\n\tG_1x + G_2x^2 + \\sum_{n=3}^\\infty G_n x^n\n\t\\ &amp;=\n\tx + 4x^2 + \\sum_{n=3}^\\infty \\left(G_{n-1} + G_{n-2}\\right)x^n\n\t\\ &amp;=\n\tx + 4x^2 + x\\sum_{n=3}^\\infty G_{n-1}x^{n-1} + x^2\\sum_{n=3}^\\infty G_{n-2}x^{n-2}\n\t\\ &amp;=\n\tx + 4x^2 + x\\sum_{n=2}^\\infty G_n x^n + x^2\\sum_{n=1}^\\infty G_n x^n\n\t\\ &amp;=\n\tx + 4x^2 + x\\left(A_G(x) - x\\right) + x^2A_G(x)\n\t\\ &amp;=\n\tx + 3x^2 + xA_G(x) + x^2A_G(x)\n\t\n\tA_G(x) &amp;= \\frac{x+3x^2}{1-x-x^2}\n\\end{aligned}]\n\nLet $A_G(x) = C$ and use the quadratic formula to solve for $x$:\n\n[\\begin{aligned}\n\tC &amp;= \\frac{x+3x^2}{1-x-x^2}\n\t\n\tx^2(C+3)+x(C+1)-C &amp;= 0\n\t\n\tx &amp;= \\frac{-(C+1)\\pm \\sqrt{(C+1)^2-4(C+3)(-C)}}{2(C+3)}\n\t\\ &amp;=\n\t\\frac{-(C+1)\\pm\\sqrt{(C+1)^2+4C^2+12C}}{2(C+3)}\n\t\\ &amp;=\n\t\\frac{-(C+1)\\pm\\sqrt{5C^2+14C+1}}{2(C+3)}\n\\end{aligned}]\n\nThe discriminant needs to be a perfect square to yield an integer. Let’s first find a few values of $C$ that results in a perfect square and see if we recognize a pattern.\n| $C$     | Root of Discriminant | $x$             |\n| —– | ——————– | —————– |\n| 2     | 7                    | $\\frac{2}{5}$   |\n| 5     | 14                   | $\\frac{1}{2}$   |\n| 21    | 50                   | $\\frac{7}{12}$  |\n| 42    | 97                   | $\\frac{3}{5}$   |\n| 152   | 343                  | $\\frac{19}{31}$ |\n| 296   | 665                  | $\\frac{8}{13}$  |\n| 1050  | 2351                 | $\\frac{50}{81}$ |\n| 2037  | 4558                 | $\\frac{21}{34}$ |\nWe see the Fibonacci fractions, but also other fractions. These non-Fibonacci fractions also follow their own Fibonacci rule (2, 5, 7, 12, …). These fractions come from adding the Fibonacci to the $G_n$ sequence:\n\n[{1,1,2,3,5,8,\\dots}\\,+\\,{1,4,5,9,14,23,\\dots} = {2,5,7,12,19,31,\\dots}]\n\nWith this fact, we can conclude that the $x$-value associated with the $n$th golden nugget is\n\n[x_n=\\begin{cases}\n\t\\frac{F_n+G_n}{F_{n+1}+G_{n+1}} \\qquad &amp;n\\text{ is odd}\n\t\n\t\\frac{F_n}{F_{n+1}} \\qquad &amp;n\\text{ is even}\n\\end{cases}]\n\nLet $H_n = F_n + G_n$. We can plug these into the function and get formulas for the $n$th golden nugget $C_n$:\n\n[C_n=\\begin{cases}\n\t\\frac{H_nH_{n+1}+3H_n^2}{11} \\qquad &amp;n\\text{ is odd}\n\t\n\tF_nF_{n+1}+3F_n^2 \\qquad &amp;n\\text{ is even}\n\\end{cases}]\n\nLike with the regular Fibonacci numbers, $H_n$ also has it’s own “Cassini’s Identity”. In this case, $H_{n+1}H_{n-1}-H_n^2=11(-1)^{n+1}$. We can prove this by induction, just like the normal Cassini’s Identity.\n\nNow that we have a direct formula, it is simple to code a loop to calculate the sum of the first 30 golden nuggets.\n# file: \"problem140.py\"\nH = [3, 2, 5]\nF = [0, 1, 1]\nfor _ in range(3, 32):\n    H.append(H[-2] + H[-1])\n    F.append(F[-2] + F[-1])\n\n# Now compute the sum of the first 30 thirty nuggets\ngoldenNuggetSum = 0\nfor n in range(1, 31):\n    if n % 2 == 1:\n        goldenNuggetSum += (H[n] * H[n + 1] + 3 * H[n] ** 2) // 11\n    else:\n        goldenNuggetSum += F[n] * F[n + 1] + 3 * F[n] ** 2\n\nprint(f'The sum of the first 30 golden nuggets is {goldenNuggetSum}.')\n\n\nRunning this short code, we get\nThe sum of the first 30 golden nuggets is 5673835352990.\n5.6199999999950734e-05 seconds.\n\nTherefore, our golden nugget sum is 5673835352990.\n",
      "categories": ["project_euler"],
      "tags": ["55_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-06-23-140-Modified-Fibonacci-golden-nuggets/"
    },{
      
      "title": "#139 - Pythagorean tiles",
      "date": "2019-06-23 18:54:00 +0000",
      
      "content": "\n  Let $(a,b,c)$ represent the three sides of a right angle triangle with integral length sides. It is possible to place four such triangles together to form a square with length $c$.\n\n  For example, (3, 4, 5) triangles can be placed together to form a 5 by 5 square with a 1 by 1 hole in the middle and it can be seen that the 5 by 5 square can be tiled with twenty-five 1 by 1 squares.\n\n  \n\n  However, if (5, 12, 13) triangles were used, then the hole would measure 7 by 7 and these could not be used to tile the 13 by 13 square.\n\n  Given that the perimeter of the right triangle is less than one-hundred million, how many Pythagorean triangles would allow such a tiling to take place?\n\n\n\nWe can use our useful Pythagorean generation technique. We will calculate the size of the hole first. We have a square of side length $c$ with four triangles. Thus, we subtract the area of the 4 triangles from the area of the larger square:\n\n[c^2-4\\left(\\frac{1}{2}ab\\right) = c^2-2ab = a^2+b^2-2ab = (a-b)^2]\n\n\n  \n    \n      SquareSquare rooting this expression gets us the side length of $a-b$. Since we don’t know which variable is bigger, we can take the absolute value. **Therefore, this means the triples we are interested are those where $\\mathbf{\n      a-b\n      =1}$**.\n    \n  \n\n\nRepeatedly appling the $B$ matrix preserves exactly this property. We do not need to run our recursive function, and just keep multiplying by $B$ until we surpass the perimeter threshold.\n# file: \"problem139.py\"\nB = np.array([\n    [1, 2, 2],\n    [2, 1, 2],\n    [2, 2, 3]\n], dtype=object)\n\ntilings = 0\nlimit = 100000000\n\n# Only of square 1 can divide...\ntriple = np.array([3, 4, 5])\nwhile sum(triple) &lt; limit:\n    print(tilings)\n    # This has a square of 1.\n    tilings += limit // sum(triple)\n    triple = np.dot(B, triple)\n\nprint(tilings)\n\nRunning this short loop results in an output of,\n10057761\n0.00013170000000001236 seconds.\n\nTherefore, our final answer is 10057761.\n",
      "categories": ["project_euler"],
      "tags": ["50_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-06-23-139-Pythagorean-tiles/"
    },{
      
      "title": "#193 - Squarefree Numbers",
      "date": "2019-07-11 12:47:00 +0000",
      
      "content": "\n  A positive integer $n$ is called squarefree, if no square of a prime divides $n$, thus 1, 2, 3, 5, 6, 7, 10, 11 are squarefree, but not 4, 8, 9, 12.\n\n  How many squarefree numbers are there below $2^{50}$?\n\n\n\nThe opposite of squarefree is squareful. There are fewer squareful numbers than squarefree, so we’ll counting the squareful numbers and subtracting from the limit. The limit of $2^{50}$ is too big to create a bit array. However, we are only concerned numbers which contain squares of primes, so we only need primes up to the square root of the limit, or $2^{25}$ in this case.\n\nTo count the number of squareful numbers, we use the principle of inclusion/exclusion, as follows.\n\n  Add the numbers that contain a single square prime i.e. multiples of 4, 9, 16, etc.\n  When we do step 1, we double-added numbers that had two square prime factors (multiples of 36, 64, etc.), so we subtract these numbers.\n  We double-subtracted the numbers that had three square prime factors (900 is the smallest such number), so we add these back in.\n  …Continue alternating adding and subtracting numbers with 4, 5, … square prime factors, until the limit is crossed.\n\n\nGiven the upper limit $L$ and the product $P$, the number of multiples is simply $\\lfloor L/P^2\\rfloor$, which we will use to prevent looping through all the multiples, and instead only worry about the distinct square prime factors.\n\nWe need a list of primes up till $\\sqrt{L}$, and we also need to know the maximum number of square primes we can multiply before crossing this limit, which can easily be calculated. In our case, this is 8.\n\nTo handle our inclusion/exclusion counting, I use a recursive function. This keeps track of $L$, the number of factors left $x$, the current product $P$, and the list of primes $p_1, p_2,\\dots$. The base case is when $x=1$, and we yield the current product multiplied with each prime factor.\n\nOtherwise, we loop through each prime and do the following steps:\n\n  We keep looping until the current product multiplied by the next $x$ factors exceeds the limit.\n  For each chosen prime $p_i$, the prime list is cut down to be in the range $[p_i+1,L/(P\\times p_i)]$. The limit stays the same, since this is needed by each recursive call. The number of factors goes down by 1, the current product is updated through the multiplication with $p_i$.\n\n\nTo add the products when $x$ is odd, and subtract if $x$ is even, we multiply a $-1^{x+1}$ factor. This code counts the squareful numbers starting from 2, so we subtract from the limit, and account for 1 being squarefree.\n# file: \"problem193.py\"\ndef genProducts(primes, limit, factors=1, currProd=1):\n    if factors == 1:\n        for prime in primes:\n            yield currProd * prime\n        return\n    i = 0\n    while currProd * np.prod(primes[i:i + factors]) &lt; limit:\n        prime = primes[i]\n        for product in genProducts(primesieve.primes(prime + 1, limit / (currProd * prime)), limit=limit,\n                                   factors=factors - 1,\n                                   currProd=currProd * prime):\n            yield product\n        i += 1\n\n\nlimit = 2 ** 50\nprimes = primesieve.primes(limit ** 0.5)\nsquareFulNums = 0\n# Find maximum number of factors...\ni = 1\nprod = 2\nwhile prod &lt;= limit ** 0.5:\n    prod *= primes[i]\n    i += 1\nmaxFactors = i - 1\n\nfor numOfFactors in range(1, maxFactors + 1):\n    totalProdCount = 0\n    for product in genProducts(primes=primes, limit=limit ** 0.5, factors=numOfFactors, currProd=1):\n        totalProdCount += (limit // product ** 2)\n    squareFulNums += (-1) ** (numOfFactors + 1) * totalProdCount\n\nprint(limit - squareFulNums + 1)\n\nOur output is thus,\n684465067343070\n12.7108755 seconds.\n\nTherefore, the number of squarefree numbers under $2^{50}$ is 684465067343070.\n",
      "categories": ["project_euler"],
      "tags": ["55_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-07-11-193-Squarefree-numbers/"
    },{
      
      "title": "#191 - Prize Strings",
      "date": "2019-07-13 19:18:00 +0000",
      
      "content": "\n  A particular school offers cash rewards to children with good attendance and punctuality. If they are absent for three consecutive days or late on more than one occasion then they forfeit their prize.\n\n  During the $n$-day period a trinary string is formed for each child consisting of L’s (late), O’s (on time), and A’s (absent).\n\n  Although there are eight-one trinary strings for a 4-day period that can be formed, exactly forty-three strings would lead to a prize:\n\n  \n    OOOO OOOA OOOL OOAO OOAA OOAL OOLO OOLA OAOO OAOA\nOAOL OAAO OAAL OALO OALA OLOO OLOA OLAO OLAA AOOO\nAOOA AOOL AOAO AOAA AOAL AOLO AOLA AAOO AAOA AAOL\nAALO AALA ALOO ALOA ALAO ALAA LOOO LOOA LOAO LOAA\nLAOO LAOA LAAO\n\n\n  How many “prize” strings exist over a 30-day period?\n\n\n\nWe want all strings of length $n$ where we do not have 3 consecutive A’s nor more than one L. It’s easier to count the complement, and subtract from the total. So we’ll find the number of strings with less than 2 L’s and 3 consecutive A’s.\nLess than 2 L’s\nWe break this up into two cases: strings without any L’s, and strings with exactly one L:\n\n  Zero L’s: Our only option is “O” or “A” for each letter. With $n$ letters, there are $2^n$ such strings.\n  One L: We can place the “L” in any one of $n$ spots. The other $n-1$ letters have to be either “O” or “A”. Thus, there are $n2^{n-1}$ such strings.\n\n\nTogether, we have $2^n+n2^{n-1} = 2^{n-1}(n+2)$ strings with less than two Ls.\nThree consecutive A’s AND less than 2 L’s\nThis is more involved, and like before, we break this into cases. Let $f(n)$ be the number of strings with no L’s and 3 consecutive A’s, and $g(n)$ be the number of strings with one L and 3 consecutive A’s.\nFinding $f(n)$\nAssume we have one such $n$-character string. Then it can be exactly one of the following:\n\n  Ends with “AAA”: The first $n-3$ characters can be any of “O” or “A”. There are $2^{n-3}$ of these.\n  Ends with “O”: The first $n-1$ characters must contain 3 consecutive A’s and no L’s, of which there are $f(n-1)$.\n  Ends with “OA”: The first $n-2$ characters must contain 3 consecutive A’s and no L’s, of which there are $f(n-2)$.\n  Ends with “OAA”: This set contains $f(n-3)$ strings.\n\n\nTherefore, our formula for the number of strings with 3 consecutive A’s and no L’s is\n\n[f(n)=2^{n-3}+f(n-1)+f(n-2)+f(n-3)=\\boxed{2^{n-3}+\\sum_{i=1}^3f(n-i)}]\n\nFinding $g(n)$\nWe can still break these into cases:\n\n  Ends with “AAA”: The first $n-3$ characters can be any of “O” or “A”, in addition to the fact that we need one L. There are $n-3$ spots to place the L, and the other $n-4$ can be any of the other two. In total, there are $(n-3)2^{n-4}$.\n  Ends with “O”: The first $n-1$ must be one of $g(n-1)$ strings. You can immediately see what the next two cases amount to.\n  Ends with “OA”: $g(n-2)$.\n  Ends with “OAA”: $g(n-3)$.\n  Ends with “L”: This is one of the extra cases we must consider. In this case, the first $n-1$ characters must contain 3 consecutive A’s. How many strings is that? Well that’s just the $f(n-1)$ we calculated in the previous section!\n  Ends with “LA”: The first $n-2$ must have “AAA”, which count for $f(n-2)$ strings.\n  Ends with “LAA”: $f(n-3)$.\n\n\nAdding up all the cases, we get\n\n\\(\\begin{aligned}\n\tg(n) &amp;= (n-3)2^{n-4}+\\sum_{i=1}^3(g(n-i)+f(n-i))\n\t\\\\ &amp;=\n\t(n-3)2^{n-4}+\\sum_{i=1}^3g(n-i)+\\sum_{i=1}^3 f(n-i)\n\t\\\\ &amp;=\n\t(n-3)2^{n-4}+\\sum_{i=1}^3 g(n-i)+ f(n)-2^{n-3}\n\t\\\\ &amp;=\n\t\\boxed{2^{n-4}(n-5)+\\sum_{i=1}^3 g(n-i)}\n\\end{aligned}\\)\nFinal amount\nWe take the number of strings which have zero or one L, and subtract off those which contain 3 consecutive A’s. In all, this is\n\n\\(a(n)=2^{n-1}(n+2)-f(n)-g(n)\\)\nSince $f(n)$ and $g(n)$ are recursive, we calculate all of these beforehand, and a single line to calculate the final amount is needed.\n# file: \"problem191.py\"\nlimit = 30\n# Make the fn and gn arrays up until limit...\nf = [0] * (limit + 1)\ng = [0] * (limit + 1)\n# fn = 2^(n-3) + (3 previous terms)\n# gn = 2^(n-4)*(n-5) + (3 previous terms) + fn\nfor n in range(3, limit + 1):\n    f[n] = 2 ** (n - 3) + sum(f[n - 3:n])\n    g[n] = 2 ** (n - 4) * (n - 5) + sum(g[n - 3:n]) + f[n]\n\n# Answer is 2^(n-1) * (n+2) - fn - gn\nprint(int(2 ** (limit - 1) * (limit + 2) - f[limit] - g[limit]))\n\nRunning this short code, we get\n1918080160\n7.449999999997736e-05 seconds.\n\nTherefore, there are 1918080160 such prize strinsg for 30 days.\n",
      "categories": ["project_euler"],
      "tags": ["35_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-07-13-191-Prize-strings/"
    },{
      
      "title": "#233 - Lattice points on a circle",
      "date": "2019-07-20 16:10:00 +0000",
      
      "content": "\n  Let $f(N)$ be the number of points with integer coordinates that are on a circle passing through $(0,0),(N,0),(0,N)$, and $(N,N)$.\n\n  It can be done shown that $f(10000)=36$.\n\n  What is the sum of all positive integers $N\\leq 10^{11}$ such that $f(N)=420$?\n\n\n\nThis is one of my favorite problems that I’ve solved for. As for the circle, it passes through 4 points of a square with side length $N$. Since it circumscribes the square the diameter of the circle is the diagonal of the square, namely $N\\sqrt{2}$. The radius is then $N\\sqrt{2}/2$. Both the circle and square also have the same center. Therefore, the center of the circle is $(N/2, N/2)$. So, our equation for this circle is\n\n[\\left(x-\\frac{N}{2}\\right)^2+\\left(y-\\frac{N}{2}\\right)^2=\\frac{N^2}{2}]\n\nThe solution is long, and before I dive in, you should watch the following video, as it gives extremely useful information in solving the problem. It is by Grant Sanderson of the YouTube channel 3Blue1Brown.\n\n\nTo summarize the key points:\n\n  The number of lattice points that a circle centered at the origin with radius $\\sqrt{N}$ crosses is dependent on the prime factorization of $N$.\n  Write the factorization of $N$ as $2^{a_0}\\left( 5^{b_1} 13^{b_2}\\cdots\\right)\\left( 3^{c_1}7^{c_2}\\cdots \\right)$ where the primes associated with $b_i$ are one above a multiple of 4 and the primes associated with $c_i$ are one below a multiple of 4.\n  The number of lattice points is $4(b_1+1)(b_2+1)\\cdots=4\\prod_{i=1}^\\infty(b_i+1)$\n  If any $c_i$ is odd, then the number of lattice points is 0. Otherwise, they do not affect the count.\n  Factors of 2 do not affect the count.\n\n\nThis is all well and good, but there is one catch with this problem.\n\nGrant’s Circle vs. Our Circle\nThe circle in the video is centered at the origin and has radius $\\sqrt{N}$, while our circle doesn’t have that center, nor that radius. If $N$ is even, then our circle lands at a lattice point, which we can translate back to the origin and compute that way. However, if $N$ is odd, then it doesn’t land a lattice point.\n\nBut I claim that we can transform our existing problem into exactly the one shown in the video. In other words, the two circles\n\n\\(\\begin{aligned}\n    \\left(x-\\frac{N}{2}\\right)^2 + \\left(y-\\frac{N}{2}\\right)^2 &amp;= \\frac{N^2}{2}\n    \\\\\n    x^2+y^2 &amp;= N^2\n\\end{aligned}\\)\nwill cross the same number of lattice points. We break this up into cases, either $N$ is even, or $N$ is odd.\n$N$ is even\n$N$ can be represented as $2k$, where $k$ is any integer. Substituting into our original circle, we get\n\n[\\begin{aligned}\n    \\left(x-\\frac{2k}{2}\\right)^2 + \\left(y-\\frac{2k}{2}\\right)^2 &amp;= \\frac{(2k)^2}{2}\n    \n    (x-k)^2+(y-k)^2 &amp;= 2k^2\n\\end{aligned}]\n\nThis is a circle centered at $(k,k)$, which is in effect can be our “origin”. Next, remember that factors of 2 do not affect the count. Thus, a circle with radius $\\sqrt{2k^2}$ will cross the same number of lattice points as one with radius $\\sqrt{2\\cdot2k^2}$. But $\\sqrt{2\\cdot2k^2} = \\sqrt{4k^2}=\\sqrt{(2k)^2}=\\sqrt{N^2}=N$. Therefore, we can make the radius of the circle be $N$ and not effect the count.\n$N$ is odd\nIf $N$ is odd, then the right-hand side (RHS) of the eqution will stay as a fraction. This means the square on the left-hand side (LHS) must also be a fraction. We can then assume something like this:\n\n[\\begin{aligned}\n\\left( x-\\frac{N}{2} \\right)^2 &amp;= \\frac{a^2}{4}\n\n\\left( y-\\frac{N}{2} \\right)^2 &amp;= \\frac{b^2}{4}\n\\end{aligned}]\n\nwhere $a$ and $b$ are integers. Adding these, our equation becomes\n\n[\\begin{aligned}\n    \\frac{a^2}{4} + \\frac{b^2}{4} &amp;= \\frac{N^2}{2}\n    \n    a^2+b^2 &amp;= 2N^2\n\\end{aligned}]\n\nThe last equation is a circle centered on the origin. Additionally, factors of 2 don’t affect count, which means this crosses the same amount of lattice points.\n\nWorking Through the Problem’s Example\nWe have convinced ourselves that the problem circle will cross the same amount of lattice points as the one that is centered on the origin with radius $N$. I’ll quickly work through the given example in the problem, where $N=10000$. We need to factorize the radius $10000^2 = 10^8$.\n\nThe video was dealing with a circle with radius $\\sqrt{N}$ and he factorized $N$. Here, we have a radius of $N$ and so we must factorize $N^2$\n\nThe prime factorization of $N^2=10^8$ is $2^8\\times 5^8$. Factors of 2 don’t affect the count. 5 can be broken down into complex factors. Add one to the exponent, then multiply by 4. Therefore, the total is 36, just as the problem.\n\nEach exponent of the factorization of $N^2$ will be even. If Gaussian primes (3, 7, etc.) have even exponents, then that does not affect the count. This fact becomes important when we find a way to solve the problem.\nSolving the Problem\nThis problem is actually asking for the inverse of what we just did. Given the number of points $P$, what values of $N$ whose circles cross that number of points?\n\nWe can work backwards. If we know $P$, we can divide by 4, and find the factorization of $P$. For example, in the problem, the anwser is 36. Divide by 4 and we get 9. This means in the prime exponents, we have either one 8, or two exponents that are 2 (3 times 3 = 9). We can include another non-Gaussian prime in our factorization, and so another solution to this is $2^4\\times 5^2\\times 13^2=67600=260^2$. Since Gaussian primes are squared and don’t affect the count, here’s another solution: $2^2\\times 3^2\\times 5^2\\times 7^2\\times 17^2 = 12744900 = 3570^2$. To get all values of $N$ below a limit $L$, we need to mix and match the exponents of the non-Gaussian primes (5, 13, 17, etc.) with the exponents of 2 and the Gaussian primes.\n\nHere’s another we look at the example. Since we need the exponents in $N^2$ to either be 8 or two 2s, the exponents in $\\mathbf{N}$ need to be either 4 or two 1s (because we are squaring which doubles the exponents). We’re almost at the point where we can get an algorithm to search all $N$ up to $L$.\n\nExample of $N=36$ and $L=1000$\nWe have two separate cases, either a single non-Gaussian prime raised to the 4th power, or two separate singleton primes. The smallest prime that can affect the count is 5. Only $5^4=625&lt;1000$, so that’s the only value below our limit for the 4th power case.\n\nThe next case is two singleton primes. Since the smallest (non-Gaussian) prime is 5, the other factor needs to be less than 1000/5 = 200. The next is 13, so the smallest $N$ that crosses 36 lattice points is $5\\times 13=65$.\n\nBut we can also take all the other Gaussian primes (3, 7, etc.) in addition 2 and include them in the product as well e.g. $2\\times3\\times5\\times13=390$, $3^2\\times5\\times13=585$, and $2\\times7\\times5\\times13=910$ all cross 36 lattice points. We have a separate set of products that we can multiply with $5\\times 13$ in order to get $N$s that cross 36 points.\n\nThis other product can’t exceed $\\lfloor 1000/65 \\rfloor=15$. We can multiply by any number between 2 and 14, except 5 and 10, as those are multiples of 5 and therefore affect the count. Multiplying 65 by each of these numbers will get additional $N$s that cross 36 points.\n\nOnce we’re done with 65, we move to $5\\times 17=85$ and repeat the process.\n\nAlgorithm\nGiven the number of crossed lattice points $C$ and the limit $L$, our algorithm is as follows:\n\n  Divide $C$ by 4, and find all possible products that will result in $C/4$. Subtract one and halve the values to obtain the exponent values for $N$.\n  For each set of exponents, get all possible products that only consist of non-Gaussian primes ($1\\mod 4$) below $L$. Let this set be $P_1$.\n  For each product $r$ in $P_1$, generate a second set of products $P_2$ less than $L/r$ whose factorizations only consist of 2 and primes that are $3\\mod 4$.\n  Multiply $r$ by each product in $P_2$ to obtain an $N$ value less than $L$ that crosses exactly $C$ lattice points.\n\n\nImplementation\nOur number is 420. Divide by 4 and we have 105. The prime factorization of 105 is $3\\times 5\\times 7$. Now we must find all possible values of the exponents.\n\n  One is cubed, one is squared, and the other is a singleton: ${3,2,1}$ (Taken directly from the 3, 5, and 7. Subtract one and divide by 2).\n  One is raised to the 10th power, and the other is squared: ${10, 2}$ (This comes from $21\\times 5 = 105$)\n  One is raised to the 7th power, and the other is cubed: ${7, 3}$ (This comes from $15\\times 7=105$)\n\n\nWe will need to loop through each case, as well as a list of $1\\mod 4$ primes and products of $3\\mod 4$ primes (including 2). We only need primes until $\\frac{10^{11}}{5^313^2}=4\\,733\\,727$, because our smallest solution is $5^3\\times13^2\\times17=359125$.\n\nFor each power case, we reduce the limit by the prime we select raised to that power. The most constraining case of a 10th and 7th power will result in the limit reducing fairly quickly. This theme is present for all the loops we have (e.g. given a chosen prime $p$ for the 10th power, the next prime for the 7th power has to be less than $\\sqrt[7]{L/p^{10}}$. The three loops and full code is below.\n# file: \"problem233.py\"\nlimit = 10 ** 11\n# Maximum prime list we need\n# is up to 10^11 / (5^3 * 13^2)\nprimeBound = limit / (125 * 169)\nprimes = primesieve.numpy.primes(primeBound)\n# Grab all primes that are of 1 mod 4\nprimes = primes[primes % 4 == 1]\n\n# Now the sieve of all integers that\n# HAVE at least one factor from the prime list.\n# The max size possible should be\n# 10^11 / (5^3 * 13^2 * 17), since that is our\n# smallest solution.\nsieveLimit = int(primeBound / 17)\nsieve = np.zeros(sieveLimit + 1, dtype=np.uint8)\nfor prime in primes:\n    # Grab multiples\n    multiples = np.arange(prime, sieveLimit + 1, prime)\n    # Set all locs to one...\n    sieve[multiples] = 1\n\n# Cases 1 and 2, powers of 10 and 2, and powers of 7 and 3\ntotal = 0\nfor ex1, ex2 in [(10, 2), (7, 3)]:\n    for p1 in primes[primes &lt; limit ** (1/ex1)]:\n        # Now we need all the different primes\n        # that are less than the square/cube root\n        # of 10^11 / prime^10\n        for p2 in primes[(primes &lt; (limit / p1 ** ex1) ** (1/ex2)) &amp; (primes != p1)]:\n            value = p1 ** ex1 * p2 ** ex2\n            numOfMultiplies = limit // value\n            # Get non 1 mod 4 prime multiples, multiply them,\n            # and finally sum them...\n            # DON'T INCLUDE 0...\n            multiples = np.where(sieve[:numOfMultiplies + 1] == 0)[0][1:]\n            total += np.sum(value * multiples)\n\n# Case 3, where we have THREE primes,\n# one cubed, squared, and the remaining just multiplied.\nfor p1 in primes[primes &lt; limit ** (1/3)]:\n    # Next is squared...\n    for p2 in primes[(primes &lt; (limit / p1 ** 3) ** (1/2)) &amp; (primes != p1)]:\n        # Next get all individually...\n        for p3 in primes[(primes &lt; limit / (p1 ** 3 * p2 ** 2)) &amp; (primes != p1) &amp;\n                         (primes != p2)]:\n            value = p1 ** 3 * p2 * p2 * p3\n            numOfMultiplies = limit // value\n            multiples = np.where(sieve[:numOfMultiplies + 1] == 0)[0][1:]\n            total += np.sum(value * multiples)\n\nprint(total)\n\nFinally, running this monster code gives us\n271204031455541309\n7.3993970000000004 seconds.\n\nTherefore, the sum of all $N&lt;10^{11}$ where the circle passes through exactly 420 lattice points is 271204031455541309. A massive number for a problem that took a massive amount of time.\n",
      "categories": ["project_euler"],
      "tags": ["70_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-07-20-233-Lattice-points-on-circle/"
    },{
      
      "title": "#68 - Magic 5-gon ring",
      "date": "2019-08-13 17:40:00 +0000",
      
      "content": "\n  Consider the following “magic” 3-gon ring, filled with numbers 1 to 6, and each line adding to nine.\n\n  \n\n  Working clockwise, and starting from the group of three with the numerically lowest external node (4,3,2 in this example), each solution can be described uniquely. For example, the above solution can be described by the set: 4,3,2; 6,2,1; 5,1,3.\n\n  It is possible to complete the ring with four different totals: 9, 10, 11, and 12. There are eight solutions in total.\n\n  \n    \n      \n        Total\n        Solution Set\n      \n    \n    \n      \n        9\n        4,2,3; 5,3,1; 6,1,2\n      \n      \n        9\n        4,3,2; 6,2,1; 5,1,3\n      \n      \n        10\n        2,3,5; 4,5,1; 6,1,3\n      \n      \n        10\n        2,5,3; 6,3,1; 4,1,5\n      \n      \n        11\n        1,4,6; 3,6,2; 5,2,4\n      \n      \n        11\n        1,6,4; 5,4,2; 3,2,6\n      \n      \n        12\n        1,5,6; 2,6,4; 3,4,5\n      \n      \n        12\n        1,6,5; 3,5,4; 2,4,6\n      \n    \n  \n\n  By concatenating each group it is possible to form 9-digit strings; the maximum string for a 3-gon ring is 432621513.\n\n  Using the numbers 1 to 10, and depending on arrangements, it is possible to form 16- and 17-digit strings. What is the maximum 16-digit string for a “magic” 5-gon ring?\n\n  \n\n\n\nThe string will concatenate 15 numbers, 3 for each of the 5 arms. Numbers on the inner ring will be repeated twice. If 10 is on the outer ring, then it will be present once in the string, which means the length of the string will be 16 (one digit for 14 circles, plus 2 for the single 10). Thus, 10 has to be on the outer ring.\n\nTo ensure proper looping without resorting to brute force, we can loop through all sets of 5 unique numbers that contain 10 to place in the outer ring. Since ring strings start with the smallest number, we can use this to enforce the ordering.\n\nOnce the 5 numbers are placed, we can fill in the first arm using 2 numbers. This sets the sum in stone that must be satisfied in the other 4 arms. We test if a solution is possible using the remaining numbers.\n\nI use itertools.permutations to quickly loop through the groups of 5 numbers.\n# file: \"problem068.py\"\ndef filterOut(toRemove, origList):\n    return [ele for ele in origList if ele not in toRemove]\n\n# Okay, so basically, we have to\n# loop through all possible locations\n# for numbers in the outer circle and\n# pair of numbers for the first petal.\nmaxNum = 10\nnumList = list(range(1, maxNum + 1))\nc = 0\nallPerms = []\nfor i in range(1, maxNum + 1):\n    for perm in permutations(list(range(i + 1, maxNum + 1)), maxNum // 2 - 1):\n        if 10 in perm:\n            allPerms.append((i,) + perm)\n            c += 1\nfor perm in allPerms:\n    # Get numbers that are remaining\n    copied = filterOut(perm, numList)\n    # All possible pairs of numbers that can be placed\n    # into the 2 remaining circles.\n    for pair in permutations(copied, 2):\n        # Make a small 2d array of the sums...\n        ring = np.zeros((maxNum // 2, 3), dtype=int)\n        ring[:, 0] = perm\n        # Assign the pair...\n        ring[0, 1:] = pair\n        # The second number in the pair is also the\n        # second number in the second leg...\n        ring[1, 1] = pair[1]\n        # The first number in the pair is also\n        # the third number in the last leg\n        ring[-1, 2] = pair[0]\n        # Calculate the required sum\n        sumToMeet = sum(ring[0])\n        # Filter out the pair...\n        innerNumsLeft = filterOut(pair, copied)\n        # Okay, we have our sum and starting\n        # numbers. Now we can keep putting\n        # required numbers until it's impossible\n        # to put anymore. We keep removing from the list.\n        # If we finish the loop, and the list is empty,\n        # then we've placed everything..\n        i = 1  # Current sum row.\n        while len(innerNumsLeft) &gt; 0 and i &lt; maxNum // 2 - 1:\n            # Calculate number that should go here...\n            requiredNum = sumToMeet - sum(ring[i])\n            # If the required number is not in the list,\n            # then it's impossible, and we break and go\n            # to the next setup.\n            if requiredNum not in innerNumsLeft:\n                break\n            # If this is the last number\n            # placed, we also need to check\n            # the other leg that has been filled.\n\n            # Otherwise remove it, add it to\n            # the ring, and go to the next leg.\n            ring[i, 2] = requiredNum\n            ring[i + 1, 1] = requiredNum\n            innerNumsLeft.remove(requiredNum)\n            i += 1\n        # Check to see if we placed all the\n        # numbers, and that the last leg is\n        # the correct sum\n        if len(innerNumsLeft) == 0 and sum(ring[-1]) == sumToMeet:\n            print(''.join(map(str, np.ravel(ring))))\n\nRunning this code outputs all 16-digit configurations:\n2594936378711015\n2951051817673439\n6357528249411013\n6531031914842725\n0.8801705000000002 seconds.\n\nTherefore, the maximum 16-digit string is 6531031914842725.\n",
      "categories": ["project_euler"],
      "tags": ["25_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-08-13-068-Magic-5-gon-ring/"
    },{
      
      "title": "#70 - Totient permutation",
      "date": "2019-08-14 12:37:00 +0000",
      
      "content": "\n  Euler’s Totient function, $\\phi(n)$ [sometimes called the phi function], is used to determine the number of positive numbers less than or equal to $n$ which are relatively prime to $n$. For example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, $\\phi(9)=6$. The number 1 is considered to be relatively prime to every positive number, so $\\phi(1)=1$.\n\n  Interestingly, $\\phi(87109)=79180$, and it can be seen that $87109$ is a permutation of $79180$.\n\n  Find the value of $n, 1&lt;n&lt;10^7$, for which $\\phi(n)$ is a permutation of $n$ and the ratio $n/\\phi(n)$ produces a minimum.\n\n\n\nThere are a couple of changes from #69 - Totient maximum. We are looking for the minimum ratio as opposed to the maximum. Our upper bound has also increased to 10 million. The approach we used in problem 69 will not be good enough with this increased limit.\n\nIf $n/\\phi(n)$ needs to be minimuzed, then $\\phi(n)$ needs to be maximized. The totient function is directly related by the distinct prime factors of $n$ through\n\n\n  \n    \n      [\\phi(n) = n\\prod_{p\n      n}\\left(1-\\frac{1}{p}\\right)]\n    \n  \n\n\nNotice that $\\left(1-\\frac{1}{p}\\right)$ is something less than 1. Thus, the more prime factors we have, the smaller $\\phi(n)$ will be. If $n$ is prime, then $\\phi(n)=n-1$. However, $n-1$ will never be a permutation of $n$. The next case is when $n$ has 2 prime factors. If $n=p_1p_2$, then\n\n[\\begin{aligned}\n\t\\phi(n)&amp;=p_1p_2\\left(1-\\frac{1}{p_1}\\right)\\left(1-\\frac{1}{p_2}\\right)\n\t\\ &amp;=\n\tp_1p_2\\left(\\frac{p_1-1}{p_1}\\right)\\left(\\frac{p_2-1}{p_2}\\right)\n\t\\ &amp;=\n\t(p_1-1)(p_2-1)\n\\end{aligned}]\n\nWe want to keep this product as close to our upper bound of $10^7$ as possible, so we will need to choose prime factors close to $\\sqrt{10^7}\\approx 3162.278$. One way is to choose a “radius” of prime numbers around this value to check. There will need to be some trial and error, but I eventually settled on a radius of 2000. We generate primes between 1162 and 5162 and check to see when the ratio is minimized.\n# file: \"problem070.py\"\nlimit = 10 ** 7\ncenter = int(limit ** 0.5)\nprimes = np.array(primesieve.primes(center - 2000, center + 2000))\n# Keep a valid list of permutations...\ntotientPermutations = []\ncenterLoc = np.searchsorted(primes, center)\nfor i in range(centerLoc, len(primes)):\n    # Find location of largest factor which will\n    # not result in a product over limit. It's right-\n    # justified, so subtract 1\n    largestFactor = np.searchsorted(primes, limit // primes[i]) - 1\n    # Going backwards, calculate phi(n), and n, and append\n    # to our list of n is a permutation of phi(n)\n    for j in range(largestFactor, -1, -1):\n        # Phi(n) = (p1 - 1)(p2 - 1)\n        phi = (primes[i] - 1) * (primes[j] - 1)\n        n = primes[i] * primes[j]\n        if sorted(str(n)) == sorted(str(phi)):\n            totientPermutations.append([n, phi])\n\n# Convert to numpy array, take ratios,\n# and find the one with the smallest.\ntotientPermutations = np.array(totientPermutations)\nratios = totientPermutations[:, 0] / totientPermutations[:, 1]\nprint(totientPermutations[np.argmin(ratios)])\n\nThe output is\n[8319823 8313928]\n0.19818319999999995 seconds.\n\nThus, $n=\\mathbf{8319823}$ will gives us the minimum ratio. The totient is a permutation of $n$ as well.\n",
      "categories": ["project_euler"],
      "tags": ["20_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-08-14-070-Totient-permutation/"
    },{
      
      "title": "#87 - Prime power triples",
      "date": "2019-08-15 10:51:00 +0000",
      
      "content": "\n  The smallest number expressible as  the sum of a prime square, prime cube, and prime fourth is 28. In fact, there are exactly four numbers below fifty that can be expressed in such a way:\n\n\\[28 = 2^2+2^3+2^4\n\\\\\n33 = 3^2+2^3+2^4\n\\\\\n49 = 5^2+2^3+2^4\n\\\\\n47 = 2^2+3^3+2^4\\]\n\n  How many numbers below fifty million can be expressed as the sum of a prime square, prime cube, and prime fourth power?\n\n\n\nDue to the sum, the primes need to be less than $\\sqrt{50000000}=7071.068$. We can easily generate all primes up to this limit, and subsequently choose a prime fourth power, third power, and second power on down.\n\nOnce we’ve chosen a prime to represent the fourth power, we subtract this from fifty million, and take the cube root to obtain the maximum prime that can be cubed.We do the same with the square root. With this method, we can greatly reduce the number of primes we have to test. We use a boolean sieve which we sum at the end in order to count the numbers.\n# file: \"problem087.py\"\ndef sieve(n):\n    primes = list(range(2, n+1))\n    # For each number, cross out\n    # numbers that are multiples of it.\n    for i, p in enumerate(primes):\n        j = i + 1\n        while j &lt; len(primes):\n            if primes[j] % p == 0:\n                del primes[j]\n            j += 1\n    return primes\n\nlimit = 50000000\nprimes = sieve(int(limit ** 0.5) + 1)\n\nsumSieve = [False] * limit\nk = 0\nwhile primes[k] ** 4 &lt; limit:\n    s1 = primes[k] ** 4\n    i = 0\n    while primes[i] &lt; (limit - s1) ** (1/3):\n        s2 = s1 + primes[i] ** 3\n        j = 0\n        while j &lt; len(primes) and primes[j] &lt; (limit - s2) ** (1/2):\n            s3 = s2 + primes[j] ** 2\n            sumSieve[s3] = True\n            j += 1\n        i += 1\n    k += 1\nprint(sum(sumSieve))\n\nRunning our loop gets us an output of\n1097343\n4.7940836000000004 seconds.\n\nThus, the sum of all numbers that satisfy the condition is 1097343.\n",
      "categories": ["project_euler"],
      "tags": ["20_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-08-15-087-Prime-power-triples/"
    },{
      
      "title": "#108 - Diophantine reciprocals I",
      "date": "2019-08-20 17:36:00 +0000",
      
      "content": "\n  In the following equation $x$, $y$, and $n$ are positive integers.\n\n\\[\\frac{1}{x} + \\frac{1}{y} = \\frac{1}{n}\\]\n\n  For $n=4$ there are exactly three distinct solutions:\n\n\\[\\begin{aligned}\n    \\frac{1}{5} + \\frac{1}{20} &amp;= \\frac{1}{4}\n    \\\\\n    \\frac{1}{6} + \\frac{1}{12} &amp;= \\frac{1}{4}\n    \\\\\n    \\frac{1}{8} + \\frac{1}{8} &amp;= \\frac{1}{4}\n\\end{aligned}\\]\n\n  What is the least value of $n$ for which the number of distinct solutions exceeds one-thousand?\n\n  This problem is an easier verison of #110 - Diophantine reciprocals II; it is strongly advised that you solve this one first.\n\n\n\nSince we are dealing with positive fractions, both $x$ and $y$ should be strictly greater than $n$. Suppose $x$ and $y$ exceed $n$ by $a$ and $b$ respectively. Then, we can rewrite the equation as follows:\n\n[\\begin{aligned}\n    \\frac{1}{a+n} + \\frac{1}{b+n} &amp;= \\frac{1}{n}\n    \n    \\frac{a+b+2n}{(a+n)(b+n)} &amp;= \\frac{1}{n}\n    \n    ab + an + bn + n^2 &amp;= an + bn + 2n^2\n    \n    ab &amp;= n^2\n\\end{aligned}]\n\nThe conclusion is that any values $a$ and $b$ which multiply together to get $n^2$ are valid solutions to the original problem. For example, with $n=4$, we have $n^2=16$. There are 3 pairs of numbers which multiply together to get 16: {1, 16}, {2, 8}, and {4, 4}. These correspond to the 3 solutions in the problem (by adding 4 to each): {5, 20}, {6, 12}, and {8, 8}.\n\nSo now we solve a reframed problem: How many pairs of integers are there that multiply together to get $\\mathbf{n^2}$. We would need the number of factors of $n^2$ in order to solve this. Since $n$ is a duplicated factor, the number of factors will be odd. 16 had 5 factors (1, 2, 4, 8, 16), which produced (5+1)/2 = 3 solutions.\n\nTo find the number of factors of $n^2$, we need the prime factorization of $n^2$. If the prime factorization of $n^2=p_1^{e_1}p_2^{e_2}\\cdots p_k^{e_k}$, then the number of factors $f(n^2)$ is given by:\n\n\\(f(n^2) = \\prod_{i=1}^k (e_i + 1)\\)\nThis is true for any number, not just $n^2$. We add one to account for the duplicated factor, then divide 2, in other words, the number of solutions $S(n)$ is given by:\n\n[S(n) = \\frac{f(n^2) + 1}{2}]\n\nWe are given the number of solutions we need to find, and asked to find $n$. Our solution will be working backwards. If $S(n)&gt; 1000$, then $f(n^2) \\geq 2000$. To keep $n$ as small as possible, we must keep the exponents as small as possible. For $n^2$, we would want the exponents to only be either 2 or 4. In that case, when we calculate $f(n^2)$ the product will consist of 3s and 5s. Finding the smallest number with only these multiplicands will give us the smallest solution.\n\nWe want the smallest number greater than 2000 that only has 3 and 5 as factors. To generate them in order, we will keep two pointers $p_3$ and $p_5$ (0-indexed) that point to the previous number we multiplied by 3 or 5 respectively in the array $A$. At each step we compare $3A[p_3]$ and $5A[p_5]$ and add whichever product is smaller (and increment its corresponding pointer). If they’re equal, we increment both. Here’s an example to generate them in order:\n\n  First, start with $A=[1]$, and $p_3=p_5=0$.\n  Compare $3\\times 1$ and $5\\times 1$. The former is smaller, so we add 3 to the array and increment $p_3$. $A=[1,3]$ and $p_3=1$.\n  Compare $3\\times 3$ and $5\\times 1$. The latter is smaller, so we add 5 and increment $p_5$. $A=[1,3,5]$ and $p_5=1$.\n  $3\\times 3 &lt; 5\\times 3$. Add 9 and increment $p_3$. $A=[1,3,5,9]$ and $p_3=2$.\n  Here, $3\\times 5 = 5\\times 3$. Add 15 to the array and increment both. $A=[1,3,5,9,15]$ and $p_3=3$ and $p_5=2$.\n\n\nIn this fashion, we keep generating numbers until we go past our limit. We see the smallest number greater than 2000 is $3^4\\times 5^2=2025$.\n\nThis factorization tells us that in $f(n^2)$, we are multiplying by 3 four times and 5 twice. Since these correspond to exponents, this means we have four prime squares, and two prime fourth powers in the prime factorization of $n^2$. Going a step further, in the factorization of $\\mathbf{n}$, we have four prime singletons, and two prime squares.\n\nTo keep the value as small as possible, we assign larger powers to the smaller primes, and smaller powers to the larger primes. This means the minimum solution is $2^2\\times 3^2\\times 5\\times 7\\times 11\\times 13 = \\mathbf{180180}$.\n\nThe code is only to calculate the smallest number above 2000 that only contains 3 and 5.\n# file: \"problem108.py\"\nfactLimit = 2001\n# Find smallest integer greater than\n# factLimit that only has 3 and 5 as prime factors\n# Two pointers to the current multiplicand\n# for either 3 or 5.\nthreePoint = 0\nfivePoint = 0\nintegers = [(1, [])]  # Start with 1 = 3^0 x 5^0\nwhile integers[-1][0] &lt; factLimit:\n    # Find the minimum value of 3 multiplied\n    # by the value at threePoint and 5 with\n    # value at fivePoint. Increment the pointer\n    # depending on which was chosen.\n    # If they're both equal, then we add one of them\n    # and increment both.\n    if 3 * integers[threePoint][0] &lt; 5 * integers[fivePoint][0]:\n        integers.append((3 * integers[threePoint][0], integers[threePoint][1] + [3]))\n        threePoint += 1\n    elif 5 * integers[fivePoint][0] &lt; 3 * integers[threePoint][0]:\n        integers.append((5 * integers[fivePoint][0], integers[fivePoint][1] + [5]))\n        fivePoint += 1\n    else:\n        integers.append((3 * integers[threePoint][0], integers[threePoint][1] + [3]))\n        threePoint += 1\n        fivePoint += 1\n\n# Calculate value.\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\nprod = 1\n# Sort the powers greatest to least\nfor i, power in enumerate(sorted(integers[-1][1], key=lambda x: -x)):\n    prod *= primes[i] ** (power - 1)\nprint(int(prod ** 0.5), 'with', (integers[-1][0] + 1) // 2, 'solutions.')\n\nRunning the code gets the correct output of,\n180180 with 1013 solutions.\n5.779999999999674e-05 seconds.\n\nThus, our final answer is 180180.\n",
      "categories": ["project_euler"],
      "tags": ["30_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-08-20-108-Diophantine-reciprocals-I/"
    },{
      
      "title": "#110 - Diophantine reciprocals II",
      "date": "2019-08-21 15:17:00 +0000",
      
      "content": "\n  In the following equation, $x$, $y$, and $n$ are positive integers.\n\n\\[\\frac{1}{x} + \\frac{1}{y} = \\frac{1}{n}\\]\n\n  It can be verified that when $n=1260$ there are 113 distinct solutions and this is the least value of $n$ for which the total number of distinct solutions exceeds one hundred.\n\n  What is the least value of $n$ for which the number of distinct solutions exceeds four million?\n\n  This problem is a much more difficult version of #108 - Diophantine reciprocals I\n\n\n\nPlease read the solution of #108 - Diophantine reciprocals I as it contains important concepts. In that problem, we assumed that the number of solutions will only have 3 and 5 as prime factors in order to keep the exponents of $n$ small. However, we cannot make the same assumption in this problem, as the number of solutions is much too large.\n\nWe need the least value of $n$ such that $f(n^2) &gt; 8000000$. While we can’t say anything about which prime factors are in this value, we can say that the maximum prime factor is 47, since 3 is the minimum exponent, and $\\lceil\\log_3 8000000\\rceil=15$, and the 15th prime factor is 47.\n\nUnfortunately, while we can write an algorithm to generate all numbers with prime factors 2 to 47, it would take a massive amount of time to run, since we would need to run through all possible cobinations of factors (of which there are $2^{15}$) of them.\n\nInstead, what we can do instead is find a list of candidate solutions and pick out our solution from that list. However, we need an upper bound in order to do that.\n\nFinding an upper bound\nWe need an upper bound $B$ such that there is some $n&lt;B$ with at least 4 million solutions. We can use the factorial function here, as it’s one of the most fastest growing functions. We can find the least $K$ such that $K!$ has at least 4 million solutions. Recall we need the prime factorization of $K!$ in order to find the number of solutions. Legendre’s formula, which utilizes divisibility to find the pwoer of each prime, can help us with this.\n\nOnce we’ve found the prime factorization of $K!$, we know the minimum solution must exist below it. At this point, we can loop through all possible values of the exponents, since we have the maximum prime number possible (47) and we have limits on each individual exponent.\n\nThis is done with recursion, where we can also decrease the remaining upper bound as we go e.g. if we have $2^8$ in our product so far, then the rest of the product shouldn’t exceed $\\frac{K!}{2^8}$. Our final roadmap is as follows:\n\n  Find the least integer $K$ such that $K!$ has at least 4 million solutions, or 8 million factors.\n  Of the prime factors in that factorization of $K!$, loop through all integers that are less than $K!$.\n  Any integers that have at least 8 million factors get added to a running list.\n  The minimum value of that list is our answer.\n\n\nLegendre’s formula\nPlease see this wiki for a detailed statement of the formula, as well as an example of it in action.\n# file: \"problem110.py\"\ndef primeFactorFactorial(n):\n    # Use Legendre's formula.\n    # We check until the greatest prime less than n\n    primes = primesieve.primes(n)\n    powers = []\n    # For each prime...until halfway\n    i = 0\n    while primes[i] &lt;= n/2:\n        prime = primes[i]\n        # Find largest power of prime\n        # less than n...\n        stopInt = int(math.log(n, prime))\n        padic = sum(n // (prime ** np.arange(1, stopInt+1, dtype=int)))\n        powers.append(padic)\n        i += 1\n    # All primes that are more than\n    # half are guaranteed to only have\n    # one power. So extend the powers\n    # array by however many 1s...\n    powers.extend([1] * (len(primes) - i))\n    return np.array(primes, dtype=object), np.array(powers, dtype=object)\n\nWith this, we get that $K=34$, so $34!$ is an upper bound that has at least 8 million factors.\nRecursive function\nWe keep track of which prime we’ve chosen, the list of all prime factors, the current prime divisors that are part of our product, and the remaining limit.\n\n  If our location goes off the end of the list, then we yield the number through the current prime divisors.\n  Otherwise, we loop all possible exponents of the current prime, and recurse with each chosen power, decreasing the limit accordingly. For example, with our original limit of $34!$, say we had $2^2\\times 3^2$ as our current running total. The exponent limit for 5 would be $\\lceil \\log_5\\left(\\frac{34!}{2^2\\times3^2}\\right)\\rceil + 1$. In this way, our limit actually decreases fairly quickly, and the recursion depth isn’t as deep as it would be.\n  Exponents are only even, so we increment by 2.\n\n\n# file: \"problem110.py\"\ndef loopThroughNums(currDivLoc, currDivPowers, divisors, limit):\n    # Base case is when we're over\n    # the current divisor location.\n    # In this case, we can yield a value.\n    if currDivLoc &gt;= len(currDivPowers):\n        yield currDivPowers, np.prod(divisors ** currDivPowers)\n\n    # For each possible divisor value\n    # in the current location, yield all\n    # possible values with that power...\n    else:\n        if currDivLoc == 0:\n            loopLimit = math.ceil(math.log(limit, divisors[currDivLoc]))\n        else:\n            loopLimit = min(currDivPowers[currDivLoc - 1] + 1, math.ceil(math.log(limit, divisors[currDivLoc])))\n        powerCopy = np.array(currDivPowers)\n        # Only doing square numbers, so go by 2s\n        for powerVal in range(0, loopLimit, 2):\n            powerCopy[currDivLoc] = powerVal\n            for product in loopThroughNums(currDivLoc + 1, powerCopy, divisors,\n                                           limit / np.prod(divisors[currDivLoc] ** powerCopy[currDivLoc])):\n                yield product\n\nPutting it all together\nWe have two functions, so combine them. At the end we take the minimum of our list.\n# file: \"problem110.py\"\nsolsRequired = 4000000\nfactLimit = (solsRequired + 1) * 2 - 1\n# Get the first n primes where n is ceil(log_2(factLimit))\nprimes = np.array(primesieve.n_primes(math.ceil(math.log(factLimit, 2))), dtype=object)\n# Get the factorial amount which has at least factLimit factors...\nn = 2\n_, powers = primeFactorFactorial(2)\nwhile np.prod(powers + 1) &lt; factLimit:\n    n += 1\n    _, powers = primeFactorFactorial(n)\n\nprint('{}! has at least {} solutions.'.format(n, solsRequired))\n\n# Now we loop through all SQUARE numbers\n# meaning prime factorizations with even numbers\n# that are less than n! Any number with at least\n# factLimit factors, we yield and collect the\n# integer value to a list. Finally,\n# we take the minimum of that list, which becomes\n# our answer.\npossibilities = []\ncount = 0\nfor powers, value in loopThroughNums(0, np.zeros(len(primes), dtype=object), primes, math.factorial(n)):\n    count += 1\n    if np.prod(powers + 1) &gt; factLimit:\n        possibilities.append(int(value ** 0.5))\n\nprint('Checked', count, 'values.')\nprint('Minimum value is', min(possibilities))\n\nRunning this code results in an output of,\n34! has at least 4000000 solutions.\nChecked 47204 values.\nMinimum value is 93501300498606000600\n8.538059700000002 seconds.\n\nWe see that there were 47204 values below 34! which had at least 8 million factors. Our answer is the minimum of these, which is 9350130049860600.\n",
      "categories": ["project_euler"],
      "tags": ["40_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-08-21-110-Diophantine-reciprocals-II/"
    },{
      
      "title": "#162 - Hexadecimal numbers",
      "date": "2019-08-23 15:58:00 +0000",
      
      "content": "\n  In the hexadecimal number system numbers are represented using 16 different digits:\n\n\\[0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F\\]\n\n  The hexadecimal number AF when written in the decimal number system equals $10\\times 16+15=175$.\n\n  In the 3-digit hexadecimal numbers 10A, 1A0, A10, and A01 the digits 0, 1, and A are all present. Like numbers written in base ten we write hexadecimal numbers without leading zeroes.\n\n  How many decimal numbers containing at most sixteen hexadecimal digits exist with all of the digits 0, 1, and A present at least once? Give your answer as a hexadecimal number.\n\n  (A,B,C,D,E and F in upper case, without any leading or trailing code that marks the number as hexadecimal and without leading zeroes, e.g. 1A3F and not: 1a3f and not 0x1a3f and not $1A3F and not #1A3F and not 0000001A3F)\n\n\n\nIn this case, we will count the complement as that is a smaller set. Then we will subtract it from the whole set of numbers. The complement is “hexadecimal numbers that are missing at least one of 0, 1, or A.”\n\nWith $n$ digits (none starting with 0), we can choose any of the 15 non-zero numbers for the first digit, and then anythnig for the rest of the $n-1$ digits. Thus, in total there are $15\\times 16^{n-1}$ $n$-digit hexadecimal numbers. From this, we subtract the number of hexadecimal numbers that are missing 0, 1, or A.\n\n\n  Missing 0: With 0 removed, we have 15 choices for each digit, in total there are $15^n$.\n  Missing 1: We have 15 choices, but only 14 for the first digit (0 is still there), so in total $14\\times 15^{n-1}$.\n  Missing A: Same as the above case, $14\\times 15^{n-1}$.\n\n\nSo in total, there are $15^n+2\\times 14\\times 15^{n-1}$. However, we double-counted instances where the number is missing two of the above digits (“BA3” for example, is missing both 0 and 1). We add back in all numbers that have two of the above missing.\n\n  Missing 0 and 1: There are 14 choices for each digit, so in total $14^n$.\n  Missing 0 and A: Same as above case, $14^n$.\n  Missing 1 and A: We have 13 choices for the first digit (0 is still there) and 14 for the rest, in total $13\\times 14^{n-1}$.\n\n\nThe total we add back is then $2\\times 14^n + 13\\times 14^{n-1}$. However, we double-counted again, this time we added back in numbers that are missing all three. We need to subtract these off. The number of hexadecimal numbers that are missing all three is just $13^n$, as we have 13 choices for each digit.\n\nIn total, the number of $n$-digit numbers that have at least one 0, one 1, and one A is\n\n[\\begin{aligned}\n\tc(n) &amp;= \n\t\t\\underbrace{15\\times16^{n-1}}\\text{all numbers} -\n\t\t\\underbrace{\\left( 15^n+2\\times14\\times15^{n-1} \\right)}\\text{missing one of 0, 1, A} + \n\t\t\\underbrace{\\left( 2\\times14^n+13\\times14^{n-1} \\right)}\\text{missing two of 0, 1, A} - \n\t\t\\underbrace{13^n}\\text{missing all 3}\n\t\\ &amp;=\n\t15\\times 16^{n-1} - 15^{n-1}(15+28) + 14^{n-1}(28+13)-13^n\n\t\\ &amp;=\n\t\\boxed{15\\times 16^{n-1} - 43\\times15^{n-1} + 41\\times 14^{n-1} - 13^n}\n\\end{aligned}]\n\nSince we have an expression for $c(n)$, all we have to do is sum the values up to $n=16$. The hex() function converts the final number to hexadecimal. It contains “0x” at the beginning so we index this out, and we can call .upper() to make all the letters uppercase.\n# file: \"problem162.py\"\ncountNums = lambda n: 15 * 16 ** (n-1) - 43 * 15 ** (n-1) + 41 * 14 ** (n-1) - 13 ** n\nprint(hex(sum(countNums(i) for i in range(3, 17)))[2:].upper())\n\nRunning this very short program, we have\n3D58725572C62302\n4.590000000004313e-05 seconds.\n\nTherefore, our answer for the total hexadecimal numbers up to 16 digits is 3D58725572C62302.\nBonus\nWe can actually find a closed-form solution for the sum. We will use the fact that $\\sum_{n=1}^N a^n = \\frac{a^{N+1}-1}{a-1}-1$. Because $c(1)=c(2)=0$, we can start our summation from $n=1$. Therefore,\n\n[\\begin{aligned}\n\\sum_{n=1}^N c(n) &amp;= 15\\sum_{n=1}^N 16^{n-1} -\n\t43\\sum_{n=1}^N 15^{n-1} + \n\t41\\sum_{n=1}^N 14^{n-1} -\n\t\\sum_{n=1}^N 13^n\n\\ &amp;=\n\t15\\left( \\frac{16^N-1}{16-1}-1 \\right) -\n\t43\\left( \\frac{15^N-1}{15-1}-1 \\right) +\n\t41\\left( \\frac{14^N-1}{14-1}-1 \\right) -\n\t\\left( \\frac{13^{N+1}-1}{13-1}-1 \\right)\n\\ &amp;=\n\t16^N-1-15 - \n\t\\frac{43}{14}\\left(15^N-1\\right)+43 +\n\t\\frac{41}{13}\\left(14^N-1\\right)-41 -\n\t\\frac{1}{12}\\left(13^{N+1}-1\\right)+1\n\\ &amp;=\n\t16^N - \\frac{43}{14}15^N + \\frac{41}{13}14^N - \\frac{1}{12}13^{N+1} - 13 + \\frac{1}{1092}\n\\end{aligned}]\n\nPlugging in $N=16$ and converting to hexadecimal gets us the same answer. The fractions will neatly cancel out, as 1092 has 14, 13, and 12 as factors.\n",
      "categories": ["project_euler"],
      "tags": ["45_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2019-08-23-162-Hexadecimal-numbers/"
    },{
      
      "title": "#173 - Using up to one million tiles how many different 'hollow' square laminae can be formed?",
      "date": "2020-01-02 12:47:00 +0000",
      
      "content": "\n  We shall define a square lamina to be a square outline with a square “hole” so that the shape possesses vertical and horizontal symmetry. For example,  using exactly thiry-two square tiles we can form two different square lamina.\n\n  \n\n  With one-hundred tiles, and not necessarily using all of the tiles at one time, it is possible to form forty-one different square laminae.\n\n  Using up to one million tiles how many different square laminae can be formed?\n\n\n\nTo count the different ways, we can keep the distance between the hole and the larger side constant, and count how many laminae can be made with that distance. In the first square in the example, the distance between the hole and the side is 2, while in the 2nd square, the distance is 1.\n\nIf we keep the distance constant, we will vary the size of the hole. Given the hole side length $s_h$ and the distance to the side as $k$, the number of tiles needed is difference in areas. The hole area is $s_h^2$, while the area of the larger square is $(s_h+2k)^2$.\n\n[(s_h+2k)^2-s_h^2=s_h^2+4ks_h+4k^2-s_h^2 = 4k(s_h+k)]\n\nSince we are keeping $k$ constant, we want to see what the maximum hole size would be. If we are allowed a max of $T$ tiles, then the maximum hole size is\n\n[\\begin{aligned}\n\t4k(s_h+k) &amp;\\leq T\n\t\n\ts_h+k &amp;\\leq \\frac{T}{4k}\n\t\n\ts_h &amp;\\leq \\frac{T}{4k}-k\n\\end{aligned}]\n\nTherefore, for each distance $k$, the total number of tilings with that distance is $\\lfloor \\frac{T}{4k}-k \\rfloor$. The maximum distance we can have will occur when the hole size is 1. So we set $s_h=1$ and solve for $k$:\n\n[\\begin{aligned}\n\t&amp;1 \\leq \\frac{T}{4k}-k\n\t\n\t4k^2+4k-T \\leq\\, &amp;0\n\t\n\t\\frac{-4-\\sqrt{16-4(4)(-T)}}{8} \\leq\\, &amp;k \\leq \\frac{-4+\\sqrt{16-4(4)(-T)}}{8}\n\t\n\t-\\frac{\\sqrt{T+1}+1}{2} \\leq\\, &amp;k \\leq \\frac{\\sqrt{T+1}-1}{2}\n\\end{aligned}]\n\nThe left side is negative, so we take the right side. We know have all the pieces required to calculate the number we want.\n\nWe simply write a loop from $k=1$ up to $\\frac{\\sqrt{T+1}-1}{2}$ and add the number of tilings with that distance.\n# file: \"problem173.py\"\nT = 10 ** 6\n# Maximum distance between\n# inner hole and edge\nmaxK = int(((1 + T) ** 0.5 - 1) / 2)\n# For each inner distance, find\n# number of tilings possible,\n# with number of tiles &lt;= 100\nnumOfTilings = 0\nfor k in range(1, maxK + 1):\n    # The number of tilings with this distance k...\n    numOfTilings += int(T / (4 * k) - k)\n\nprint(numOfTilings)\n\nOr, if you prefer a one-liner:\n# file: \"problem173.py\"\nT = 10 ** 6\nprint(sum(int(T / (4 * k) - k) for k in range(1, int(((1 + T) ** 0.5 - 1) / 2) + 1)))\n\nRunning the one-liner code, we have\n1572729\n0.00018640000000003099 seconds.\n\nTherefore, the number of ways is 1572729.\n",
      "categories": ["project_euler"],
      "tags": ["30_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2020-01-02-173-Hollow-square-laminae/"
    },{
      
      "title": "#187 - Semiprimes",
      "date": "2020-01-02 14:05:00 +0000",
      
      "content": "\n  A composite is a number containing at least two prime factors. For example, $15=3\\times5$; $9=3\\times 3$; $12=2\\times 2\\times 3$.\n\n  There are ten composites below thirty containing precisely two, not necessarily distinct, prime factors: 4, 6, 9, 10, 14, 15, 21, 22, 25, 26.\n\n  How many composite integers, $n&lt;10^8$, have precisely two, not necessarily distinct, prime factors?\n\n\n\nSince we are only concerned about numbers with two factors, the larger of the two must not be more than half the limit. We can solve this with a double for loop if we have a prime flag array. The maximum value of the smaller prime can’t exceed the square root of the limit. Once we have this factor, we count all primes that are larger than this prime and add it to a running total. By enforcing the smaller factor, it avoids double counting $2\\times 3$ and $3\\times 2$ twice. I use primesieve.numpy as pnp so I can easily flag the primes.\n\n# file: \"problem187.py\"\nlimit = 10 ** 8\n# Only need primes halfway\nprimes = pnp.primes(limit / 2)\n# Take as little space as possible with\n# np.uint8\nprimeFlags = np.zeros(limit // 2, dtype=np.uint8)\nprimeFlags[primes] = 1\ndel primes  # Get rid of it, we don't need it anymore!\n\ntotal = 0\ni = 0\n# The smaller of the two can't exceed the \n# square root of the limit...\nwhile i &lt;= limit ** 0.5 + 1:\n    if primeFlags[i]:\n        # Count primes up till limit // i to ensure\n        # the resulting number does not exceed\n        # the limit.\n        total += np.sum(primeFlags[i: limit // i + 1])\n    i += 1\nprint(total)\n\nRunning this short loop, we get\n17427258\n0.22744560000000003 seconds.\n\nThus, there are 17427258 composite integers below $10^8$ with exactly two prime factors.\n",
      "categories": ["project_euler"],
      "tags": ["25_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2020-01-02-187-Semiprimes/"
    },{
      
      "title": "#138 - Special isosceles triangles",
      "date": "2020-04-05 09:15:00 +0000",
      
      "content": "\n  Consider the isosceles triangle with base length, $b=16$, and legs, $L=17$.\n\n  \n\n  By using the Pythagorean theorem it can be seen that the height of the triangle, $h=\\sqrt{17^2-8^2}=15$, which is one less than the base length.\n\n  With $b=272$ and $L=305$, we get $h=273$, which is one more than the base length, and this is the second smallest isosceles triangle with the property that $h=b\\pm1$.\n\n  Find $\\sum L$ for the twelve smallest isosceles triangles for which $h=b\\pm1$ and $b,L$ are positive integers.\n\n\n\nWhenever you drop the height of an isosceles triangle down to the base, it cuts the base in two and produces two right triangles, whose leg lengths are $b/2$ and $h$, with hypotenuse $L$. Since we want $h=b\\pm1$, then $b/2&lt;h$.\n\nLet’s say that $\\alpha=h$, $\\beta=b/2$, and $\\gamma=L$. To have our original property hold, we need to find Pythagorean triples such that $2\\beta=\\alpha\\pm1$. Additionally, this also means the triples have to be primitive, because if they weren’t, the difference would be greater than 1. We can use the Pythaogrean tree as we did in previous problems.\n\nLooking at the tree, the two solutions given in the problem correspond to the (15, 8, 17) and (273, 136, 305) triangles. It seems we multiplied by $C$ for the first triple, then multiplied by $B$ then $C$ to get the second one. Does this pattern hold? If we multiply by $CB$ on the left again, let’s see if we get another solution.\n\n[(CB)^2C\\overrightarrow{v} =\n \\begin{bmatrix}\n -545 &amp; 610 &amp; 818 \n -274 &amp; 305 &amp; 410 \n -610 &amp; 682 &amp; 915\n \\end{bmatrix}\n \\begin{bmatrix}\n 3 \\ 4 \\ 5\n \\end{bmatrix}\n= \\begin{bmatrix}\n 4895 \\ 2448 \\ 5473\n\\end{bmatrix}]\n\nIndeed, we have 2(2448) = 4896, which is one more than 4895. To prove this pattern works, one would need to go through the multiplication with a generic triple $(\\alpha, \\beta, \\gamma)$ and show that the rule holds with $CB$ and not with any other pair.\n\nThe only code is to define the matrics and multiply them together, which is quick and easy with numpy.\n# file: \"problem138.py\"\nB = np.array([\n    [1, 2, 2],\n    [2, 1, 2],\n    [2, 2, 3]\n], dtype=object)\nC = np.array([\n    [-1, 2, 2],\n    [-2, 1, 2],\n    [-2, 2, 3]\n], dtype=object)\n\nbaseTriple = np.array([15, 8, 17], dtype=object)\nCBprod = np.dot(C, B)\nsumL = 17\nlimit = 12\nfor _ in range(limit - 2):\n    CBprod = np.dot(np.dot(C, B), CBprod)\n    triple = np.dot(CBprod, baseTriple)\n    sumL += triple[-1]\nprint(sumL)\n\nRunning this short loop, we get\n1118049290473627\n0.00019860000000002098 seconds.\n\nThus, the sum of all hypotenuses is 1118049290473627.\n",
      "categories": ["project_euler"],
      "tags": ["45_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2020-04-05-138-Special-isosceles-triangles/"
    },{
      
      "title": "#176 - Right-angled triangles that share a cathetus",
      "date": "2020-05-31 19:59:00 +0000",
      
      "content": "\n  The four right-angled triangles with sides (9, 12, 15), (12, 16, 20), (5, 12, 13) and (12, 35, 37) all have one of the shorter sides (catheti) equal to 12. It can be shown that no other integer sided right-angled triangle exists with one of the catheti equal to 12.\n\n  Find the smallest integer that can be the length of a cathetus of exactly 47547 different integer sided right-angled triangles.\n\n\n\nOn the Wolfram Mathworld page for Pythagorean Triples, we find the following formula for the number of triangles with leg length $s$.\n\n[L(s) = \\begin{cases}\n    \\frac{1}{2}[(2a_1+1)(2a_2+1)\\cdots(2a_n+1)-1] \\qquad &amp;\\text{for }a_0=0\n    \n    \\frac{1}{2}[(2a_0-1)(2a_1+1)(2a_2+1)\\cdots(2a_n+1)-1] \\qquad &amp;\\text{for }a_0\\geq 1\n\\end{cases}]\n\nwhere $s=2^{a_0}p_1^{a_1}\\cdots p_n^{a_n}$.\n\nWe can verify this using the example given in the problem. $s=12=2^2\\times 3$. Therefore, since $a_0=2\\geq 1$, we use the second case, and $L(12) = \\frac{1}{2}[(2(2)-1)(2(1)+1)-1] = \\frac{1}{2}(3(3)-1) = 4$.\n\nBut we’re not asked to find $L(s)$. Instead, we are given what $L(s)$ is, and asked to find the minimum value of $s$. We want $L^{-1}(s)$.\n\nThe first thing we do is adjust the formula to accommodate the inverse. Assuming $s$ is broken down into its prime factorization, we multiply by 2 and 1 to $L(s)$, and keep the product on the other side. Because we want the smallest $s$, we want $s$ to have powers of 2, and not potentially anything larger. (12 has a power 12, 15 does not, but both evaluate to 4 triangles).\n\n[(2a_0-1)(2a_1+1)(2a_2+1)\\cdots(2a_n+1)=2L(s)+1]\n\nOn the left, we are multiplying numbers together, so maybe if we find the prime factorization of $\\mathbf{2L(s)+1}$, we can be a step closer to the answer.\n\nThe factorization of $2(47547)+1=95095$ is $5\\times 7\\times 11\\times 13\\times 19$. We have 5 factors, which can be split among 5 factors above (corresponding to $a_0,a_1,\\dots,a_4$). But which factor corresponds to which $a_i$? Remember $a_i$ corresponds to the exponent in the original factorization of $s$. In order to achieve the smallest product possible, we want the largest exponents on the smallest prime factors (and vice versa). Therefore, we want\n\n[\\begin{cases}\n    2a_0-1 &amp;= 19\n    \n    2a_1+1 &amp;= 13\n    \n    2a_2+1 &amp;= 11\n    \n    2a_3+1 &amp;= 7\n    \n    2a_4+1 &amp;= 5\n\\end{cases}]\n\nThese are simple equations, and the exponents for $s$ are then ${a_0,a_1,a_2,a_3,a_4}={10,6,5,3,2}$. Thus, the smallest $s$ which makes $L(s)=47547$ is\n\n[s=2^{10}\\times 3^6\\times 5^5\\times 7^3\\times 11^2 = \\boxed{96818198400000}]\n\nOur large answer is 96818198400000. No code necessary for this problem :). This worked because the factorization of $2L(s)+1$ had 5 clean factors we could evenly distribute. If the factorization were more complicated, we would have to check additional cases.\n",
      "categories": ["project_euler"],
      "tags": ["70_diff"],
      
      "collection": "posts",
      "url": "/blog/project_euler/2020-05-31-176-Right-angled-triangles-cathetus/"
    },{
      "image": "/assets/img/blog/jj-ying.jpg",
      "title": "What’s New in Hydejack 9.1?",
      "date": "2021-02-13 00:00:00 +0000",
      "description": "Version 9.1 provides minor design changes, new features, and closes multiple issues.\n",
      "content": "What’s New in Hydejack 9.1?\n\n\n  Stripe-ified Design\n  Inverted Sidebars\n  Code Block Headers\n  Resume Download Buttons\n  SERP Breadcrumbs\n  Last Modified At\n  Clap Button Preview\n  Credits\n\n\nStripe-ified Design\nMost elements now have rounded borders, making the design look more modern (dare I say “Stripe-ified”) than ever before.\n\nThe goal of Hydejack was always to provide a theme that looks “designed” combined the amenities of a typical Jekyll theme for coders.\nThis is an important step in maintaining this goal.\n\nAt the same time, I’m introducing nerdy elements like breadcrumbs, that are almost ornamental in nature.\nYou wouldn’t find these on other Stripe-like designs, but I think they are appealing to developer types like myself. \nLike most additions to Hydejack, they can be disabled via configuration.\n\nInverted Sidebars\nThe colors on the sidebar can now be inverted to allow brighter sidebar images. This can be enabled per-page in the fort matter:\n\ninvert_sidebar: true\n\n\nCode Block Headers\nCode blocks can now have headers:\n\n// file: 'hello-world.js'\nconsole.log('Hello World!');\n\n\nHeaders are added by making the first line a comment of the form (file|title): ['\"].*['\"], e.g.:\n\n~~~js\n// file: 'hello-world.js'\nconsole.log('Hello World!');\n~~~\n\n\nCode blocks with and without headers now also come with a copy button. \nIn the case of header-less code blocks, the button only shows on hover to prevent potential overlap.\n\nResume Download Buttons\nResumes can now have download buttons:\n\n\n\nResumes can now have download buttons.\n\nThe documentation has been updated with a chapter on how to configure the buttons.\n\nSERP Breadcrumbs\nAdded breadcrumbs above page title:\n\n\n\nBread crumbs are now shown above each page title.\n\nNote that this requires a directory-like URL structure on your entire site, \notherwise the intermediate links will point to nonexisting sites.\n\nOn a side note, Hydejack now has built-in tooltips for abbreviations like SERP (activated via tap/click).\nSee Example Content on how to add them to your content.\n\nLast Modified At\nBlog posts can now have a “last modified at” date in the sub title row.\n\n\n\nNote that this depends on the last_modified_at property of the page, which must be either set manually in the frontmatter (not recommended), or via a plugin like jekyll-last-modified-at. Note that the later is not available when building on GitHub Pages and can increase build times.\n\nClap Button Preview\nI’ve been trying something new with getclaps.app, a feedback and analytics tool for personal sites like those powered by Hydejack.\n\n\n\nIt is a separate product from Hydejack and not enabled by default. Because it depends on a backend component, it requires a monthly fee. \nIf enabled, it is placed below posts and pages where the dingbat character (❖) used to be.\n\nI can’t claim that this product is fully baked (feedback welcome), but I’ve been using it on my personal site and here for the last couple of months with no issues.\nFor more, see the dedicated website.\n\n\n\nThere are many more changes and bugfixes in 9.1. See the CHANGELOG for details.\n\nCredits\n\nPhoto by JJ Ying on Unsplash\n\n",
      "categories": ["example"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/example/2021-02-13-whats-new-in-hydejack-9-1/"
    },{
      
      "title": "Project Euler",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler is a site full of mathematical challenges that more often than not utilize programming to solve the problem.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/blog/project-euler/"
    },{
      
      "title": "5%",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler problems that are rated at 5% difficulty.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/blog/tag-05-diff/"
    },{
      
      "title": "10%",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler problems that are rated at 10% difficulty.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/blog/tag-10-diff/"
    },{
      
      "title": "15%",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler problems that are rated at 15% difficulty.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/blog/tag-15-diff/"
    },{
      
      "title": "20%",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler problems that are rated at 20% difficulty.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/blog/tag-20-diff/"
    },{
      
      "title": "25%",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler problems that are rated at 25% difficulty.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/blog/tag-25-diff/"
    },{
      
      "title": "30%",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler problems that are rated at 30% difficulty.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/blog/tag-30-diff/"
    },{
      
      "title": "35%",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler problems that are rated at 35% difficulty.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/blog/tag-35-diff/"
    },{
      
      "title": "40%",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler problems that are rated at 40% difficulty.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/blog/tag-40-diff/"
    },{
      
      "title": "45%",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler problems that are rated at 45% difficulty.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/blog/tag-45-diff/"
    },{
      
      "title": "50%",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler problems that are rated at 50% difficulty.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/blog/tag-50-diff/"
    },{
      
      "title": "55%",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler problems that are rated at 55% difficulty.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/blog/tag-55-diff/"
    },{
      
      "title": "70%",
      "date": "2023-06-27 03:46:57 +0000",
      "description": "Project Euler problems that are rated at 70% difficulty.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/blog/tag-70-diff/"
    },{
      "image": {"path":"/assets/img/projects/pe.jpg","srcset":{"1920w":"/assets/img/projects/pe.jpg","960w":"/assets/img/projects/pe@0,5x.jpg","480w":"/assets/img/projects/pe@0,25x.jpg"}},
      "title": "Project Euler",
      "date": "2015-07-15 00:00:00 +0000",
      "description": "I started doing Project Euler problems in 2015. Since then, I have solved 100+ problems on and off, and have written up solutions to all of them.\n",
      "content": "Project Euler is a list of hundreds of mathematical problems that require\nmathematical knowhow as well as programming skills to come to a solution. Each problem generally has\nsome mathematical concept hiding behind it. While there is no limit to the amount of time a program can \ntake when solving a problem, the site recommends a limit of one minute.\n\nHere, I provide solutions to all the problems I have solved so far, focusing on the mathematics\nas much as possible.\n\nOn problems where prime numbers are used in the solution, I liberally use the primesieve package,\nwhich provides handy prime generation capabilities. This may seem as cheating, but I believe that in \nmost cases the actual generation of primes is not the important concept needed to solve the problem.\n\nProject Euler also lists corresponding difficulty of each problem, ranging from 5% to 100%,\nin increments of 5. Below you can see all the posts that are demarcated by difficulty.\nFor a full list of all problems, please use the link above this post’s image.\n\nDifficulty\n\n  5%\n  10%\n  15%\n  20%\n  25%\n  30%\n  35%\n  40%\n  45%\n  50%\n  55%\n  60%\n  70%\n  75%\n  80%\n  85%\n  90%\n  95%\n  100%\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/project_euler/"
    },{
      "image": {"path":"/assets/img/projects/diva.jpg"},
      "title": "DIVA Gemstone (UMD)",
      "date": "2019-04-12 00:00:00 +0000",
      "description": "As part of the University of Maryland Gemstone Honors program, an interdisciplinary undergraduate team consisting of I and six other students researched novel climate visualizations using virtual reality under the mentorship of Dr. Stephen Penny. The project is titled Data Imaging and Visualization Analysis.\n",
      "content": "The Gemstone program of the University of Maryland is a division of the Honors program that focuses\non research and thesis writing. It is a 4-year program, with teams being created at the end of freshman year\non student and professor-created projects, culminating in Thesis defense in the spring of senior year.\nEach team has a mentor to guide the students throughout the research process.\n\nThe project my team and I focused was regarding the state of climate visualization tools used by climate\nscientists. They are largely outdated and unintuitive to use. Performing targeted analyses on specific\nclimate topics can be time-consuming and fairly shallow. To combat this, Dr. Stephen Penny (our mentor) \nproposed using virtual reality to produce climate visualizations.\n\nUsing an Oculus Rift as our main testing device, we were able to build visualizations of temperature \nrecordings and wind currents across the globe, along with a proof-of-concept local visualization of\nthe Chesapeake Bay. The local visualizations can be used to analysis different climate patterns after \nmajor events, for example, with Hurricane Harvey.\n\nWe also utilized a Leap Motion infrared sensor, which projects the user hands into the VR space. This\nadds intuitive user interaction to the tool, through mapping simple gestures to functionalities. For example,\none can close a fist to open a menu to control globe rotations.\n\nWe also performed some focus groups of get current Atmospheric and Oceanic Studies individuals \nto get feedback on the tool. The result was the implementation of a zoom feature on the local visualizations.\n\nThis was a large collaborative effort between me and the other team members: Teddy Corrales, Erin Estes,\nKevin Ho, Austin Hom, Justin Shen, and Justin Pan. Huge thanks to Dr. Stephen Penny for mentoring and guiding\nus throughout the whole process, as well as the Gemstone Honors program for setting up and the \ninfrastructure for this research effort. Please see the links above for our final thesis paper, the \npresentation slides, and the presentation recording itself.\n\nWe were awarded the James. A Wallace Outstanding Thesis Award for our thesis!\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/project_diva/"
    }
  ]
}

